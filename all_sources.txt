
// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\allocation\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <cstdlib>
#include <iostream>
#include <memory>
#include <type_traits>
#include <utility>
#include "asio.hpp"

using asio::ip::tcp;

// Class to manage the memory to be used for handler-based custom allocation.
// It contains a single block of memory which may be returned for allocation
// requests. If the memory is in use when an allocation request is made, the
// allocator delegates allocation to the global heap.
class handler_memory
{
public:
  handler_memory()
    : in_use_(false)
  {
  }

  handler_memory(const handler_memory&) = delete;
  handler_memory& operator=(const handler_memory&) = delete;

  void* allocate(std::size_t size)
  {
    if (!in_use_ && size < sizeof(storage_))
    {
      in_use_ = true;
      return &storage_;
    }
    else
    {
      return ::operator new(size);
    }
  }

  void deallocate(void* pointer)
  {
    if (pointer == &storage_)
    {
      in_use_ = false;
    }
    else
    {
      ::operator delete(pointer);
    }
  }

private:
  // Storage space used for handler-based custom memory allocation.
  typename std::aligned_storage<1024>::type storage_;

  // Whether the handler-based custom allocation storage has been used.
  bool in_use_;
};

// The allocator to be associated with the handler objects. This allocator only
// needs to satisfy the C++11 minimal allocator requirements.
template <typename T>
class handler_allocator
{
public:
  using value_type = T;

  explicit handler_allocator(handler_memory& mem)
    : memory_(mem)
  {
  }

  template <typename U>
  handler_allocator(const handler_allocator<U>& other) noexcept
    : memory_(other.memory_)
  {
  }

  bool operator==(const handler_allocator& other) const noexcept
  {
    return &memory_ == &other.memory_;
  }

  bool operator!=(const handler_allocator& other) const noexcept
  {
    return &memory_ != &other.memory_;
  }

  T* allocate(std::size_t n) const
  {
    return static_cast<T*>(memory_.allocate(sizeof(T) * n));
  }

  void deallocate(T* p, std::size_t /*n*/) const
  {
    return memory_.deallocate(p);
  }

private:
  template <typename> friend class handler_allocator;

  // The underlying memory.
  handler_memory& memory_;
};

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(tcp::socket socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    do_read();
  }

private:
  void do_read()
  {
    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_),
        asio::bind_allocator(
          handler_allocator<int>(handler_memory_),
          [this, self](std::error_code ec, std::size_t length)
          {
            if (!ec)
            {
              do_write(length);
            }
          }));
  }

  void do_write(std::size_t length)
  {
    auto self(shared_from_this());
    asio::async_write(socket_, asio::buffer(data_, length),
        asio::bind_allocator(
          handler_allocator<int>(handler_memory_),
          [this, self](std::error_code ec, std::size_t /*length*/)
          {
            if (!ec)
            {
              do_read();
            }
          }));
  }

  // The socket used to communicate with the client.
  tcp::socket socket_;

  // Buffer used to store data received from the client.
  std::array<char, 1024> data_;

  // The memory to use for handler-based custom memory allocation.
  handler_memory handler_memory_;
};

class server
{
public:
  server(asio::io_context& io_context, short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port))
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket socket)
        {
          if (!ec)
          {
            std::make_shared<session>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: server <port>\n";
      return 1;
    }

    asio::io_context io_context;
    server s(io_context, std::atoi(argv[1]));
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\buffers\reference_counted.cpp
//
// reference_counted.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>
#include <memory>
#include <utility>
#include <vector>
#include <ctime>

using asio::ip::tcp;

// A reference-counted non-modifiable buffer class.
class shared_const_buffer
{
public:
  // Construct from a std::string.
  explicit shared_const_buffer(const std::string& data)
    : data_(new std::vector<char>(data.begin(), data.end())),
      buffer_(asio::buffer(*data_))
  {
  }

  // Implement the ConstBufferSequence requirements.
  typedef asio::const_buffer value_type;
  typedef const asio::const_buffer* const_iterator;
  const asio::const_buffer* begin() const { return &buffer_; }
  const asio::const_buffer* end() const { return &buffer_ + 1; }

private:
  std::shared_ptr<std::vector<char> > data_;
  asio::const_buffer buffer_;
};

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(tcp::socket socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    do_write();
  }

private:
  void do_write()
  {
    std::time_t now = std::time(0);
    shared_const_buffer buffer(std::ctime(&now));

    auto self(shared_from_this());
    asio::async_write(socket_, buffer,
        [self](std::error_code /*ec*/, std::size_t /*length*/)
        {
        });
  }

  // The socket used to communicate with the client.
  tcp::socket socket_;
};

class server
{
public:
  server(asio::io_context& io_context, short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port))
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket socket)
        {
          if (!ec)
          {
            std::make_shared<session>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: reference_counted <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\chat\chat_client.cpp
//
// chat_client.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <deque>
#include <iostream>
#include <thread>
#include "asio.hpp"
#include "chat_message.hpp"

using asio::ip::tcp;

typedef std::deque<chat_message> chat_message_queue;

class chat_client
{
public:
  chat_client(asio::io_context& io_context,
      const tcp::resolver::results_type& endpoints)
    : io_context_(io_context),
      socket_(io_context)
  {
    do_connect(endpoints);
  }

  void write(const chat_message& msg)
  {
    asio::post(io_context_,
        [this, msg]()
        {
          bool write_in_progress = !write_msgs_.empty();
          write_msgs_.push_back(msg);
          if (!write_in_progress)
          {
            do_write();
          }
        });
  }

  void close()
  {
    asio::post(io_context_, [this]() { socket_.close(); });
  }

private:
  void do_connect(const tcp::resolver::results_type& endpoints)
  {
    asio::async_connect(socket_, endpoints,
        [this](std::error_code ec, tcp::endpoint)
        {
          if (!ec)
          {
            do_read_header();
          }
        });
  }

  void do_read_header()
  {
    asio::async_read(socket_,
        asio::buffer(read_msg_.data(), chat_message::header_length),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec && read_msg_.decode_header())
          {
            do_read_body();
          }
          else
          {
            socket_.close();
          }
        });
  }

  void do_read_body()
  {
    asio::async_read(socket_,
        asio::buffer(read_msg_.body(), read_msg_.body_length()),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            std::cout.write(read_msg_.body(), read_msg_.body_length());
            std::cout << "\n";
            do_read_header();
          }
          else
          {
            socket_.close();
          }
        });
  }

  void do_write()
  {
    asio::async_write(socket_,
        asio::buffer(write_msgs_.front().data(),
          write_msgs_.front().length()),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            write_msgs_.pop_front();
            if (!write_msgs_.empty())
            {
              do_write();
            }
          }
          else
          {
            socket_.close();
          }
        });
  }

private:
  asio::io_context& io_context_;
  tcp::socket socket_;
  chat_message read_msg_;
  chat_message_queue write_msgs_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: chat_client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    tcp::resolver resolver(io_context);
    auto endpoints = resolver.resolve(argv[1], argv[2]);
    chat_client c(io_context, endpoints);

    std::thread t([&io_context](){ io_context.run(); });

    char line[chat_message::max_body_length + 1];
    while (std::cin.getline(line, chat_message::max_body_length + 1))
    {
      chat_message msg;
      msg.body_length(std::strlen(line));
      std::memcpy(msg.body(), line, msg.body_length());
      msg.encode_header();
      c.write(msg);
    }

    c.close();
    t.join();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\chat\chat_server.cpp
//
// chat_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <deque>
#include <iostream>
#include <list>
#include <memory>
#include <set>
#include <utility>
#include "asio.hpp"
#include "chat_message.hpp"

using asio::ip::tcp;

//----------------------------------------------------------------------

typedef std::deque<chat_message> chat_message_queue;

//----------------------------------------------------------------------

class chat_participant
{
public:
  virtual ~chat_participant() {}
  virtual void deliver(const chat_message& msg) = 0;
};

typedef std::shared_ptr<chat_participant> chat_participant_ptr;

//----------------------------------------------------------------------

class chat_room
{
public:
  void join(chat_participant_ptr participant)
  {
    participants_.insert(participant);
    for (auto msg: recent_msgs_)
      participant->deliver(msg);
  }

  void leave(chat_participant_ptr participant)
  {
    participants_.erase(participant);
  }

  void deliver(const chat_message& msg)
  {
    recent_msgs_.push_back(msg);
    while (recent_msgs_.size() > max_recent_msgs)
      recent_msgs_.pop_front();

    for (auto participant: participants_)
      participant->deliver(msg);
  }

private:
  std::set<chat_participant_ptr> participants_;
  enum { max_recent_msgs = 100 };
  chat_message_queue recent_msgs_;
};

//----------------------------------------------------------------------

class chat_session
  : public chat_participant,
    public std::enable_shared_from_this<chat_session>
{
public:
  chat_session(tcp::socket socket, chat_room& room)
    : socket_(std::move(socket)),
      room_(room)
  {
  }

  void start()
  {
    room_.join(shared_from_this());
    do_read_header();
  }

  void deliver(const chat_message& msg)
  {
    bool write_in_progress = !write_msgs_.empty();
    write_msgs_.push_back(msg);
    if (!write_in_progress)
    {
      do_write();
    }
  }

private:
  void do_read_header()
  {
    auto self(shared_from_this());
    asio::async_read(socket_,
        asio::buffer(read_msg_.data(), chat_message::header_length),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec && read_msg_.decode_header())
          {
            do_read_body();
          }
          else
          {
            room_.leave(shared_from_this());
          }
        });
  }

  void do_read_body()
  {
    auto self(shared_from_this());
    asio::async_read(socket_,
        asio::buffer(read_msg_.body(), read_msg_.body_length()),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            room_.deliver(read_msg_);
            do_read_header();
          }
          else
          {
            room_.leave(shared_from_this());
          }
        });
  }

  void do_write()
  {
    auto self(shared_from_this());
    asio::async_write(socket_,
        asio::buffer(write_msgs_.front().data(),
          write_msgs_.front().length()),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            write_msgs_.pop_front();
            if (!write_msgs_.empty())
            {
              do_write();
            }
          }
          else
          {
            room_.leave(shared_from_this());
          }
        });
  }

  tcp::socket socket_;
  chat_room& room_;
  chat_message read_msg_;
  chat_message_queue write_msgs_;
};

//----------------------------------------------------------------------

class chat_server
{
public:
  chat_server(asio::io_context& io_context,
      const tcp::endpoint& endpoint)
    : acceptor_(io_context, endpoint)
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket socket)
        {
          if (!ec)
          {
            std::make_shared<chat_session>(std::move(socket), room_)->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
  chat_room room_;
};

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    if (argc < 2)
    {
      std::cerr << "Usage: chat_server <port> [<port> ...]\n";
      return 1;
    }

    asio::io_context io_context;

    std::list<chat_server> servers;
    for (int i = 1; i < argc; ++i)
    {
      tcp::endpoint endpoint(tcp::v4(), std::atoi(argv[i]));
      servers.emplace_back(io_context, endpoint);
    }

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\chat\posix_chat_client.cpp
//
// posix_chat_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include "asio.hpp"
#include "chat_message.hpp"

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

using asio::ip::tcp;
namespace posix = asio::posix;

class posix_chat_client
{
public:
  posix_chat_client(asio::io_context& io_context,
      const tcp::resolver::results_type& endpoints)
    : socket_(io_context),
      input_(io_context, ::dup(STDIN_FILENO)),
      output_(io_context, ::dup(STDOUT_FILENO)),
      input_buffer_(chat_message::max_body_length)
  {
    do_connect(endpoints);
  }

private:
  void do_connect(const tcp::resolver::results_type& endpoints)
  {
    asio::async_connect(socket_, endpoints,
        [this](std::error_code ec, tcp::endpoint)
        {
          if (!ec)
          {
            do_read_header();
            do_read_input();
          }
        });
  }

  void do_read_header()
  {
    asio::async_read(socket_,
        asio::buffer(read_msg_.data(), chat_message::header_length),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec && read_msg_.decode_header())
          {
            do_read_body();
          }
          else
          {
            close();
          }
        });
  }

  void do_read_body()
  {
    asio::async_read(socket_,
        asio::buffer(read_msg_.body(), read_msg_.body_length()),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            do_write_output();
          }
          else
          {
            close();
          }
        });
  }

  void do_write_output()
  {
    // Write out the message we just received, terminated by a newline.
    static char eol[] = { '\n' };
    std::array<asio::const_buffer, 2> buffers = {{
      asio::buffer(read_msg_.body(), read_msg_.body_length()),
      asio::buffer(eol) }};
    asio::async_write(output_, buffers,
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            do_read_header();
          }
          else
          {
            close();
          }
        });
  }

  void do_read_input()
  {
    // Read a line of input entered by the user.
    asio::async_read_until(input_, input_buffer_, '\n',
        [this](std::error_code ec, std::size_t length)
        {
          if (!ec)
          {
            // Write the message (minus the newline) to the server.
            write_msg_.body_length(length - 1);
            input_buffer_.sgetn(write_msg_.body(), length - 1);
            input_buffer_.consume(1); // Remove newline from input.
            write_msg_.encode_header();
            do_write_message();
          }
          else if (ec == asio::error::not_found)
          {
            // Didn't get a newline. Send whatever we have.
            write_msg_.body_length(input_buffer_.size());
            input_buffer_.sgetn(write_msg_.body(), input_buffer_.size());
            write_msg_.encode_header();
            do_write_message();
          }
          else
          {
            close();
          }
        });
  }

  void do_write_message()
  {
    asio::async_write(socket_,
        asio::buffer(write_msg_.data(), write_msg_.length()),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            do_read_input();
          }
          else
          {
            close();
          }
        });
  }

  void close()
  {
    // Cancel all outstanding asynchronous operations.
    socket_.close();
    input_.close();
    output_.close();
  }

private:
  tcp::socket socket_;
  posix::stream_descriptor input_;
  posix::stream_descriptor output_;
  chat_message read_msg_;
  chat_message write_msg_;
  asio::streambuf input_buffer_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: posix_chat_client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    tcp::resolver resolver(io_context);
    tcp::resolver::results_type endpoints = resolver.resolve(argv[1], argv[2]);

    posix_chat_client c(io_context, endpoints);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\deferred\deferred_1.cpp
//
// deferred_1.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  auto deferred_op = timer.async_wait(deferred);

  std::move(deferred_op)(
      [](std::error_code ec)
      {
        std::cout << "timer wait finished: " << ec.message() << "\n";
      }
    );

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\deferred\deferred_2.cpp
//
// deferred_2.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  auto deferred_op = timer.async_wait(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer.expires_after(std::chrono::seconds(1));
          return timer.async_wait(deferred);
        }
      )
    );

  std::move(deferred_op)(
      [](std::error_code ec)
      {
        std::cout << "second timer wait finished: " << ec.message() << "\n";
      }
    );

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\echo\async_tcp_echo_server.cpp
//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <memory>
#include <utility>
#include "asio.hpp"

using asio::ip::tcp;

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(tcp::socket socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    do_read();
  }

private:
  void do_read()
  {
    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_, max_length),
        [this, self](std::error_code ec, std::size_t length)
        {
          if (!ec)
          {
            do_write(length);
          }
        });
  }

  void do_write(std::size_t length)
  {
    auto self(shared_from_this());
    asio::async_write(socket_, asio::buffer(data_, length),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            do_read();
          }
        });
  }

  tcp::socket socket_;
  enum { max_length = 1024 };
  char data_[max_length];
};

class server
{
public:
  server(asio::io_context& io_context, short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port))
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket socket)
        {
          if (!ec)
          {
            std::make_shared<session>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_tcp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\echo\async_udp_echo_server.cpp
//
// async_udp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include "asio.hpp"

using asio::ip::udp;

class server
{
public:
  server(asio::io_context& io_context, short port)
    : socket_(io_context, udp::endpoint(udp::v4(), port))
  {
    do_receive();
  }

  void do_receive()
  {
    socket_.async_receive_from(
        asio::buffer(data_, max_length), sender_endpoint_,
        [this](std::error_code ec, std::size_t bytes_recvd)
        {
          if (!ec && bytes_recvd > 0)
          {
            do_send(bytes_recvd);
          }
          else
          {
            do_receive();
          }
        });
  }

  void do_send(std::size_t length)
  {
    socket_.async_send_to(
        asio::buffer(data_, length), sender_endpoint_,
        [this](std::error_code /*ec*/, std::size_t /*bytes_sent*/)
        {
          do_receive();
        });
  }

private:
  udp::socket socket_;
  udp::endpoint sender_endpoint_;
  enum { max_length = 1024 };
  char data_[max_length];
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_udp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\echo\blocking_tcp_echo_client.cpp
//
// blocking_tcp_echo_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <cstring>
#include <iostream>
#include "asio.hpp"

using asio::ip::tcp;

enum { max_length = 1024 };

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: blocking_tcp_echo_client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    tcp::socket s(io_context);
    tcp::resolver resolver(io_context);
    asio::connect(s, resolver.resolve(argv[1], argv[2]));

    std::cout << "Enter message: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t request_length = std::strlen(request);
    asio::write(s, asio::buffer(request, request_length));

    char reply[max_length];
    size_t reply_length = asio::read(s,
        asio::buffer(reply, request_length));
    std::cout << "Reply is: ";
    std::cout.write(reply, reply_length);
    std::cout << "\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\echo\blocking_tcp_echo_server.cpp
//
// blocking_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <thread>
#include <utility>
#include "asio.hpp"

using asio::ip::tcp;

const int max_length = 1024;

void session(tcp::socket sock)
{
  try
  {
    for (;;)
    {
      char data[max_length];

      std::error_code error;
      size_t length = sock.read_some(asio::buffer(data), error);
      if (error == asio::error::eof)
        break; // Connection closed cleanly by peer.
      else if (error)
        throw std::system_error(error); // Some other error.

      asio::write(sock, asio::buffer(data, length));
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception in thread: " << e.what() << "\n";
  }
}

void server(asio::io_context& io_context, unsigned short port)
{
  tcp::acceptor a(io_context, tcp::endpoint(tcp::v4(), port));
  for (;;)
  {
    std::thread(session, a.accept()).detach();
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: blocking_tcp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server(io_context, std::atoi(argv[1]));
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\echo\blocking_udp_echo_client.cpp
//
// blocking_udp_echo_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <cstring>
#include <iostream>
#include "asio.hpp"

using asio::ip::udp;

enum { max_length = 1024 };

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: blocking_udp_echo_client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));

    udp::resolver resolver(io_context);
    udp::resolver::results_type endpoints =
      resolver.resolve(udp::v4(), argv[1], argv[2]);

    std::cout << "Enter message: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t request_length = std::strlen(request);
    s.send_to(asio::buffer(request, request_length), *endpoints.begin());

    char reply[max_length];
    udp::endpoint sender_endpoint;
    size_t reply_length = s.receive_from(
        asio::buffer(reply, max_length), sender_endpoint);
    std::cout << "Reply is: ";
    std::cout.write(reply, reply_length);
    std::cout << "\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\echo\blocking_udp_echo_server.cpp
//
// blocking_udp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include "asio.hpp"

using asio::ip::udp;

enum { max_length = 1024 };

void server(asio::io_context& io_context, unsigned short port)
{
  udp::socket sock(io_context, udp::endpoint(udp::v4(), port));
  for (;;)
  {
    char data[max_length];
    udp::endpoint sender_endpoint;
    size_t length = sock.receive_from(
        asio::buffer(data, max_length), sender_endpoint);
    sock.send_to(asio::buffer(data, length), sender_endpoint);
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: blocking_udp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server(io_context, std::atoi(argv[1]));
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\executors\actor.cpp
#include <asio/any_io_executor.hpp>
#include <asio/defer.hpp>
#include <asio/post.hpp>
#include <asio/strand.hpp>
#include <asio/system_executor.hpp>
#include <condition_variable>
#include <deque>
#include <memory>
#include <mutex>
#include <typeinfo>
#include <vector>

using asio::any_io_executor;
using asio::defer;
using asio::post;
using asio::strand;
using asio::system_executor;

//------------------------------------------------------------------------------
// A tiny actor framework
// ~~~~~~~~~~~~~~~~~~~~~~

class actor;

// Used to identify the sender and recipient of messages.
typedef actor* actor_address;

// Base class for all registered message handlers.
class message_handler_base
{
public:
  virtual ~message_handler_base() {}

  // Used to determine which message handlers receive an incoming message.
  virtual const std::type_info& message_id() const = 0;
};

// Base class for a handler for a specific message type.
template <class Message>
class message_handler : public message_handler_base
{
public:
  // Handle an incoming message.
  virtual void handle_message(Message msg, actor_address from) = 0;
};

// Concrete message handler for a specific message type.
template <class Actor, class Message>
class mf_message_handler : public message_handler<Message>
{
public:
  // Construct a message handler to invoke the specified member function.
  mf_message_handler(void (Actor::* mf)(Message, actor_address), Actor* a)
    : function_(mf), actor_(a)
  {
  }

  // Used to determine which message handlers receive an incoming message.
  virtual const std::type_info& message_id() const
  {
    return typeid(Message);
  }

  // Handle an incoming message.
  virtual void handle_message(Message msg, actor_address from)
  {
    (actor_->*function_)(std::move(msg), from);
  }

  // Determine whether the message handler represents the specified function.
  bool is_function(void (Actor::* mf)(Message, actor_address)) const
  {
    return mf == function_;
  }

private:
  void (Actor::* function_)(Message, actor_address);
  Actor* actor_;
};

// Base class for all actors.
class actor
{
public:
  virtual ~actor()
  {
  }

  // Obtain the actor's address for use as a message sender or recipient.
  actor_address address()
  {
    return this;
  }

  // Send a message from one actor to another.
  template <class Message>
  friend void send(Message msg, actor_address from, actor_address to)
  {
    // Execute the message handler in the context of the target's executor.
    post(to->executor_,
      [=]
      {
        to->call_handler(std::move(msg), from);
      });
  }

protected:
  // Construct the actor to use the specified executor for all message handlers.
  actor(any_io_executor e)
    : executor_(std::move(e))
  {
  }

  // Register a handler for a specific message type. Duplicates are permitted.
  template <class Actor, class Message>
  void register_handler(void (Actor::* mf)(Message, actor_address))
  {
    handlers_.push_back(
      std::make_shared<mf_message_handler<Actor, Message>>(
        mf, static_cast<Actor*>(this)));
  }

  // Deregister a handler. Removes only the first matching handler.
  template <class Actor, class Message>
  void deregister_handler(void (Actor::* mf)(Message, actor_address))
  {
    const std::type_info& id = typeid(Message);
    for (auto iter = handlers_.begin(); iter != handlers_.end(); ++iter)
    {
      if ((*iter)->message_id() == id)
      {
        auto mh = static_cast<mf_message_handler<Actor, Message>*>(iter->get());
        if (mh->is_function(mf))
        {
          handlers_.erase(iter);
          return;
        }
      }
    }
  }

  // Send a message from within a message handler.
  template <class Message>
  void tail_send(Message msg, actor_address to)
  {
    // Execute the message handler in the context of the target's executor.
    actor* from = this;
    defer(to->executor_,
      [=]
      {
        to->call_handler(std::move(msg), from);
      });
  }

private:
  // Find the matching message handlers, if any, and call them.
  template <class Message>
  void call_handler(Message msg, actor_address from)
  {
    const std::type_info& message_id = typeid(Message);
    for (auto& h: handlers_)
    {
      if (h->message_id() == message_id)
      {
        auto mh = static_cast<message_handler<Message>*>(h.get());
        mh->handle_message(msg, from);
      }
    }
  }

  // All messages associated with a single actor object should be processed
  // non-concurrently. We use a strand to ensure non-concurrent execution even
  // if the underlying executor may use multiple threads.
  strand<any_io_executor> executor_;

  std::vector<std::shared_ptr<message_handler_base>> handlers_;
};

// A concrete actor that allows synchronous message retrieval.
template <class Message>
class receiver : public actor
{
public:
  receiver()
    : actor(system_executor())
  {
    register_handler(&receiver::message_handler);
  }

  // Block until a message has been received.
  Message wait()
  {
    std::unique_lock<std::mutex> lock(mutex_);
    condition_.wait(lock, [this]{ return !message_queue_.empty(); });
    Message msg(std::move(message_queue_.front()));
    message_queue_.pop_front();
    return msg;
  }

private:
  // Handle a new message by adding it to the queue and waking a waiter.
  void message_handler(Message msg, actor_address /* from */)
  {
    std::lock_guard<std::mutex> lock(mutex_);
    message_queue_.push_back(std::move(msg));
    condition_.notify_one();
  }

  std::mutex mutex_;
  std::condition_variable condition_;
  std::deque<Message> message_queue_;
};

//------------------------------------------------------------------------------

#include <asio/thread_pool.hpp>
#include <iostream>

using asio::thread_pool;

class member : public actor
{
public:
  explicit member(any_io_executor e)
    : actor(std::move(e))
  {
    register_handler(&member::init_handler);
  }

private:
  void init_handler(actor_address next, actor_address from)
  {
    next_ = next;
    caller_ = from;

    register_handler(&member::token_handler);
    deregister_handler(&member::init_handler);
  }

  void token_handler(int token, actor_address /*from*/)
  {
    int msg(token);
    actor_address to(caller_);

    if (token > 0)
    {
      msg = token - 1;
      to = next_;
    }

    tail_send(msg, to);
  }

  actor_address next_;
  actor_address caller_;
};

int main()
{
  const std::size_t num_threads = 16;
  const int num_hops = 50000000;
  const std::size_t num_actors = 503;
  const int token_value = (num_hops + num_actors - 1) / num_actors;
  const std::size_t actors_per_thread = num_actors / num_threads;

  struct single_thread_pool : thread_pool { single_thread_pool() : thread_pool(1) {} };
  single_thread_pool pools[num_threads];
  std::vector<std::shared_ptr<member>> members(num_actors);
  receiver<int> rcvr;

  // Create the member actors.
  for (std::size_t i = 0; i < num_actors; ++i)
    members[i] = std::make_shared<member>(pools[(i / actors_per_thread) % num_threads].get_executor());

  // Initialise the actors by passing each one the address of the next actor in the ring.
  for (std::size_t i = num_actors, next_i = 0; i > 0; next_i = --i)
    send(members[next_i]->address(), rcvr.address(), members[i - 1]->address());

  // Send exactly one token to each actor, all with the same initial value, rounding up if required.
  for (std::size_t i = 0; i < num_actors; ++i)
    send(token_value, rcvr.address(), members[i]->address());

  // Wait for all signal messages, indicating the tokens have all reached zero.
  for (std::size_t i = 0; i < num_actors; ++i)
    rcvr.wait();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\executors\bank_account_1.cpp
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <iostream>

using asio::static_thread_pool;
namespace execution = asio::execution;

// Traditional active object pattern.
// Member functions do not block.

class bank_account
{
  int balance_ = 0;
  mutable static_thread_pool pool_{1};

public:
  void deposit(int amount)
  {
    pool_.executor().execute(
        [this, amount]
        {
          balance_ += amount;
        });
  }

  void withdraw(int amount)
  {
    pool_.executor().execute(
        [this, amount]
        {
          if (balance_ >= amount)
            balance_ -= amount;
        });
  }

  void print_balance() const
  {
    pool_.executor().execute(
        [this]
        {
          std::cout << "balance = " << balance_ << "\n";
        });
  }

  ~bank_account()
  {
    pool_.wait();
  }
};

int main()
{
  bank_account acct;
  acct.deposit(20);
  acct.withdraw(10);
  acct.print_balance();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\executors\bank_account_2.cpp
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <iostream>

using asio::static_thread_pool;
namespace execution = asio::execution;

// Traditional active object pattern.
// Member functions block until operation is finished.

class bank_account
{
  int balance_ = 0;
  mutable static_thread_pool pool_{1};

public:
  void deposit(int amount)
  {
    asio::require(pool_.executor(), execution::blocking.always).execute(
        [this, amount]
        {
          balance_ += amount;
        });
  }

  void withdraw(int amount)
  {
    asio::require(pool_.executor(), execution::blocking.always).execute(
        [this, amount]
        {
          if (balance_ >= amount)
            balance_ -= amount;
        });
  }

  int balance() const
  {
    int result = 0;
    asio::require(pool_.executor(), execution::blocking.always).execute(
        [this, &result]
        {
          result = balance_;
        });
    return result;
  }
};

int main()
{
  bank_account acct;
  acct.deposit(20);
  acct.withdraw(10);
  std::cout << "balance = " << acct.balance() << "\n";
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\executors\fork_join.cpp
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <algorithm>
#include <condition_variable>
#include <memory>
#include <mutex>
#include <queue>
#include <thread>
#include <numeric>

using asio::static_thread_pool;
namespace execution = asio::execution;

// A fixed-size thread pool used to implement fork/join semantics. Functions
// are scheduled using a simple FIFO queue. Implementing work stealing, or
// using a queue based on atomic operations, are left as tasks for the reader.
class fork_join_pool
{
public:
  // The constructor starts a thread pool with the specified number of threads.
  // Note that the thread_count is not a fixed limit on the pool's concurrency.
  // Additional threads may temporarily be added to the pool if they join a
  // fork_executor.
  explicit fork_join_pool(
      std::size_t thread_count = std::max(std::thread::hardware_concurrency(), 1u) * 2)
    : use_count_(1),
      threads_(thread_count)
  {
    try
    {
      // Ask each thread in the pool to dequeue and execute functions until
      // it is time to shut down, i.e. the use count is zero.
      for (thread_count_ = 0; thread_count_ < thread_count; ++thread_count_)
      {
        threads_.executor().execute(
            [this]
            {
              std::unique_lock<std::mutex> lock(mutex_);
              while (use_count_ > 0)
                if (!execute_next(lock))
                  condition_.wait(lock);
            });
      }
    }
    catch (...)
    {
      stop_threads();
      threads_.wait();
      throw;
    }
  }

  // The destructor waits for the pool to finish executing functions.
  ~fork_join_pool()
  {
    stop_threads();
    threads_.wait();
  }

private:
  friend class fork_executor;

  // The base for all functions that are queued in the pool.
  struct function_base
  {
    std::shared_ptr<std::size_t> work_count_;
    void (*execute_)(std::shared_ptr<function_base>& p);
  };

  // Execute the next function from the queue, if any. Returns true if a
  // function was executed, and false if the queue was empty.
  bool execute_next(std::unique_lock<std::mutex>& lock)
  {
    if (queue_.empty())
      return false;
    auto p(queue_.front());
    queue_.pop();
    lock.unlock();
    execute(lock, p); 
    return true;
  }

  // Execute a function and decrement the outstanding work.
  void execute(std::unique_lock<std::mutex>& lock,
      std::shared_ptr<function_base>& p)
  {
    std::shared_ptr<std::size_t> work_count(std::move(p->work_count_));
    try
    {
      p->execute_(p);
      lock.lock();
      do_work_finished(work_count);
    }
    catch (...)
    {
      lock.lock();
      do_work_finished(work_count);
      throw;
    }
  }

  // Increment outstanding work.
  void do_work_started(const std::shared_ptr<std::size_t>& work_count) noexcept
  {
    if (++(*work_count) == 1)
      ++use_count_;
  }

  // Decrement outstanding work. Notify waiting threads if we run out.
  void do_work_finished(const std::shared_ptr<std::size_t>& work_count) noexcept
  {
    if (--(*work_count) == 0)
    {
      --use_count_;
      condition_.notify_all();
    }
  }

  // Dispatch a function, executing it immediately if the queue is already
  // loaded. Otherwise adds the function to the queue and wakes a thread.
  void do_execute(std::shared_ptr<function_base> p,
      const std::shared_ptr<std::size_t>& work_count)
  {
    std::unique_lock<std::mutex> lock(mutex_);
    if (queue_.size() > thread_count_ * 16)
    {
      do_work_started(work_count);
      lock.unlock();
      execute(lock, p);
    }
    else
    {
      queue_.push(p);
      do_work_started(work_count);
      condition_.notify_one();
    }
  }

  // Ask all threads to shut down.
  void stop_threads()
  {
    std::lock_guard<std::mutex> lock(mutex_);
    --use_count_;
    condition_.notify_all();
  }

  std::mutex mutex_;
  std::condition_variable condition_;
  std::queue<std::shared_ptr<function_base>> queue_;
  std::size_t use_count_;
  std::size_t thread_count_;
  static_thread_pool threads_;
};

// A class that satisfies the Executor requirements. Every function or piece of
// work associated with a fork_executor is part of a single, joinable group.
class fork_executor
{
public:
  fork_executor(fork_join_pool& ctx)
    : context_(ctx),
      work_count_(std::make_shared<std::size_t>(0))
  {
  }

  fork_join_pool& query(execution::context_t) const noexcept
  {
    return context_;
  }

  template <class Func>
  void execute(Func f) const
  {
    auto p(std::make_shared<function<Func>>(std::move(f), work_count_));
    context_.do_execute(p, work_count_);
  }

  friend bool operator==(const fork_executor& a,
      const fork_executor& b) noexcept
  {
    return a.work_count_ == b.work_count_;
  }

  friend bool operator!=(const fork_executor& a,
      const fork_executor& b) noexcept
  {
    return a.work_count_ != b.work_count_;
  }

  // Block until all work associated with the executor is complete. While it is
  // waiting, the thread may be borrowed to execute functions from the queue.
  void join() const
  {
    std::unique_lock<std::mutex> lock(context_.mutex_);
    while (*work_count_ > 0)
      if (!context_.execute_next(lock))
        context_.condition_.wait(lock);
  }

private:
  template <class Func>
  struct function : fork_join_pool::function_base
  {
    explicit function(Func f, const std::shared_ptr<std::size_t>& w)
      : function_(std::move(f))
    {
      work_count_ = w;
      execute_ = [](std::shared_ptr<fork_join_pool::function_base>& p)
      {
        Func tmp(std::move(static_cast<function*>(p.get())->function_));
        p.reset();
        tmp();
      };
    }

    Func function_;
  };

  fork_join_pool& context_;
  std::shared_ptr<std::size_t> work_count_;
};

// Helper class to automatically join a fork_executor when exiting a scope.
class join_guard
{
public:
  explicit join_guard(const fork_executor& ex) : ex_(ex) {}
  join_guard(const join_guard&) = delete;
  join_guard(join_guard&&) = delete;
  ~join_guard() { ex_.join(); }

private:
  fork_executor ex_;
};

//------------------------------------------------------------------------------

#include <algorithm>
#include <iostream>
#include <random>
#include <vector>

fork_join_pool pool;

template <class Iterator>
void fork_join_sort(Iterator begin, Iterator end)
{
  std::size_t n = end - begin;
  if (n > 32768)
  {
    {
      fork_executor fork(pool);
      join_guard join(fork);
      fork.execute([=]{ fork_join_sort(begin, begin + n / 2); });
      fork.execute([=]{ fork_join_sort(begin + n / 2, end); });
    }
    std::inplace_merge(begin, begin + n / 2, end);
  }
  else
  {
    std::sort(begin, end);
  }
}

int main(int argc, char* argv[])
{
  if (argc != 2)
  {
    std::cerr << "Usage: fork_join <size>\n";
    return 1;
  }

  std::vector<double> vec(std::atoll(argv[1]));
  std::iota(vec.begin(), vec.end(), 0);

  std::random_device rd;
  std::mt19937 g(rd());
  std::shuffle(vec.begin(), vec.end(), g);

  std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();

  fork_join_sort(vec.begin(), vec.end());

  std::chrono::steady_clock::duration elapsed = std::chrono::steady_clock::now() - start;

  std::cout << "sort took ";
  std::cout << std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
  std::cout << " microseconds" << std::endl;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\executors\pipeline.cpp
#include <asio/associated_executor.hpp>
#include <asio/bind_executor.hpp>
#include <asio/execution_context.hpp>
#include <asio/post.hpp>
#include <asio/system_executor.hpp>
#include <asio/use_future.hpp>
#include <condition_variable>
#include <future>
#include <memory>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>
#include <cctype>

using asio::execution_context;
using asio::executor_binder;
using asio::get_associated_executor;
using asio::post;
using asio::system_executor;
using asio::use_future;
using asio::use_service;
namespace execution = asio::execution;

// An executor that launches a new thread for each function submitted to it.
// This class satisfies the executor requirements.
class thread_executor
{
private:
  // Service to track all threads started through a thread_executor.
  class thread_bag : public execution_context::service
  {
  public:
    typedef thread_bag key_type;

    explicit thread_bag(execution_context& ctx)
      : execution_context::service(ctx)
    {
    }

    void add_thread(std::thread&& t)
    {
      std::unique_lock<std::mutex> lock(mutex_);
      threads_.push_back(std::move(t));
    }

  private:
    virtual void shutdown()
    {
      for (auto& t : threads_)
        t.join();
    }

    std::mutex mutex_;
    std::vector<std::thread> threads_;
  };

public:
  execution_context& query(execution::context_t) const
  {
    return asio::query(system_executor(), execution::context);
  }

  execution::blocking_t query(execution::blocking_t) const
  {
    return execution::blocking.never;
  }

  thread_executor require(execution::blocking_t::never_t) const
  {
    return *this;
  }

  template <class Func>
  void execute(Func f) const
  {
    thread_bag& bag = use_service<thread_bag>(query(execution::context));
    bag.add_thread(std::thread(std::move(f)));
  }

  friend bool operator==(const thread_executor&,
      const thread_executor&) noexcept
  {
    return true;
  }

  friend bool operator!=(const thread_executor&,
      const thread_executor&) noexcept
  {
    return false;
  }
};

// Base class for all thread-safe queue implementations.
class queue_impl_base
{
  template <class> friend class queue_front;
  template <class> friend class queue_back;
  std::mutex mutex_;
  std::condition_variable condition_;
  bool stop_ = false;
};

// Underlying implementation of a thread-safe queue, shared between the
// queue_front and queue_back classes.
template <class T>
class queue_impl : public queue_impl_base
{
  template <class> friend class queue_front;
  template <class> friend class queue_back;
  std::queue<T> queue_;
};

// The front end of a queue between consecutive pipeline stages.
template <class T>
class queue_front
{
public:
  typedef T value_type;

  explicit queue_front(std::shared_ptr<queue_impl<T>> impl)
    : impl_(impl)
  {
  }

  void push(T t)
  {
    std::unique_lock<std::mutex> lock(impl_->mutex_);
    impl_->queue_.push(std::move(t));
    impl_->condition_.notify_one();
  }

  void stop()
  {
    std::unique_lock<std::mutex> lock(impl_->mutex_);
    impl_->stop_ = true;
    impl_->condition_.notify_one();
  }

private:
  std::shared_ptr<queue_impl<T>> impl_;
};

// The back end of a queue between consecutive pipeline stages.
template <class T>
class queue_back
{
public:
  typedef T value_type;

  explicit queue_back(std::shared_ptr<queue_impl<T>> impl)
    : impl_(impl)
  {
  }

  bool pop(T& t)
  {
    std::unique_lock<std::mutex> lock(impl_->mutex_);
    while (impl_->queue_.empty() && !impl_->stop_)
      impl_->condition_.wait(lock);
    if (!impl_->queue_.empty())
    {
      t = impl_->queue_.front();
      impl_->queue_.pop();
      return true;
    }
    return false;
  }

private:
  std::shared_ptr<queue_impl<T>> impl_;
};

// Launch the last stage in a pipeline.
template <class T, class F>
std::future<void> pipeline(queue_back<T> in, F f)
{
  // Get the function's associated executor, defaulting to thread_executor.
  auto ex = get_associated_executor(f, thread_executor());

  // Run the function, and as we're the last stage return a future so that the
  // caller can wait for the pipeline to finish.
  return post(ex, use_future([in, f]() mutable { f(in); }));
}

// Launch an intermediate stage in a pipeline.
template <class T, class F, class... Tail>
std::future<void> pipeline(queue_back<T> in, F f, Tail... t)
{
  // Determine the output queue type.
  typedef typename executor_binder<F, thread_executor>::second_argument_type::value_type output_value_type;

  // Create the output queue and its implementation.
  auto out_impl = std::make_shared<queue_impl<output_value_type>>();
  queue_front<output_value_type> out(out_impl);
  queue_back<output_value_type> next_in(out_impl);

  // Get the function's associated executor, defaulting to thread_executor.
  auto ex = get_associated_executor(f, thread_executor());

  // Run the function.
  post(ex, [in, out, f]() mutable
      {
        f(in, out);
        out.stop();
      });

  // Launch the rest of the pipeline.
  return pipeline(next_in, std::move(t)...);
}

// Launch the first stage in a pipeline.
template <class F, class... Tail>
std::future<void> pipeline(F f, Tail... t)
{
  // Determine the output queue type.
  typedef typename executor_binder<F, thread_executor>::argument_type::value_type output_value_type;

  // Create the output queue and its implementation.
  auto out_impl = std::make_shared<queue_impl<output_value_type>>();
  queue_front<output_value_type> out(out_impl);
  queue_back<output_value_type> next_in(out_impl);

  // Get the function's associated executor, defaulting to thread_executor.
  auto ex = get_associated_executor(f, thread_executor());

  // Run the function.
  post(ex, [out, f]() mutable
      {
        f(out);
        out.stop();
      });

  // Launch the rest of the pipeline.
  return pipeline(next_in, std::move(t)...);
}

//------------------------------------------------------------------------------

#include <asio/thread_pool.hpp>
#include <iostream>
#include <string>

using asio::bind_executor;
using asio::thread_pool;

void reader(queue_front<std::string> out)
{
  std::string line;
  while (std::getline(std::cin, line))
    out.push(line);
}

void filter(queue_back<std::string> in, queue_front<std::string> out)
{
  std::string line;
  while (in.pop(line))
    if (line.length() > 5)
      out.push(line);
}

void upper(queue_back<std::string> in, queue_front<std::string> out)
{
  std::string line;
  while (in.pop(line))
  {
    std::string new_line;
    for (char c : line)
      new_line.push_back(std::toupper(c));
    out.push(new_line);
  }
}

void writer(queue_back<std::string> in)
{
  std::size_t count = 0;
  std::string line;
  while (in.pop(line))
    std::cout << count++ << ": " << line << std::endl;
}

int main()
{
  thread_pool pool(1);

  auto f = pipeline(reader, filter, bind_executor(pool, upper), writer);
  f.wait();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\executors\priority_scheduler.cpp
#include <asio/dispatch.hpp>
#include <asio/execution_context.hpp>
#include <condition_variable>
#include <iostream>
#include <memory>
#include <mutex>
#include <queue>

using asio::dispatch;
using asio::execution_context;
namespace execution = asio::execution;

class priority_scheduler : public execution_context
{
public:
  // A class that satisfies the Executor requirements.
  class executor_type
  {
  public:
    executor_type(priority_scheduler& ctx, int pri) noexcept
      : context_(ctx), priority_(pri)
    {
    }

    priority_scheduler& query(execution::context_t) const noexcept
    {
      return context_;
    }

    template <class Func>
    void execute(Func f) const
    {
      auto p(std::make_shared<item<Func>>(priority_, std::move(f)));
      std::lock_guard<std::mutex> lock(context_.mutex_);
      context_.queue_.push(p);
      context_.condition_.notify_one();
    }

    friend bool operator==(const executor_type& a,
        const executor_type& b) noexcept
    {
      return &a.context_ == &b.context_;
    }

    friend bool operator!=(const executor_type& a,
        const executor_type& b) noexcept
    {
      return &a.context_ != &b.context_;
    }

  private:
    priority_scheduler& context_;
    int priority_;
  };

  ~priority_scheduler() noexcept
  {
    shutdown();
    destroy();
  }

  executor_type get_executor(int pri = 0) noexcept
  {
    return executor_type(*const_cast<priority_scheduler*>(this), pri);
  }

  void run()
  {
    std::unique_lock<std::mutex> lock(mutex_);
    for (;;)
    {
      condition_.wait(lock, [&]{ return stopped_ || !queue_.empty(); });
      if (stopped_)
        return;
      auto p(queue_.top());
      queue_.pop();
      lock.unlock();
      p->execute_(p);
      lock.lock();
    }
  }

  void stop()
  {
    std::lock_guard<std::mutex> lock(mutex_);
    stopped_ = true;
    condition_.notify_all();
  }

private:
  struct item_base
  {
    int priority_;
    void (*execute_)(std::shared_ptr<item_base>&);
  };

  template <class Func>
  struct item : item_base
  {
    item(int pri, Func f) : function_(std::move(f))
    {
      priority_ = pri;
      execute_ = [](std::shared_ptr<item_base>& p)
      {
        Func tmp(std::move(static_cast<item*>(p.get())->function_));
        p.reset();
        tmp();
      };
    }

    Func function_;
  };

  struct item_comp
  {
    bool operator()(
        const std::shared_ptr<item_base>& a,
        const std::shared_ptr<item_base>& b)
    {
      return a->priority_ < b->priority_;
    }
  };

  std::mutex mutex_;
  std::condition_variable condition_;
  std::priority_queue<
    std::shared_ptr<item_base>,
    std::vector<std::shared_ptr<item_base>>,
    item_comp> queue_;
  bool stopped_ = false;
};

int main()
{
  priority_scheduler sched;
  auto low = sched.get_executor(0);
  auto med = sched.get_executor(1);
  auto high = sched.get_executor(2);
  dispatch(low, []{ std::cout << "1\n"; });
  dispatch(low, []{ std::cout << "11\n"; });
  dispatch(med, []{ std::cout << "2\n"; });
  dispatch(med, []{ std::cout << "22\n"; });
  dispatch(high, []{ std::cout << "3\n"; });
  dispatch(high, []{ std::cout << "33\n"; });
  dispatch(high, []{ std::cout << "333\n"; });
  dispatch(sched.get_executor(-1), [&]{ sched.stop(); });
  sched.run();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\files\async_file_copy.cpp
//
// async_file_copy.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include "asio.hpp"

#if defined(ASIO_HAS_FILE)

class file_copier
{
public:
  file_copier(asio::io_context& io_context,
      const char* from, const char* to)
    : from_file_(io_context, from,
        asio::stream_file::read_only),
      to_file_(io_context, to,
        asio::stream_file::write_only
          | asio::stream_file::create
          | asio::stream_file::truncate)
  {
  }

  void start()
  {
    do_read();
  }

private:
  void do_read()
  {
    from_file_.async_read_some(asio::buffer(data_),
        [this](std::error_code error, std::size_t n)
        {
          if (!error)
          {
            do_write(n);
          }
          else if (error != asio::error::eof)
          {
            std::cerr << "Error copying file: " << error.message() << "\n";
          }
        });
  }

  void do_write(std::size_t n)
  {
    asio::async_write(to_file_, asio::buffer(data_, n),
        [this](std::error_code error, std::size_t /*n*/)
        {
          if (!error)
          {
            do_read();
          }
          else
          {
            std::cerr << "Error copying file: " << error.message() << "\n";
          }
        });
  }

  asio::stream_file from_file_;
  asio::stream_file to_file_;
  char data_[4096];
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: async_file_copy <from> <to>\n";
      return 1;
    }

    asio::io_context io_context;

    file_copier copier(io_context, argv[1], argv[2]);
    copier.start();

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
    return 1;
  }

  return 0;
}

#else // defined(ASIO_HAS_FILE)
int main() {}
#endif // defined(ASIO_HAS_FILE)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\files\blocking_file_copy.cpp
//
// blocking_file_copy.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include "asio.hpp"

#if defined(ASIO_HAS_FILE)

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: blocking_file_copy <from> <to>\n";
      return 1;
    }

    asio::io_context io_context;

    asio::stream_file from_file(io_context, argv[1],
        asio::stream_file::read_only);

    asio::stream_file to_file(io_context, argv[2],
        asio::stream_file::write_only
          | asio::stream_file::create
          | asio::stream_file::truncate);

    char data[4096];
    std::error_code error;
    for (;;)
    {
      std::size_t n = from_file.read_some(asio::buffer(data), error);
      if (error)
        break;
      asio::write(to_file, asio::buffer(data, n), error);
      if (error)
        break;
    }

    if (error && error != asio::error::eof)
    {
      std::cerr << "Error copying file: " << error.message() << "\n";
      return 1;
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
    return 1;
  }

  return 0;
}

#else // defined(ASIO_HAS_FILE)
int main() {}
#endif // defined(ASIO_HAS_FILE)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\fork\daemon.cpp
//
// daemon.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/io_context.hpp>
#include <asio/ip/udp.hpp>
#include <asio/signal_set.hpp>
#include <array>
#include <ctime>
#include <iostream>
#include <syslog.h>
#include <unistd.h>

using asio::ip::udp;

class udp_daytime_server
{
public:
  udp_daytime_server(asio::io_context& io_context)
    : socket_(io_context, {udp::v4(), 13})
  {
    receive();
  }

private:
  void receive()
  {
    socket_.async_receive_from(
        asio::buffer(recv_buffer_), remote_endpoint_,
        [this](std::error_code ec, std::size_t /*n*/)
        {
          if (!ec)
          {
            using namespace std; // For time_t, time and ctime;
            time_t now = time(0);
            std::string message = ctime(&now);

            std::error_code ignored_ec;
            socket_.send_to(asio::buffer(message),
                remote_endpoint_, 0, ignored_ec);
          }

          receive();
        });
  }

  udp::socket socket_;
  udp::endpoint remote_endpoint_;
  std::array<char, 1> recv_buffer_;
};

int main()
{
  try
  {
    asio::io_context io_context;

    // Initialise the server before becoming a daemon. If the process is
    // started from a shell, this means any errors will be reported back to the
    // user.
    udp_daytime_server server(io_context);

    // Register signal handlers so that the daemon may be shut down. You may
    // also want to register for other signals, such as SIGHUP to trigger a
    // re-read of a configuration file.
    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait(
        [&](std::error_code /*ec*/, int /*signo*/)
        {
          io_context.stop();
        });

    // Inform the io_context that we are about to become a daemon. The
    // io_context cleans up any internal resources, such as threads, that may
    // interfere with forking.
    io_context.notify_fork(asio::io_context::fork_prepare);

    // Fork the process and have the parent exit. If the process was started
    // from a shell, this returns control to the user. Forking a new process is
    // also a prerequisite for the subsequent call to setsid().
    if (pid_t pid = fork())
    {
      if (pid > 0)
      {
        // We're in the parent process and need to exit.
        //
        // When the exit() function is used, the program terminates without
        // invoking local variables' destructors. Only global variables are
        // destroyed. As the io_context object is a local variable, this means
        // we do not have to call:
        //
        //   io_context.notify_fork(asio::io_context::fork_parent);
        //
        // However, this line should be added before each call to exit() if
        // using a global io_context object. An additional call:
        //
        //   io_context.notify_fork(asio::io_context::fork_prepare);
        //
        // should also precede the second fork().
        exit(0);
      }
      else
      {
        syslog(LOG_ERR | LOG_USER, "First fork failed: %m");
        return 1;
      }
    }

    // Make the process a new session leader. This detaches it from the
    // terminal.
    setsid();

    // A process inherits its working directory from its parent. This could be
    // on a mounted filesystem, which means that the running daemon would
    // prevent this filesystem from being unmounted. Changing to the root
    // directory avoids this problem.
    chdir("/");

    // The file mode creation mask is also inherited from the parent process.
    // We don't want to restrict the permissions on files created by the
    // daemon, so the mask is cleared.
    umask(0);

    // A second fork ensures the process cannot acquire a controlling terminal.
    if (pid_t pid = fork())
    {
      if (pid > 0)
      {
        exit(0);
      }
      else
      {
        syslog(LOG_ERR | LOG_USER, "Second fork failed: %m");
        return 1;
      }
    }

    // Close the standard streams. This decouples the daemon from the terminal
    // that started it.
    close(0);
    close(1);
    close(2);

    // We don't want the daemon to have any standard input.
    if (open("/dev/null", O_RDONLY) < 0)
    {
      syslog(LOG_ERR | LOG_USER, "Unable to open /dev/null: %m");
      return 1;
    }

    // Send standard output to a log file.
    const char* output = "/tmp/asio.daemon.out";
    const int flags = O_WRONLY | O_CREAT | O_APPEND;
    const mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
    if (open(output, flags, mode) < 0)
    {
      syslog(LOG_ERR | LOG_USER, "Unable to open output file %s: %m", output);
      return 1;
    }

    // Also send standard error to the same log file.
    if (dup(1) < 0)
    {
      syslog(LOG_ERR | LOG_USER, "Unable to dup output descriptor: %m");
      return 1;
    }

    // Inform the io_context that we have finished becoming a daemon. The
    // io_context uses this opportunity to create any internal file descriptors
    // that need to be private to the new process.
    io_context.notify_fork(asio::io_context::fork_child);

    // The io_context can now be used normally.
    syslog(LOG_INFO | LOG_USER, "Daemon started");
    io_context.run();
    syslog(LOG_INFO | LOG_USER, "Daemon stopped");
  }
  catch (std::exception& e)
  {
    syslog(LOG_ERR | LOG_USER, "Exception: %s", e.what());
    std::cerr << "Exception: " << e.what() << std::endl;
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\fork\process_per_connection.cpp
//
// process_per_connection.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdlib>
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

using asio::ip::tcp;

class server
{
public:
  server(asio::io_context& io_context, unsigned short port)
    : io_context_(io_context),
      signal_(io_context, SIGCHLD),
      acceptor_(io_context, {tcp::v4(), port}),
      socket_(io_context)
  {
    wait_for_signal();
    accept();
  }

private:
  void wait_for_signal()
  {
    signal_.async_wait(
        [this](std::error_code /*ec*/, int /*signo*/)
        {
          // Only the parent process should check for this signal. We can
          // determine whether we are in the parent by checking if the acceptor
          // is still open.
          if (acceptor_.is_open())
          {
            // Reap completed child processes so that we don't end up with
            // zombies.
            int status = 0;
            while (waitpid(-1, &status, WNOHANG) > 0) {}

            wait_for_signal();
          }
        });
  }

  void accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket new_socket)
        {
          if (!ec)
          {
            // Take ownership of the newly accepted socket.
            socket_ = std::move(new_socket);

            // Inform the io_context that we are about to fork. The io_context
            // cleans up any internal resources, such as threads, that may
            // interfere with forking.
            io_context_.notify_fork(asio::io_context::fork_prepare);

            if (fork() == 0)
            {
              // Inform the io_context that the fork is finished and that this
              // is the child process. The io_context uses this opportunity to
              // create any internal file descriptors that must be private to
              // the new process.
              io_context_.notify_fork(asio::io_context::fork_child);

              // The child won't be accepting new connections, so we can close
              // the acceptor. It remains open in the parent.
              acceptor_.close();

              // The child process is not interested in processing the SIGCHLD
              // signal.
              signal_.cancel();

              read();
            }
            else
            {

              // Inform the io_context that the fork is finished (or failed)
              // and that this is the parent process. The io_context uses this
              // opportunity to recreate any internal resources that were
              // cleaned up during preparation for the fork.
              io_context_.notify_fork(asio::io_context::fork_parent);

              // The parent process can now close the newly accepted socket. It
              // remains open in the child.
              socket_.close();

              accept();
            }
          }
          else
          {
            std::cerr << "Accept error: " << ec.message() << std::endl;
            accept();
          }
        });
  }

  void read()
  {
    socket_.async_read_some(asio::buffer(data_),
        [this](std::error_code ec, std::size_t length)
        {
          if (!ec)
            write(length);
        });
  }

  void write(std::size_t length)
  {
    asio::async_write(socket_, asio::buffer(data_, length),
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
            read();
        });
  }

  asio::io_context& io_context_;
  asio::signal_set signal_;
  tcp::acceptor acceptor_;
  tcp::socket socket_;
  std::array<char, 1024> data_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: process_per_connection <port>\n";
      return 1;
    }

    asio::io_context io_context;

    using namespace std; // For atoi.
    server s(io_context, atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << std::endl;
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\futures\daytime_client.cpp
//
// daytime_client.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <future>
#include <iostream>
#include <thread>
#include <asio/io_context.hpp>
#include <asio/ip/udp.hpp>
#include <asio/use_future.hpp>

using asio::ip::udp;

void get_daytime(asio::io_context& io_context, const char* hostname)
{
  try
  {
    udp::resolver resolver(io_context);

    std::future<udp::resolver::results_type> endpoints =
      resolver.async_resolve(
          udp::v4(), hostname, "daytime",
          asio::use_future);

    // The async_resolve operation above returns the endpoints as a future
    // value that is not retrieved ...

    udp::socket socket(io_context, udp::v4());

    std::array<char, 1> send_buf  = {{ 0 }};
    std::future<std::size_t> send_length =
      socket.async_send_to(asio::buffer(send_buf),
          *endpoints.get().begin(), // ... until here. This call may block.
          asio::use_future);

    // Do other things here while the send completes.

    send_length.get(); // Blocks until the send is complete. Throws any errors.

    std::array<char, 128> recv_buf;
    udp::endpoint sender_endpoint;
    std::future<std::size_t> recv_length =
      socket.async_receive_from(
          asio::buffer(recv_buf),
          sender_endpoint,
          asio::use_future);

    // Do other things here while the receive completes.

    std::cout.write(
        recv_buf.data(),
        recv_length.get()); // Blocks until receive is complete.
  }
  catch (std::system_error& e)
  {
    std::cerr << e.what() << std::endl;
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: daytime_client <host>" << std::endl;
      return 1;
    }

    // We run the io_context off in its own thread so that it operates
    // completely asynchronously with respect to the rest of the program.
    asio::io_context io_context;
    auto work = asio::make_work_guard(io_context);
    std::thread thread([&io_context](){ io_context.run(); });

    get_daytime(io_context, argv[1]);

    io_context.stop();
    thread.join();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\handler_tracking\async_tcp_echo_server.cpp
//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <memory>
#include <utility>
#include <asio.hpp>

using asio::ip::tcp;

// Define a helper macro to invoke ASIO_HANDLER_LOCATION with the current
// file name, line number, and function name. For the function name, you might
// also consider using __PRETTY_FUNCTION__, BOOST_CURRENT_FUNCTION, or a hand-
// crafted name. For C++20 or later, you may also use std::source_location.
#define HANDLER_LOCATION \
  ASIO_HANDLER_LOCATION((__FILE__, __LINE__, __func__))

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(tcp::socket socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    HANDLER_LOCATION;

    do_read();
  }

private:
  void do_read()
  {
    HANDLER_LOCATION;

    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_, max_length),
        [this, self](std::error_code ec, std::size_t length)
        {
          HANDLER_LOCATION;

          if (!ec)
          {
            do_write(length);
          }
        });
  }

  void do_write(std::size_t length)
  {
    HANDLER_LOCATION;

    auto self(shared_from_this());
    asio::async_write(socket_, asio::buffer(data_, length),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          HANDLER_LOCATION;

          if (!ec)
          {
            do_read();
          }
        });
  }

  tcp::socket socket_;
  enum { max_length = 1024 };
  char data_[max_length];
};

class server
{
public:
  server(asio::io_context& io_context, short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port))
  {
    do_accept();
  }

private:
  void do_accept()
  {
    HANDLER_LOCATION;

    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket socket)
        {
          HANDLER_LOCATION;

          if (!ec)
          {
            std::make_shared<session>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_tcp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\client\async_client.cpp
//
// async_client.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <functional>
#include <iostream>
#include <istream>
#include <ostream>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;

class client
{
public:
  client(asio::io_context& io_context,
      const std::string& server, const std::string& path)
    : resolver_(io_context),
      socket_(io_context)
  {
    // Form the request. We specify the "Connection: close" header so that the
    // server will close the socket after transmitting the response. This will
    // allow us to treat all data up until the EOF as the content.
    std::ostream request_stream(&request_);
    request_stream << "GET " << path << " HTTP/1.0\r\n";
    request_stream << "Host: " << server << "\r\n";
    request_stream << "Accept: */*\r\n";
    request_stream << "Connection: close\r\n\r\n";

    // Start an asynchronous resolve to translate the server and service names
    // into a list of endpoints.
    resolver_.async_resolve(server, "http",
        std::bind(&client::handle_resolve, this,
          asio::placeholders::error,
          asio::placeholders::results));
  }

private:
  void handle_resolve(const std::error_code& err,
      const tcp::resolver::results_type& endpoints)
  {
    if (!err)
    {
      // Attempt a connection to each endpoint in the list until we
      // successfully establish a connection.
      asio::async_connect(socket_, endpoints,
          std::bind(&client::handle_connect, this,
            asio::placeholders::error));
    }
    else
    {
      std::cout << "Error: " << err.message() << "\n";
    }
  }

  void handle_connect(const std::error_code& err)
  {
    if (!err)
    {
      // The connection was successful. Send the request.
      asio::async_write(socket_, request_,
          std::bind(&client::handle_write_request, this,
            asio::placeholders::error));
    }
    else
    {
      std::cout << "Error: " << err.message() << "\n";
    }
  }

  void handle_write_request(const std::error_code& err)
  {
    if (!err)
    {
      // Read the response status line. The response_ streambuf will
      // automatically grow to accommodate the entire line. The growth may be
      // limited by passing a maximum size to the streambuf constructor.
      asio::async_read_until(socket_, response_, "\r\n",
          std::bind(&client::handle_read_status_line, this,
            asio::placeholders::error));
    }
    else
    {
      std::cout << "Error: " << err.message() << "\n";
    }
  }

  void handle_read_status_line(const std::error_code& err)
  {
    if (!err)
    {
      // Check that response is OK.
      std::istream response_stream(&response_);
      std::string http_version;
      response_stream >> http_version;
      unsigned int status_code;
      response_stream >> status_code;
      std::string status_message;
      std::getline(response_stream, status_message);
      if (!response_stream || http_version.substr(0, 5) != "HTTP/")
      {
        std::cout << "Invalid response\n";
        return;
      }
      if (status_code != 200)
      {
        std::cout << "Response returned with status code ";
        std::cout << status_code << "\n";
        return;
      }

      // Read the response headers, which are terminated by a blank line.
      asio::async_read_until(socket_, response_, "\r\n\r\n",
          std::bind(&client::handle_read_headers, this,
            asio::placeholders::error));
    }
    else
    {
      std::cout << "Error: " << err << "\n";
    }
  }

  void handle_read_headers(const std::error_code& err)
  {
    if (!err)
    {
      // Process the response headers.
      std::istream response_stream(&response_);
      std::string header;
      while (std::getline(response_stream, header) && header != "\r")
        std::cout << header << "\n";
      std::cout << "\n";

      // Write whatever content we already have to output.
      if (response_.size() > 0)
        std::cout << &response_;

      // Start reading remaining data until EOF.
      asio::async_read(socket_, response_,
          asio::transfer_at_least(1),
          std::bind(&client::handle_read_content, this,
            asio::placeholders::error));
    }
    else
    {
      std::cout << "Error: " << err << "\n";
    }
  }

  void handle_read_content(const std::error_code& err)
  {
    if (!err)
    {
      // Write all of the data that has been read so far.
      std::cout << &response_;

      // Continue reading remaining data until EOF.
      asio::async_read(socket_, response_,
          asio::transfer_at_least(1),
          std::bind(&client::handle_read_content, this,
            asio::placeholders::error));
    }
    else if (err != asio::error::eof)
    {
      std::cout << "Error: " << err << "\n";
    }
  }

  tcp::resolver resolver_;
  tcp::socket socket_;
  asio::streambuf request_;
  asio::streambuf response_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cout << "Usage: async_client <server> <path>\n";
      std::cout << "Example:\n";
      std::cout << "  async_client www.boost.org /LICENSE_1_0.txt\n";
      return 1;
    }

    asio::io_context io_context;
    client c(io_context, argv[1], argv[2]);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\client\sync_client.cpp
//
// sync_client.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <istream>
#include <ostream>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cout << "Usage: sync_client <server> <path>\n";
      std::cout << "Example:\n";
      std::cout << "  sync_client www.boost.org /LICENSE_1_0.txt\n";
      return 1;
    }

    asio::io_context io_context;

    // Get a list of endpoints corresponding to the server name.
    tcp::resolver resolver(io_context);
    tcp::resolver::results_type endpoints = resolver.resolve(argv[1], "http");

    // Try each endpoint until we successfully establish a connection.
    tcp::socket socket(io_context);
    asio::connect(socket, endpoints);

    // Form the request. We specify the "Connection: close" header so that the
    // server will close the socket after transmitting the response. This will
    // allow us to treat all data up until the EOF as the content.
    asio::streambuf request;
    std::ostream request_stream(&request);
    request_stream << "GET " << argv[2] << " HTTP/1.0\r\n";
    request_stream << "Host: " << argv[1] << "\r\n";
    request_stream << "Accept: */*\r\n";
    request_stream << "Connection: close\r\n\r\n";

    // Send the request.
    asio::write(socket, request);

    // Read the response status line. The response streambuf will automatically
    // grow to accommodate the entire line. The growth may be limited by passing
    // a maximum size to the streambuf constructor.
    asio::streambuf response;
    asio::read_until(socket, response, "\r\n");

    // Check that response is OK.
    std::istream response_stream(&response);
    std::string http_version;
    response_stream >> http_version;
    unsigned int status_code;
    response_stream >> status_code;
    std::string status_message;
    std::getline(response_stream, status_message);
    if (!response_stream || http_version.substr(0, 5) != "HTTP/")
    {
      std::cout << "Invalid response\n";
      return 1;
    }
    if (status_code != 200)
    {
      std::cout << "Response returned with status code " << status_code << "\n";
      return 1;
    }

    // Read the response headers, which are terminated by a blank line.
    asio::read_until(socket, response, "\r\n\r\n");

    // Process the response headers.
    std::string header;
    while (std::getline(response_stream, header) && header != "\r")
      std::cout << header << "\n";
    std::cout << "\n";

    // Write whatever content we already have to output.
    if (response.size() > 0)
      std::cout << &response;

    // Read until EOF, writing data to output as we go.
    std::error_code error;
    while (asio::read(socket, response,
          asio::transfer_at_least(1), error))
      std::cout << &response;
    if (error != asio::error::eof)
      throw std::system_error(error);
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\connection_manager.cpp
//
// connection_manager.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "connection_manager.hpp"

namespace http {
namespace server {

connection_manager::connection_manager()
{
}

void connection_manager::start(connection_ptr c)
{
  connections_.insert(c);
  c->start();
}

void connection_manager::stop(connection_ptr c)
{
  connections_.erase(c);
  c->stop();
}

void connection_manager::stop_all()
{
  for (auto c: connections_)
    c->stop();
  connections_.clear();
}

} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\connection.cpp
//
// connection.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "connection.hpp"
#include <utility>
#include "connection_manager.hpp"
#include "request_handler.hpp"

namespace http {
namespace server {

connection::connection(asio::ip::tcp::socket socket,
    connection_manager& manager, request_handler& handler)
  : socket_(std::move(socket)),
    connection_manager_(manager),
    request_handler_(handler)
{
}

void connection::start()
{
  do_read();
}

void connection::stop()
{
  socket_.close();
}

void connection::do_read()
{
  auto self(shared_from_this());
  socket_.async_read_some(asio::buffer(buffer_),
      [this, self](std::error_code ec, std::size_t bytes_transferred)
      {
        if (!ec)
        {
          request_parser::result_type result;
          std::tie(result, std::ignore) = request_parser_.parse(
              request_, buffer_.data(), buffer_.data() + bytes_transferred);

          if (result == request_parser::good)
          {
            request_handler_.handle_request(request_, reply_);
            do_write();
          }
          else if (result == request_parser::bad)
          {
            reply_ = reply::stock_reply(reply::bad_request);
            do_write();
          }
          else
          {
            do_read();
          }
        }
        else if (ec != asio::error::operation_aborted)
        {
          connection_manager_.stop(shared_from_this());
        }
      });
}

void connection::do_write()
{
  auto self(shared_from_this());
  asio::async_write(socket_, reply_.to_buffers(),
      [this, self](std::error_code ec, std::size_t)
      {
        if (!ec)
        {
          // Initiate graceful connection closure.
          std::error_code ignored_ec;
          socket_.shutdown(asio::ip::tcp::socket::shutdown_both,
            ignored_ec);
        }

        if (ec != asio::error::operation_aborted)
        {
          connection_manager_.stop(shared_from_this());
        }
      });
}

} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\main.cpp
//
// main.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <string>
#include <asio.hpp>
#include "server.hpp"

int main(int argc, char* argv[])
{
  try
  {
    // Check command line arguments.
    if (argc != 4)
    {
      std::cerr << "Usage: http_server <address> <port> <doc_root>\n";
      std::cerr << "  For IPv4, try:\n";
      std::cerr << "    receiver 0.0.0.0 80 .\n";
      std::cerr << "  For IPv6, try:\n";
      std::cerr << "    receiver 0::0 80 .\n";
      return 1;
    }

    // Initialise the server.
    http::server::server s(argv[1], argv[2], argv[3]);

    // Run the server until stopped.
    s.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\mime_types.cpp
//
// mime_types.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "mime_types.hpp"

namespace http {
namespace server {
namespace mime_types {

struct mapping
{
  const char* extension;
  const char* mime_type;
} mappings[] =
{
  { "gif", "image/gif" },
  { "htm", "text/html" },
  { "html", "text/html" },
  { "jpg", "image/jpeg" },
  { "png", "image/png" }
};

std::string extension_to_type(const std::string& extension)
{
  for (mapping m: mappings)
  {
    if (m.extension == extension)
    {
      return m.mime_type;
    }
  }

  return "text/plain";
}

} // namespace mime_types
} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\reply.cpp
//
// reply.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "reply.hpp"
#include <string>

namespace http {
namespace server {

namespace status_strings {

const std::string ok =
  "HTTP/1.0 200 OK\r\n";
const std::string created =
  "HTTP/1.0 201 Created\r\n";
const std::string accepted =
  "HTTP/1.0 202 Accepted\r\n";
const std::string no_content =
  "HTTP/1.0 204 No Content\r\n";
const std::string multiple_choices =
  "HTTP/1.0 300 Multiple Choices\r\n";
const std::string moved_permanently =
  "HTTP/1.0 301 Moved Permanently\r\n";
const std::string moved_temporarily =
  "HTTP/1.0 302 Moved Temporarily\r\n";
const std::string not_modified =
  "HTTP/1.0 304 Not Modified\r\n";
const std::string bad_request =
  "HTTP/1.0 400 Bad Request\r\n";
const std::string unauthorized =
  "HTTP/1.0 401 Unauthorized\r\n";
const std::string forbidden =
  "HTTP/1.0 403 Forbidden\r\n";
const std::string not_found =
  "HTTP/1.0 404 Not Found\r\n";
const std::string internal_server_error =
  "HTTP/1.0 500 Internal Server Error\r\n";
const std::string not_implemented =
  "HTTP/1.0 501 Not Implemented\r\n";
const std::string bad_gateway =
  "HTTP/1.0 502 Bad Gateway\r\n";
const std::string service_unavailable =
  "HTTP/1.0 503 Service Unavailable\r\n";

asio::const_buffer to_buffer(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return asio::buffer(ok);
  case reply::created:
    return asio::buffer(created);
  case reply::accepted:
    return asio::buffer(accepted);
  case reply::no_content:
    return asio::buffer(no_content);
  case reply::multiple_choices:
    return asio::buffer(multiple_choices);
  case reply::moved_permanently:
    return asio::buffer(moved_permanently);
  case reply::moved_temporarily:
    return asio::buffer(moved_temporarily);
  case reply::not_modified:
    return asio::buffer(not_modified);
  case reply::bad_request:
    return asio::buffer(bad_request);
  case reply::unauthorized:
    return asio::buffer(unauthorized);
  case reply::forbidden:
    return asio::buffer(forbidden);
  case reply::not_found:
    return asio::buffer(not_found);
  case reply::internal_server_error:
    return asio::buffer(internal_server_error);
  case reply::not_implemented:
    return asio::buffer(not_implemented);
  case reply::bad_gateway:
    return asio::buffer(bad_gateway);
  case reply::service_unavailable:
    return asio::buffer(service_unavailable);
  default:
    return asio::buffer(internal_server_error);
  }
}

} // namespace status_strings

namespace misc_strings {

const char name_value_separator[] = { ':', ' ' };
const char crlf[] = { '\r', '\n' };

} // namespace misc_strings

std::vector<asio::const_buffer> reply::to_buffers()
{
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(status_strings::to_buffer(status));
  for (std::size_t i = 0; i < headers.size(); ++i)
  {
    header& h = headers[i];
    buffers.push_back(asio::buffer(h.name));
    buffers.push_back(asio::buffer(misc_strings::name_value_separator));
    buffers.push_back(asio::buffer(h.value));
    buffers.push_back(asio::buffer(misc_strings::crlf));
  }
  buffers.push_back(asio::buffer(misc_strings::crlf));
  buffers.push_back(asio::buffer(content));
  return buffers;
}

namespace stock_replies {

const char ok[] = "";
const char created[] =
  "<html>"
  "<head><title>Created</title></head>"
  "<body><h1>201 Created</h1></body>"
  "</html>";
const char accepted[] =
  "<html>"
  "<head><title>Accepted</title></head>"
  "<body><h1>202 Accepted</h1></body>"
  "</html>";
const char no_content[] =
  "<html>"
  "<head><title>No Content</title></head>"
  "<body><h1>204 Content</h1></body>"
  "</html>";
const char multiple_choices[] =
  "<html>"
  "<head><title>Multiple Choices</title></head>"
  "<body><h1>300 Multiple Choices</h1></body>"
  "</html>";
const char moved_permanently[] =
  "<html>"
  "<head><title>Moved Permanently</title></head>"
  "<body><h1>301 Moved Permanently</h1></body>"
  "</html>";
const char moved_temporarily[] =
  "<html>"
  "<head><title>Moved Temporarily</title></head>"
  "<body><h1>302 Moved Temporarily</h1></body>"
  "</html>";
const char not_modified[] =
  "<html>"
  "<head><title>Not Modified</title></head>"
  "<body><h1>304 Not Modified</h1></body>"
  "</html>";
const char bad_request[] =
  "<html>"
  "<head><title>Bad Request</title></head>"
  "<body><h1>400 Bad Request</h1></body>"
  "</html>";
const char unauthorized[] =
  "<html>"
  "<head><title>Unauthorized</title></head>"
  "<body><h1>401 Unauthorized</h1></body>"
  "</html>";
const char forbidden[] =
  "<html>"
  "<head><title>Forbidden</title></head>"
  "<body><h1>403 Forbidden</h1></body>"
  "</html>";
const char not_found[] =
  "<html>"
  "<head><title>Not Found</title></head>"
  "<body><h1>404 Not Found</h1></body>"
  "</html>";
const char internal_server_error[] =
  "<html>"
  "<head><title>Internal Server Error</title></head>"
  "<body><h1>500 Internal Server Error</h1></body>"
  "</html>";
const char not_implemented[] =
  "<html>"
  "<head><title>Not Implemented</title></head>"
  "<body><h1>501 Not Implemented</h1></body>"
  "</html>";
const char bad_gateway[] =
  "<html>"
  "<head><title>Bad Gateway</title></head>"
  "<body><h1>502 Bad Gateway</h1></body>"
  "</html>";
const char service_unavailable[] =
  "<html>"
  "<head><title>Service Unavailable</title></head>"
  "<body><h1>503 Service Unavailable</h1></body>"
  "</html>";

std::string to_string(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return ok;
  case reply::created:
    return created;
  case reply::accepted:
    return accepted;
  case reply::no_content:
    return no_content;
  case reply::multiple_choices:
    return multiple_choices;
  case reply::moved_permanently:
    return moved_permanently;
  case reply::moved_temporarily:
    return moved_temporarily;
  case reply::not_modified:
    return not_modified;
  case reply::bad_request:
    return bad_request;
  case reply::unauthorized:
    return unauthorized;
  case reply::forbidden:
    return forbidden;
  case reply::not_found:
    return not_found;
  case reply::internal_server_error:
    return internal_server_error;
  case reply::not_implemented:
    return not_implemented;
  case reply::bad_gateway:
    return bad_gateway;
  case reply::service_unavailable:
    return service_unavailable;
  default:
    return internal_server_error;
  }
}

} // namespace stock_replies

reply reply::stock_reply(reply::status_type status)
{
  reply rep;
  rep.status = status;
  rep.content = stock_replies::to_string(status);
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = "text/html";
  return rep;
}

} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\request_handler.cpp
//
// request_handler.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_handler.hpp"
#include <fstream>
#include <sstream>
#include <string>
#include "mime_types.hpp"
#include "reply.hpp"
#include "request.hpp"

namespace http {
namespace server {

request_handler::request_handler(const std::string& doc_root)
  : doc_root_(doc_root)
{
}

void request_handler::handle_request(const request& req, reply& rep)
{
  // Decode url to path.
  std::string request_path;
  if (!url_decode(req.uri, request_path))
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // Request path must be absolute and not contain "..".
  if (request_path.empty() || request_path[0] != '/'
      || request_path.find("..") != std::string::npos)
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // If path ends in slash (i.e. is a directory) then add "index.html".
  if (request_path[request_path.size() - 1] == '/')
  {
    request_path += "index.html";
  }

  // Determine the file extension.
  std::size_t last_slash_pos = request_path.find_last_of("/");
  std::size_t last_dot_pos = request_path.find_last_of(".");
  std::string extension;
  if (last_dot_pos != std::string::npos && last_dot_pos > last_slash_pos)
  {
    extension = request_path.substr(last_dot_pos + 1);
  }

  // Open the file to send back.
  std::string full_path = doc_root_ + request_path;
  std::ifstream is(full_path.c_str(), std::ios::in | std::ios::binary);
  if (!is)
  {
    rep = reply::stock_reply(reply::not_found);
    return;
  }

  // Fill out the reply to be sent to the client.
  rep.status = reply::ok;
  char buf[512];
  while (is.read(buf, sizeof(buf)).gcount() > 0)
    rep.content.append(buf, is.gcount());
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = mime_types::extension_to_type(extension);
}

bool request_handler::url_decode(const std::string& in, std::string& out)
{
  out.clear();
  out.reserve(in.size());
  for (std::size_t i = 0; i < in.size(); ++i)
  {
    if (in[i] == '%')
    {
      if (i + 3 <= in.size())
      {
        int value = 0;
        std::istringstream is(in.substr(i + 1, 2));
        if (is >> std::hex >> value)
        {
          out += static_cast<char>(value);
          i += 2;
        }
        else
        {
          return false;
        }
      }
      else
      {
        return false;
      }
    }
    else if (in[i] == '+')
    {
      out += ' ';
    }
    else
    {
      out += in[i];
    }
  }
  return true;
}

} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\request_parser.cpp
//
// request_parser.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_parser.hpp"
#include "request.hpp"

namespace http {
namespace server {

request_parser::request_parser()
  : state_(method_start)
{
}

void request_parser::reset()
{
  state_ = method_start;
}

request_parser::result_type request_parser::consume(request& req, char input)
{
  switch (state_)
  {
  case method_start:
    if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      state_ = method;
      req.method.push_back(input);
      return indeterminate;
    }
  case method:
    if (input == ' ')
    {
      state_ = uri;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.method.push_back(input);
      return indeterminate;
    }
  case uri:
    if (input == ' ')
    {
      state_ = http_version_h;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.uri.push_back(input);
      return indeterminate;
    }
  case http_version_h:
    if (input == 'H')
    {
      state_ = http_version_t_1;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_1:
    if (input == 'T')
    {
      state_ = http_version_t_2;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_2:
    if (input == 'T')
    {
      state_ = http_version_p;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_p:
    if (input == 'P')
    {
      state_ = http_version_slash;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_slash:
    if (input == '/')
    {
      req.http_version_major = 0;
      req.http_version_minor = 0;
      state_ = http_version_major_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major_start:
    if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      state_ = http_version_major;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major:
    if (input == '.')
    {
      state_ = http_version_minor_start;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor_start:
    if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      state_ = http_version_minor;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor:
    if (input == '\r')
    {
      state_ = expecting_newline_1;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_1:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_line_start:
    if (input == '\r')
    {
      state_ = expecting_newline_3;
      return indeterminate;
    }
    else if (!req.headers.empty() && (input == ' ' || input == '\t'))
    {
      state_ = header_lws;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.push_back(header());
      req.headers.back().name.push_back(input);
      state_ = header_name;
      return indeterminate;
    }
  case header_lws:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (input == ' ' || input == '\t')
    {
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      state_ = header_value;
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case header_name:
    if (input == ':')
    {
      state_ = space_before_header_value;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().name.push_back(input);
      return indeterminate;
    }
  case space_before_header_value:
    if (input == ' ')
    {
      state_ = header_value;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_value:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case expecting_newline_2:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_3:
    return (input == '\n') ? good : bad;
  default:
    return bad;
  }
}

bool request_parser::is_char(int c)
{
  return c >= 0 && c <= 127;
}

bool request_parser::is_ctl(int c)
{
  return (c >= 0 && c <= 31) || (c == 127);
}

bool request_parser::is_tspecial(int c)
{
  switch (c)
  {
  case '(': case ')': case '<': case '>': case '@':
  case ',': case ';': case ':': case '\\': case '"':
  case '/': case '[': case ']': case '?': case '=':
  case '{': case '}': case ' ': case '\t':
    return true;
  default:
    return false;
  }
}

bool request_parser::is_digit(int c)
{
  return c >= '0' && c <= '9';
}

} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "server.hpp"
#include <signal.h>
#include <utility>

namespace http {
namespace server {

server::server(const std::string& address, const std::string& port,
    const std::string& doc_root)
  : io_context_(1),
    signals_(io_context_),
    acceptor_(io_context_),
    connection_manager_(),
    request_handler_(doc_root)
{
  // Register to handle the signals that indicate when the server should exit.
  // It is safe to register for the same signal multiple times in a program,
  // provided all registration for the specified signal is made through Asio.
  signals_.add(SIGINT);
  signals_.add(SIGTERM);
#if defined(SIGQUIT)
  signals_.add(SIGQUIT);
#endif // defined(SIGQUIT)

  do_await_stop();

  // Open the acceptor with the option to reuse the address (i.e. SO_REUSEADDR).
  asio::ip::tcp::resolver resolver(io_context_);
  asio::ip::tcp::endpoint endpoint =
    *resolver.resolve(address, port).begin();
  acceptor_.open(endpoint.protocol());
  acceptor_.set_option(asio::ip::tcp::acceptor::reuse_address(true));
  acceptor_.bind(endpoint);
  acceptor_.listen();

  do_accept();
}

void server::run()
{
  // The io_context::run() call will block until all asynchronous operations
  // have finished. While the server is running, there is always at least one
  // asynchronous operation outstanding: the asynchronous accept call waiting
  // for new incoming connections.
  io_context_.run();
}

void server::do_accept()
{
  acceptor_.async_accept(
      [this](std::error_code ec, asio::ip::tcp::socket socket)
      {
        // Check whether the server was stopped by a signal before this
        // completion handler had a chance to run.
        if (!acceptor_.is_open())
        {
          return;
        }

        if (!ec)
        {
          connection_manager_.start(std::make_shared<connection>(
              std::move(socket), connection_manager_, request_handler_));
        }

        do_accept();
      });
}

void server::do_await_stop()
{
  signals_.async_wait(
      [this](std::error_code /*ec*/, int /*signo*/)
      {
        // The server is stopped by cancelling all outstanding asynchronous
        // operations. Once all operations have finished the io_context::run()
        // call will exit.
        acceptor_.close();
        connection_manager_.stop_all();
      });
}

} // namespace server
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\connection.cpp
//
// connection.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "connection.hpp"
#include <utility>
#include "request_handler.hpp"

namespace http {
namespace server2 {

connection::connection(asio::ip::tcp::socket socket,
    request_handler& handler)
  : socket_(std::move(socket)),
    request_handler_(handler)
{
}

void connection::start()
{
  do_read();
}

void connection::do_read()
{
  auto self(shared_from_this());
  socket_.async_read_some(asio::buffer(buffer_),
      [this, self](std::error_code ec, std::size_t bytes_transferred)
      {
        if (!ec)
        {
          request_parser::result_type result;
          std::tie(result, std::ignore) = request_parser_.parse(
              request_, buffer_.data(), buffer_.data() + bytes_transferred);

          if (result == request_parser::good)
          {
            request_handler_.handle_request(request_, reply_);
            do_write();
          }
          else if (result == request_parser::bad)
          {
            reply_ = reply::stock_reply(reply::bad_request);
            do_write();
          }
          else
          {
            do_read();
          }
        }

        // If an error occurs then no new asynchronous operations are
        // started. This means that all shared_ptr references to the
        // connection object will disappear and the object will be
        // destroyed automatically after this handler returns. The
        // connection class's destructor closes the socket.
      });
}

void connection::do_write()
{
  auto self(shared_from_this());
  asio::async_write(socket_, reply_.to_buffers(),
      [this, self](std::error_code ec, std::size_t)
      {
        if (!ec)
        {
          // Initiate graceful connection closure.
          std::error_code ignored_ec;
          socket_.shutdown(asio::ip::tcp::socket::shutdown_both,
            ignored_ec);
        }

        // No new asynchronous operations are started. This means that
        // all shared_ptr references to the connection object will
        // disappear and the object will be destroyed automatically after
        // this handler returns. The connection class's destructor closes
        // the socket.
      });
}

} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\io_context_pool.cpp
//
// io_context_pool.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "server.hpp"
#include <stdexcept>
#include <thread>

namespace http {
namespace server2 {

io_context_pool::io_context_pool(std::size_t pool_size)
  : next_io_context_(0)
{
  if (pool_size == 0)
    throw std::runtime_error("io_context_pool size is 0");

  // Give all the io_contexts work to do so that their run() functions will not
  // exit until they are explicitly stopped.
  for (std::size_t i = 0; i < pool_size; ++i)
  {
    io_context_ptr io_context(new asio::io_context);
    io_contexts_.push_back(io_context);
    work_.push_back(asio::make_work_guard(*io_context));
  }
}

void io_context_pool::run()
{
  // Create a pool of threads to run all of the io_contexts.
  std::vector<std::thread> threads;
  for (std::size_t i = 0; i < io_contexts_.size(); ++i)
    threads.emplace_back([this, i]{ io_contexts_[i]->run(); });

  // Wait for all threads in the pool to exit.
  for (std::size_t i = 0; i < threads.size(); ++i)
    threads[i].join();
}

void io_context_pool::stop()
{
  // Explicitly stop all io_contexts.
  for (std::size_t i = 0; i < io_contexts_.size(); ++i)
    io_contexts_[i]->stop();
}

asio::io_context& io_context_pool::get_io_context()
{
  // Use a round-robin scheme to choose the next io_context to use.
  asio::io_context& io_context = *io_contexts_[next_io_context_];
  ++next_io_context_;
  if (next_io_context_ == io_contexts_.size())
    next_io_context_ = 0;
  return io_context;
}

} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\main.cpp
//
// main.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <string>
#include <asio.hpp>
#include "server.hpp"

int main(int argc, char* argv[])
{
  try
  {
    // Check command line arguments.
    if (argc != 5)
    {
      std::cerr << "Usage: http_server <address> <port> <threads> <doc_root>\n";
      std::cerr << "  For IPv4, try:\n";
      std::cerr << "    receiver 0.0.0.0 80 1 .\n";
      std::cerr << "  For IPv6, try:\n";
      std::cerr << "    receiver 0::0 80 1 .\n";
      return 1;
    }

    // Initialise the server.
    std::size_t num_threads = std::stoi(argv[3]);
    http::server2::server s(argv[1], argv[2], argv[4], num_threads);

    // Run the server until stopped.
    s.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\mime_types.cpp
//
// mime_types.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "mime_types.hpp"

namespace http {
namespace server2 {
namespace mime_types {

struct mapping
{
  const char* extension;
  const char* mime_type;
} mappings[] =
{
  { "gif", "image/gif" },
  { "htm", "text/html" },
  { "html", "text/html" },
  { "jpg", "image/jpeg" },
  { "png", "image/png" },
  { 0, 0 } // Marks end of list.
};

std::string extension_to_type(const std::string& extension)
{
  for (mapping* m = mappings; m->extension; ++m)
  {
    if (m->extension == extension)
    {
      return m->mime_type;
    }
  }

  return "text/plain";
}

} // namespace mime_types
} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\reply.cpp
//
// reply.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "reply.hpp"
#include <string>

namespace http {
namespace server2 {

namespace status_strings {

const std::string ok =
  "HTTP/1.0 200 OK\r\n";
const std::string created =
  "HTTP/1.0 201 Created\r\n";
const std::string accepted =
  "HTTP/1.0 202 Accepted\r\n";
const std::string no_content =
  "HTTP/1.0 204 No Content\r\n";
const std::string multiple_choices =
  "HTTP/1.0 300 Multiple Choices\r\n";
const std::string moved_permanently =
  "HTTP/1.0 301 Moved Permanently\r\n";
const std::string moved_temporarily =
  "HTTP/1.0 302 Moved Temporarily\r\n";
const std::string not_modified =
  "HTTP/1.0 304 Not Modified\r\n";
const std::string bad_request =
  "HTTP/1.0 400 Bad Request\r\n";
const std::string unauthorized =
  "HTTP/1.0 401 Unauthorized\r\n";
const std::string forbidden =
  "HTTP/1.0 403 Forbidden\r\n";
const std::string not_found =
  "HTTP/1.0 404 Not Found\r\n";
const std::string internal_server_error =
  "HTTP/1.0 500 Internal Server Error\r\n";
const std::string not_implemented =
  "HTTP/1.0 501 Not Implemented\r\n";
const std::string bad_gateway =
  "HTTP/1.0 502 Bad Gateway\r\n";
const std::string service_unavailable =
  "HTTP/1.0 503 Service Unavailable\r\n";

asio::const_buffer to_buffer(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return asio::buffer(ok);
  case reply::created:
    return asio::buffer(created);
  case reply::accepted:
    return asio::buffer(accepted);
  case reply::no_content:
    return asio::buffer(no_content);
  case reply::multiple_choices:
    return asio::buffer(multiple_choices);
  case reply::moved_permanently:
    return asio::buffer(moved_permanently);
  case reply::moved_temporarily:
    return asio::buffer(moved_temporarily);
  case reply::not_modified:
    return asio::buffer(not_modified);
  case reply::bad_request:
    return asio::buffer(bad_request);
  case reply::unauthorized:
    return asio::buffer(unauthorized);
  case reply::forbidden:
    return asio::buffer(forbidden);
  case reply::not_found:
    return asio::buffer(not_found);
  case reply::internal_server_error:
    return asio::buffer(internal_server_error);
  case reply::not_implemented:
    return asio::buffer(not_implemented);
  case reply::bad_gateway:
    return asio::buffer(bad_gateway);
  case reply::service_unavailable:
    return asio::buffer(service_unavailable);
  default:
    return asio::buffer(internal_server_error);
  }
}

} // namespace status_strings

namespace misc_strings {

const char name_value_separator[] = { ':', ' ' };
const char crlf[] = { '\r', '\n' };

} // namespace misc_strings

std::vector<asio::const_buffer> reply::to_buffers()
{
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(status_strings::to_buffer(status));
  for (std::size_t i = 0; i < headers.size(); ++i)
  {
    header& h = headers[i];
    buffers.push_back(asio::buffer(h.name));
    buffers.push_back(asio::buffer(misc_strings::name_value_separator));
    buffers.push_back(asio::buffer(h.value));
    buffers.push_back(asio::buffer(misc_strings::crlf));
  }
  buffers.push_back(asio::buffer(misc_strings::crlf));
  buffers.push_back(asio::buffer(content));
  return buffers;
}

namespace stock_replies {

const char ok[] = "";
const char created[] =
  "<html>"
  "<head><title>Created</title></head>"
  "<body><h1>201 Created</h1></body>"
  "</html>";
const char accepted[] =
  "<html>"
  "<head><title>Accepted</title></head>"
  "<body><h1>202 Accepted</h1></body>"
  "</html>";
const char no_content[] =
  "<html>"
  "<head><title>No Content</title></head>"
  "<body><h1>204 Content</h1></body>"
  "</html>";
const char multiple_choices[] =
  "<html>"
  "<head><title>Multiple Choices</title></head>"
  "<body><h1>300 Multiple Choices</h1></body>"
  "</html>";
const char moved_permanently[] =
  "<html>"
  "<head><title>Moved Permanently</title></head>"
  "<body><h1>301 Moved Permanently</h1></body>"
  "</html>";
const char moved_temporarily[] =
  "<html>"
  "<head><title>Moved Temporarily</title></head>"
  "<body><h1>302 Moved Temporarily</h1></body>"
  "</html>";
const char not_modified[] =
  "<html>"
  "<head><title>Not Modified</title></head>"
  "<body><h1>304 Not Modified</h1></body>"
  "</html>";
const char bad_request[] =
  "<html>"
  "<head><title>Bad Request</title></head>"
  "<body><h1>400 Bad Request</h1></body>"
  "</html>";
const char unauthorized[] =
  "<html>"
  "<head><title>Unauthorized</title></head>"
  "<body><h1>401 Unauthorized</h1></body>"
  "</html>";
const char forbidden[] =
  "<html>"
  "<head><title>Forbidden</title></head>"
  "<body><h1>403 Forbidden</h1></body>"
  "</html>";
const char not_found[] =
  "<html>"
  "<head><title>Not Found</title></head>"
  "<body><h1>404 Not Found</h1></body>"
  "</html>";
const char internal_server_error[] =
  "<html>"
  "<head><title>Internal Server Error</title></head>"
  "<body><h1>500 Internal Server Error</h1></body>"
  "</html>";
const char not_implemented[] =
  "<html>"
  "<head><title>Not Implemented</title></head>"
  "<body><h1>501 Not Implemented</h1></body>"
  "</html>";
const char bad_gateway[] =
  "<html>"
  "<head><title>Bad Gateway</title></head>"
  "<body><h1>502 Bad Gateway</h1></body>"
  "</html>";
const char service_unavailable[] =
  "<html>"
  "<head><title>Service Unavailable</title></head>"
  "<body><h1>503 Service Unavailable</h1></body>"
  "</html>";

std::string to_string(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return ok;
  case reply::created:
    return created;
  case reply::accepted:
    return accepted;
  case reply::no_content:
    return no_content;
  case reply::multiple_choices:
    return multiple_choices;
  case reply::moved_permanently:
    return moved_permanently;
  case reply::moved_temporarily:
    return moved_temporarily;
  case reply::not_modified:
    return not_modified;
  case reply::bad_request:
    return bad_request;
  case reply::unauthorized:
    return unauthorized;
  case reply::forbidden:
    return forbidden;
  case reply::not_found:
    return not_found;
  case reply::internal_server_error:
    return internal_server_error;
  case reply::not_implemented:
    return not_implemented;
  case reply::bad_gateway:
    return bad_gateway;
  case reply::service_unavailable:
    return service_unavailable;
  default:
    return internal_server_error;
  }
}

} // namespace stock_replies

reply reply::stock_reply(reply::status_type status)
{
  reply rep;
  rep.status = status;
  rep.content = stock_replies::to_string(status);
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = "text/html";
  return rep;
}

} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\request_handler.cpp
//
// request_handler.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_handler.hpp"
#include <fstream>
#include <sstream>
#include <string>
#include "mime_types.hpp"
#include "reply.hpp"
#include "request.hpp"

namespace http {
namespace server2 {

request_handler::request_handler(const std::string& doc_root)
  : doc_root_(doc_root)
{
}

void request_handler::handle_request(const request& req, reply& rep)
{
  // Decode url to path.
  std::string request_path;
  if (!url_decode(req.uri, request_path))
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // Request path must be absolute and not contain "..".
  if (request_path.empty() || request_path[0] != '/'
      || request_path.find("..") != std::string::npos)
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // If path ends in slash (i.e. is a directory) then add "index.html".
  if (request_path[request_path.size() - 1] == '/')
  {
    request_path += "index.html";
  }

  // Determine the file extension.
  std::size_t last_slash_pos = request_path.find_last_of("/");
  std::size_t last_dot_pos = request_path.find_last_of(".");
  std::string extension;
  if (last_dot_pos != std::string::npos && last_dot_pos > last_slash_pos)
  {
    extension = request_path.substr(last_dot_pos + 1);
  }

  // Open the file to send back.
  std::string full_path = doc_root_ + request_path;
  std::ifstream is(full_path.c_str(), std::ios::in | std::ios::binary);
  if (!is)
  {
    rep = reply::stock_reply(reply::not_found);
    return;
  }

  // Fill out the reply to be sent to the client.
  rep.status = reply::ok;
  char buf[512];
  while (is.read(buf, sizeof(buf)).gcount() > 0)
    rep.content.append(buf, is.gcount());
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = mime_types::extension_to_type(extension);
}

bool request_handler::url_decode(const std::string& in, std::string& out)
{
  out.clear();
  out.reserve(in.size());
  for (std::size_t i = 0; i < in.size(); ++i)
  {
    if (in[i] == '%')
    {
      if (i + 3 <= in.size())
      {
        int value = 0;
        std::istringstream is(in.substr(i + 1, 2));
        if (is >> std::hex >> value)
        {
          out += static_cast<char>(value);
          i += 2;
        }
        else
        {
          return false;
        }
      }
      else
      {
        return false;
      }
    }
    else if (in[i] == '+')
    {
      out += ' ';
    }
    else
    {
      out += in[i];
    }
  }
  return true;
}

} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\request_parser.cpp
//
// request_parser.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_parser.hpp"
#include "request.hpp"

namespace http {
namespace server2 {

request_parser::request_parser()
  : state_(method_start)
{
}

void request_parser::reset()
{
  state_ = method_start;
}

request_parser::result_type request_parser::consume(request& req, char input)
{
  switch (state_)
  {
  case method_start:
    if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      state_ = method;
      req.method.push_back(input);
      return indeterminate;
    }
  case method:
    if (input == ' ')
    {
      state_ = uri;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.method.push_back(input);
      return indeterminate;
    }
  case uri:
    if (input == ' ')
    {
      state_ = http_version_h;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.uri.push_back(input);
      return indeterminate;
    }
  case http_version_h:
    if (input == 'H')
    {
      state_ = http_version_t_1;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_1:
    if (input == 'T')
    {
      state_ = http_version_t_2;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_2:
    if (input == 'T')
    {
      state_ = http_version_p;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_p:
    if (input == 'P')
    {
      state_ = http_version_slash;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_slash:
    if (input == '/')
    {
      req.http_version_major = 0;
      req.http_version_minor = 0;
      state_ = http_version_major_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major_start:
    if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      state_ = http_version_major;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major:
    if (input == '.')
    {
      state_ = http_version_minor_start;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor_start:
    if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      state_ = http_version_minor;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor:
    if (input == '\r')
    {
      state_ = expecting_newline_1;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_1:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_line_start:
    if (input == '\r')
    {
      state_ = expecting_newline_3;
      return indeterminate;
    }
    else if (!req.headers.empty() && (input == ' ' || input == '\t'))
    {
      state_ = header_lws;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.push_back(header());
      req.headers.back().name.push_back(input);
      state_ = header_name;
      return indeterminate;
    }
  case header_lws:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (input == ' ' || input == '\t')
    {
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      state_ = header_value;
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case header_name:
    if (input == ':')
    {
      state_ = space_before_header_value;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().name.push_back(input);
      return indeterminate;
    }
  case space_before_header_value:
    if (input == ' ')
    {
      state_ = header_value;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_value:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case expecting_newline_2:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_3:
    return (input == '\n') ? good : bad;
  default:
    return bad;
  }
}

bool request_parser::is_char(int c)
{
  return c >= 0 && c <= 127;
}

bool request_parser::is_ctl(int c)
{
  return (c >= 0 && c <= 31) || (c == 127);
}

bool request_parser::is_tspecial(int c)
{
  switch (c)
  {
  case '(': case ')': case '<': case '>': case '@':
  case ',': case ';': case ':': case '\\': case '"':
  case '/': case '[': case ']': case '?': case '=':
  case '{': case '}': case ' ': case '\t':
    return true;
  default:
    return false;
  }
}

bool request_parser::is_digit(int c)
{
  return c >= '0' && c <= '9';
}

} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server2\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "server.hpp"
#include <signal.h>
#include <utility>
#include "connection.hpp"

namespace http {
namespace server2 {

server::server(const std::string& address, const std::string& port,
    const std::string& doc_root, std::size_t io_context_pool_size)
  : io_context_pool_(io_context_pool_size),
    signals_(io_context_pool_.get_io_context()),
    acceptor_(io_context_pool_.get_io_context()),
    request_handler_(doc_root)
{
  // Register to handle the signals that indicate when the server should exit.
  // It is safe to register for the same signal multiple times in a program,
  // provided all registration for the specified signal is made through Asio.
  signals_.add(SIGINT);
  signals_.add(SIGTERM);
#if defined(SIGQUIT)
  signals_.add(SIGQUIT);
#endif // defined(SIGQUIT)

  do_await_stop();

  // Open the acceptor with the option to reuse the address (i.e. SO_REUSEADDR).
  asio::ip::tcp::resolver resolver(acceptor_.get_executor());
  asio::ip::tcp::endpoint endpoint =
    *resolver.resolve(address, port).begin();
  acceptor_.open(endpoint.protocol());
  acceptor_.set_option(asio::ip::tcp::acceptor::reuse_address(true));
  acceptor_.bind(endpoint);
  acceptor_.listen();

  do_accept();
}

void server::run()
{
  io_context_pool_.run();
}

void server::do_accept()
{
  acceptor_.async_accept(io_context_pool_.get_io_context(),
      [this](std::error_code ec, asio::ip::tcp::socket socket)
      {
        // Check whether the server was stopped by a signal before this
        // completion handler had a chance to run.
        if (!acceptor_.is_open())
        {
          return;
        }

        if (!ec)
        {
          std::make_shared<connection>(
              std::move(socket), request_handler_)->start();
        }

        do_accept();
      });
}

void server::do_await_stop()
{
  signals_.async_wait(
      [this](std::error_code /*ec*/, int /*signo*/)
      {
        io_context_pool_.stop();
      });
}

} // namespace server2
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\connection.cpp
//
// connection.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "connection.hpp"
#include <utility>
#include "request_handler.hpp"

namespace http {
namespace server3 {

connection::connection(asio::ip::tcp::socket socket,
    request_handler& handler)
  : socket_(std::move(socket)),
    request_handler_(handler)
{
}

void connection::start()
{
  do_read();
}

void connection::do_read()
{
  auto self(shared_from_this());
  socket_.async_read_some(asio::buffer(buffer_),
      [this, self](std::error_code ec, std::size_t bytes_transferred)
      {
        if (!ec)
        {
          request_parser::result_type result;
          std::tie(result, std::ignore) = request_parser_.parse(
              request_, buffer_.data(), buffer_.data() + bytes_transferred);

          if (result == request_parser::good)
          {
            request_handler_.handle_request(request_, reply_);
            do_write();
          }
          else if (result == request_parser::bad)
          {
            reply_ = reply::stock_reply(reply::bad_request);
            do_write();
          }
          else
          {
            do_read();
          }
        }

        // If an error occurs then no new asynchronous operations are
        // started. This means that all shared_ptr references to the
        // connection object will disappear and the object will be
        // destroyed automatically after this handler returns. The
        // connection class's destructor closes the socket.
      });
}

void connection::do_write()
{
  auto self(shared_from_this());
  asio::async_write(socket_, reply_.to_buffers(),
      [this, self](std::error_code ec, std::size_t)
      {
        if (!ec)
        {
          // Initiate graceful connection closure.
          std::error_code ignored_ec;
          socket_.shutdown(asio::ip::tcp::socket::shutdown_both,
            ignored_ec);
        }

        // No new asynchronous operations are started. This means that
        // all shared_ptr references to the connection object will
        // disappear and the object will be destroyed automatically after
        // this handler returns. The connection class's destructor closes
        // the socket.
      });
}

} // namespace server3
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\main.cpp
//
// main.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <string>
#include <asio.hpp>
#include "server.hpp"

int main(int argc, char* argv[])
{
  try
  {
    // Check command line arguments.
    if (argc != 5)
    {
      std::cerr << "Usage: http_server <address> <port> <threads> <doc_root>\n";
      std::cerr << "  For IPv4, try:\n";
      std::cerr << "    receiver 0.0.0.0 80 1 .\n";
      std::cerr << "  For IPv6, try:\n";
      std::cerr << "    receiver 0::0 80 1 .\n";
      return 1;
    }

    // Initialise the server.
    std::size_t num_threads = std::stoi(argv[3]);
    http::server3::server s(argv[1], argv[2], argv[4], num_threads);

    // Run the server until stopped.
    s.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\mime_types.cpp
//
// mime_types.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "mime_types.hpp"

namespace http {
namespace server3 {
namespace mime_types {

struct mapping
{
  const char* extension;
  const char* mime_type;
} mappings[] =
{
  { "gif", "image/gif" },
  { "htm", "text/html" },
  { "html", "text/html" },
  { "jpg", "image/jpeg" },
  { "png", "image/png" },
  { 0, 0 } // Marks end of list.
};

std::string extension_to_type(const std::string& extension)
{
  for (mapping* m = mappings; m->extension; ++m)
  {
    if (m->extension == extension)
    {
      return m->mime_type;
    }
  }

  return "text/plain";
}

} // namespace mime_types
} // namespace server3
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\reply.cpp
//
// reply.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "reply.hpp"
#include <string>

namespace http {
namespace server3 {

namespace status_strings {

const std::string ok =
  "HTTP/1.0 200 OK\r\n";
const std::string created =
  "HTTP/1.0 201 Created\r\n";
const std::string accepted =
  "HTTP/1.0 202 Accepted\r\n";
const std::string no_content =
  "HTTP/1.0 204 No Content\r\n";
const std::string multiple_choices =
  "HTTP/1.0 300 Multiple Choices\r\n";
const std::string moved_permanently =
  "HTTP/1.0 301 Moved Permanently\r\n";
const std::string moved_temporarily =
  "HTTP/1.0 302 Moved Temporarily\r\n";
const std::string not_modified =
  "HTTP/1.0 304 Not Modified\r\n";
const std::string bad_request =
  "HTTP/1.0 400 Bad Request\r\n";
const std::string unauthorized =
  "HTTP/1.0 401 Unauthorized\r\n";
const std::string forbidden =
  "HTTP/1.0 403 Forbidden\r\n";
const std::string not_found =
  "HTTP/1.0 404 Not Found\r\n";
const std::string internal_server_error =
  "HTTP/1.0 500 Internal Server Error\r\n";
const std::string not_implemented =
  "HTTP/1.0 501 Not Implemented\r\n";
const std::string bad_gateway =
  "HTTP/1.0 502 Bad Gateway\r\n";
const std::string service_unavailable =
  "HTTP/1.0 503 Service Unavailable\r\n";

asio::const_buffer to_buffer(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return asio::buffer(ok);
  case reply::created:
    return asio::buffer(created);
  case reply::accepted:
    return asio::buffer(accepted);
  case reply::no_content:
    return asio::buffer(no_content);
  case reply::multiple_choices:
    return asio::buffer(multiple_choices);
  case reply::moved_permanently:
    return asio::buffer(moved_permanently);
  case reply::moved_temporarily:
    return asio::buffer(moved_temporarily);
  case reply::not_modified:
    return asio::buffer(not_modified);
  case reply::bad_request:
    return asio::buffer(bad_request);
  case reply::unauthorized:
    return asio::buffer(unauthorized);
  case reply::forbidden:
    return asio::buffer(forbidden);
  case reply::not_found:
    return asio::buffer(not_found);
  case reply::internal_server_error:
    return asio::buffer(internal_server_error);
  case reply::not_implemented:
    return asio::buffer(not_implemented);
  case reply::bad_gateway:
    return asio::buffer(bad_gateway);
  case reply::service_unavailable:
    return asio::buffer(service_unavailable);
  default:
    return asio::buffer(internal_server_error);
  }
}

} // namespace status_strings

namespace misc_strings {

const char name_value_separator[] = { ':', ' ' };
const char crlf[] = { '\r', '\n' };

} // namespace misc_strings

std::vector<asio::const_buffer> reply::to_buffers()
{
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(status_strings::to_buffer(status));
  for (std::size_t i = 0; i < headers.size(); ++i)
  {
    header& h = headers[i];
    buffers.push_back(asio::buffer(h.name));
    buffers.push_back(asio::buffer(misc_strings::name_value_separator));
    buffers.push_back(asio::buffer(h.value));
    buffers.push_back(asio::buffer(misc_strings::crlf));
  }
  buffers.push_back(asio::buffer(misc_strings::crlf));
  buffers.push_back(asio::buffer(content));
  return buffers;
}

namespace stock_replies {

const char ok[] = "";
const char created[] =
  "<html>"
  "<head><title>Created</title></head>"
  "<body><h1>201 Created</h1></body>"
  "</html>";
const char accepted[] =
  "<html>"
  "<head><title>Accepted</title></head>"
  "<body><h1>202 Accepted</h1></body>"
  "</html>";
const char no_content[] =
  "<html>"
  "<head><title>No Content</title></head>"
  "<body><h1>204 Content</h1></body>"
  "</html>";
const char multiple_choices[] =
  "<html>"
  "<head><title>Multiple Choices</title></head>"
  "<body><h1>300 Multiple Choices</h1></body>"
  "</html>";
const char moved_permanently[] =
  "<html>"
  "<head><title>Moved Permanently</title></head>"
  "<body><h1>301 Moved Permanently</h1></body>"
  "</html>";
const char moved_temporarily[] =
  "<html>"
  "<head><title>Moved Temporarily</title></head>"
  "<body><h1>302 Moved Temporarily</h1></body>"
  "</html>";
const char not_modified[] =
  "<html>"
  "<head><title>Not Modified</title></head>"
  "<body><h1>304 Not Modified</h1></body>"
  "</html>";
const char bad_request[] =
  "<html>"
  "<head><title>Bad Request</title></head>"
  "<body><h1>400 Bad Request</h1></body>"
  "</html>";
const char unauthorized[] =
  "<html>"
  "<head><title>Unauthorized</title></head>"
  "<body><h1>401 Unauthorized</h1></body>"
  "</html>";
const char forbidden[] =
  "<html>"
  "<head><title>Forbidden</title></head>"
  "<body><h1>403 Forbidden</h1></body>"
  "</html>";
const char not_found[] =
  "<html>"
  "<head><title>Not Found</title></head>"
  "<body><h1>404 Not Found</h1></body>"
  "</html>";
const char internal_server_error[] =
  "<html>"
  "<head><title>Internal Server Error</title></head>"
  "<body><h1>500 Internal Server Error</h1></body>"
  "</html>";
const char not_implemented[] =
  "<html>"
  "<head><title>Not Implemented</title></head>"
  "<body><h1>501 Not Implemented</h1></body>"
  "</html>";
const char bad_gateway[] =
  "<html>"
  "<head><title>Bad Gateway</title></head>"
  "<body><h1>502 Bad Gateway</h1></body>"
  "</html>";
const char service_unavailable[] =
  "<html>"
  "<head><title>Service Unavailable</title></head>"
  "<body><h1>503 Service Unavailable</h1></body>"
  "</html>";

std::string to_string(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return ok;
  case reply::created:
    return created;
  case reply::accepted:
    return accepted;
  case reply::no_content:
    return no_content;
  case reply::multiple_choices:
    return multiple_choices;
  case reply::moved_permanently:
    return moved_permanently;
  case reply::moved_temporarily:
    return moved_temporarily;
  case reply::not_modified:
    return not_modified;
  case reply::bad_request:
    return bad_request;
  case reply::unauthorized:
    return unauthorized;
  case reply::forbidden:
    return forbidden;
  case reply::not_found:
    return not_found;
  case reply::internal_server_error:
    return internal_server_error;
  case reply::not_implemented:
    return not_implemented;
  case reply::bad_gateway:
    return bad_gateway;
  case reply::service_unavailable:
    return service_unavailable;
  default:
    return internal_server_error;
  }
}

} // namespace stock_replies

reply reply::stock_reply(reply::status_type status)
{
  reply rep;
  rep.status = status;
  rep.content = stock_replies::to_string(status);
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = "text/html";
  return rep;
}

} // namespace server3
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\request_handler.cpp
//
// request_handler.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_handler.hpp"
#include <fstream>
#include <sstream>
#include <string>
#include "mime_types.hpp"
#include "reply.hpp"
#include "request.hpp"

namespace http {
namespace server3 {

request_handler::request_handler(const std::string& doc_root)
  : doc_root_(doc_root)
{
}

void request_handler::handle_request(const request& req, reply& rep)
{
  // Decode url to path.
  std::string request_path;
  if (!url_decode(req.uri, request_path))
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // Request path must be absolute and not contain "..".
  if (request_path.empty() || request_path[0] != '/'
      || request_path.find("..") != std::string::npos)
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // If path ends in slash (i.e. is a directory) then add "index.html".
  if (request_path[request_path.size() - 1] == '/')
  {
    request_path += "index.html";
  }

  // Determine the file extension.
  std::size_t last_slash_pos = request_path.find_last_of("/");
  std::size_t last_dot_pos = request_path.find_last_of(".");
  std::string extension;
  if (last_dot_pos != std::string::npos && last_dot_pos > last_slash_pos)
  {
    extension = request_path.substr(last_dot_pos + 1);
  }

  // Open the file to send back.
  std::string full_path = doc_root_ + request_path;
  std::ifstream is(full_path.c_str(), std::ios::in | std::ios::binary);
  if (!is)
  {
    rep = reply::stock_reply(reply::not_found);
    return;
  }

  // Fill out the reply to be sent to the client.
  rep.status = reply::ok;
  char buf[512];
  while (is.read(buf, sizeof(buf)).gcount() > 0)
    rep.content.append(buf, is.gcount());
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = mime_types::extension_to_type(extension);
}

bool request_handler::url_decode(const std::string& in, std::string& out)
{
  out.clear();
  out.reserve(in.size());
  for (std::size_t i = 0; i < in.size(); ++i)
  {
    if (in[i] == '%')
    {
      if (i + 3 <= in.size())
      {
        int value = 0;
        std::istringstream is(in.substr(i + 1, 2));
        if (is >> std::hex >> value)
        {
          out += static_cast<char>(value);
          i += 2;
        }
        else
        {
          return false;
        }
      }
      else
      {
        return false;
      }
    }
    else if (in[i] == '+')
    {
      out += ' ';
    }
    else
    {
      out += in[i];
    }
  }
  return true;
}

} // namespace server3
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\request_parser.cpp
//
// request_parser.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_parser.hpp"
#include "request.hpp"

namespace http {
namespace server3 {

request_parser::request_parser()
  : state_(method_start)
{
}

void request_parser::reset()
{
  state_ = method_start;
}

request_parser::result_type request_parser::consume(request& req, char input)
{
  switch (state_)
  {
  case method_start:
    if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      state_ = method;
      req.method.push_back(input);
      return indeterminate;
    }
  case method:
    if (input == ' ')
    {
      state_ = uri;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.method.push_back(input);
      return indeterminate;
    }
  case uri:
    if (input == ' ')
    {
      state_ = http_version_h;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.uri.push_back(input);
      return indeterminate;
    }
  case http_version_h:
    if (input == 'H')
    {
      state_ = http_version_t_1;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_1:
    if (input == 'T')
    {
      state_ = http_version_t_2;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_2:
    if (input == 'T')
    {
      state_ = http_version_p;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_p:
    if (input == 'P')
    {
      state_ = http_version_slash;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_slash:
    if (input == '/')
    {
      req.http_version_major = 0;
      req.http_version_minor = 0;
      state_ = http_version_major_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major_start:
    if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      state_ = http_version_major;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major:
    if (input == '.')
    {
      state_ = http_version_minor_start;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor_start:
    if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      state_ = http_version_minor;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor:
    if (input == '\r')
    {
      state_ = expecting_newline_1;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_1:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_line_start:
    if (input == '\r')
    {
      state_ = expecting_newline_3;
      return indeterminate;
    }
    else if (!req.headers.empty() && (input == ' ' || input == '\t'))
    {
      state_ = header_lws;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.push_back(header());
      req.headers.back().name.push_back(input);
      state_ = header_name;
      return indeterminate;
    }
  case header_lws:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (input == ' ' || input == '\t')
    {
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      state_ = header_value;
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case header_name:
    if (input == ':')
    {
      state_ = space_before_header_value;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().name.push_back(input);
      return indeterminate;
    }
  case space_before_header_value:
    if (input == ' ')
    {
      state_ = header_value;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_value:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case expecting_newline_2:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_3:
    return (input == '\n') ? good : bad;
  default:
    return bad;
  }
}

bool request_parser::is_char(int c)
{
  return c >= 0 && c <= 127;
}

bool request_parser::is_ctl(int c)
{
  return (c >= 0 && c <= 31) || (c == 127);
}

bool request_parser::is_tspecial(int c)
{
  switch (c)
  {
  case '(': case ')': case '<': case '>': case '@':
  case ',': case ';': case ':': case '\\': case '"':
  case '/': case '[': case ']': case '?': case '=':
  case '{': case '}': case ' ': case '\t':
    return true;
  default:
    return false;
  }
}

bool request_parser::is_digit(int c)
{
  return c >= '0' && c <= '9';
}

} // namespace server3
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server3\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "server.hpp"
#include <signal.h>
#include <thread>
#include <utility>
#include <vector>
#include "connection.hpp"

namespace http {
namespace server3 {

server::server(const std::string& address, const std::string& port,
    const std::string& doc_root, std::size_t thread_pool_size)
  : thread_pool_size_(thread_pool_size),
    signals_(io_context_),
    acceptor_(io_context_),
    request_handler_(doc_root)
{
  // Register to handle the signals that indicate when the server should exit.
  // It is safe to register for the same signal multiple times in a program,
  // provided all registration for the specified signal is made through Asio.
  signals_.add(SIGINT);
  signals_.add(SIGTERM);
#if defined(SIGQUIT)
  signals_.add(SIGQUIT);
#endif // defined(SIGQUIT)

  do_await_stop();

  // Open the acceptor with the option to reuse the address (i.e. SO_REUSEADDR).
  asio::ip::tcp::resolver resolver(io_context_);
  asio::ip::tcp::endpoint endpoint =
    *resolver.resolve(address, port).begin();
  acceptor_.open(endpoint.protocol());
  acceptor_.set_option(asio::ip::tcp::acceptor::reuse_address(true));
  acceptor_.bind(endpoint);
  acceptor_.listen();

  do_accept();
}

void server::run()
{
  // Create a pool of threads to run the io_context.
  std::vector<std::thread> threads;
  for (std::size_t i = 0; i < thread_pool_size_; ++i)
    threads.emplace_back([this]{ io_context_.run(); });

  // Wait for all threads in the pool to exit.
  for (std::size_t i = 0; i < threads.size(); ++i)
    threads[i].join();
}

void server::do_accept()
{
  // The newly accepted socket is put into its own strand to ensure that all
  // completion handlers associated with the connection do not run concurrently.
  acceptor_.async_accept(asio::make_strand(io_context_),
      [this](std::error_code ec, asio::ip::tcp::socket socket)
      {
        // Check whether the server was stopped by a signal before this
        // completion handler had a chance to run.
        if (!acceptor_.is_open())
        {
          return;
        }

        if (!ec)
        {
          std::make_shared<connection>(
              std::move(socket), request_handler_)->start();
        }

        do_accept();
      });
}

void server::do_await_stop()
{
  signals_.async_wait(
      [this](std::error_code /*ec*/, int /*signo*/)
      {
        io_context_.stop();
      });
}

} // namespace server3
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server4\file_handler.cpp
//
// file_handler.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "file_handler.hpp"
#include <fstream>
#include <sstream>
#include <string>
#include "mime_types.hpp"
#include "reply.hpp"
#include "request.hpp"

namespace http {
namespace server4 {

file_handler::file_handler(const std::string& doc_root)
  : doc_root_(doc_root)
{
}

void file_handler::operator()(const request& req, reply& rep)
{
  // Decode url to path.
  std::string request_path;
  if (!url_decode(req.uri, request_path))
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // Request path must be absolute and not contain "..".
  if (request_path.empty() || request_path[0] != '/'
      || request_path.find("..") != std::string::npos)
  {
    rep = reply::stock_reply(reply::bad_request);
    return;
  }

  // If path ends in slash (i.e. is a directory) then add "index.html".
  if (request_path[request_path.size() - 1] == '/')
  {
    request_path += "index.html";
  }

  // Determine the file extension.
  std::size_t last_slash_pos = request_path.find_last_of("/");
  std::size_t last_dot_pos = request_path.find_last_of(".");
  std::string extension;
  if (last_dot_pos != std::string::npos && last_dot_pos > last_slash_pos)
  {
    extension = request_path.substr(last_dot_pos + 1);
  }

  // Open the file to send back.
  std::string full_path = doc_root_ + request_path;
  std::ifstream is(full_path.c_str(), std::ios::in | std::ios::binary);
  if (!is)
  {
    rep = reply::stock_reply(reply::not_found);
    return;
  }

  // Fill out the reply to be sent to the client.
  rep.status = reply::ok;
  char buf[512];
  while (is.read(buf, sizeof(buf)).gcount() > 0)
    rep.content.append(buf, is.gcount());
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = mime_types::extension_to_type(extension);
}

bool file_handler::url_decode(const std::string& in, std::string& out)
{
  out.clear();
  out.reserve(in.size());
  for (std::size_t i = 0; i < in.size(); ++i)
  {
    if (in[i] == '%')
    {
      if (i + 3 <= in.size())
      {
        int value = 0;
        std::istringstream is(in.substr(i + 1, 2));
        if (is >> std::hex >> value)
        {
          out += static_cast<char>(value);
          i += 2;
        }
        else
        {
          return false;
        }
      }
      else
      {
        return false;
      }
    }
    else if (in[i] == '+')
    {
      out += ' ';
    }
    else
    {
      out += in[i];
    }
  }
  return true;
}

} // namespace server4
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server4\main.cpp
//
// main.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <asio.hpp>
#include <signal.h>
#include "server.hpp"
#include "file_handler.hpp"

int main(int argc, char* argv[])
{
  try
  {
    // Check command line arguments.
    if (argc != 4)
    {
      std::cerr << "Usage: http_server <address> <port> <doc_root>\n";
      std::cerr << "  For IPv4, try:\n";
      std::cerr << "    receiver 0.0.0.0 80 .\n";
      std::cerr << "  For IPv6, try:\n";
      std::cerr << "    receiver 0::0 80 .\n";
      return 1;
    }

    asio::io_context io_context;

    // Launch the initial server coroutine.
    http::server4::server(io_context, argv[1], argv[2],
        http::server4::file_handler(argv[3]))();

    // Wait for signals indicating time to shut down.
    asio::signal_set signals(io_context);
    signals.add(SIGINT);
    signals.add(SIGTERM);
#if defined(SIGQUIT)
    signals.add(SIGQUIT);
#endif // defined(SIGQUIT)
    signals.async_wait(
        [&io_context](std::error_code, int)
        {
          io_context.stop();
        });

    // Run the server.
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server4\mime_types.cpp
//
// mime_types.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "mime_types.hpp"

namespace http {
namespace server4 {
namespace mime_types {

struct mapping
{
  const char* extension;
  const char* mime_type;
} mappings[] =
{
  { "gif", "image/gif" },
  { "htm", "text/html" },
  { "html", "text/html" },
  { "jpg", "image/jpeg" },
  { "png", "image/png" },
  { 0, 0 } // Marks end of list.
};

std::string extension_to_type(const std::string& extension)
{
  for (mapping* m = mappings; m->extension; ++m)
  {
    if (m->extension == extension)
    {
      return m->mime_type;
    }
  }

  return "text/plain";
}

} // namespace mime_types
} // namespace server4
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server4\reply.cpp
//
// reply.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "reply.hpp"
#include <string>

namespace http {
namespace server4 {

namespace status_strings {

const std::string ok =
  "HTTP/1.0 200 OK\r\n";
const std::string created =
  "HTTP/1.0 201 Created\r\n";
const std::string accepted =
  "HTTP/1.0 202 Accepted\r\n";
const std::string no_content =
  "HTTP/1.0 204 No Content\r\n";
const std::string multiple_choices =
  "HTTP/1.0 300 Multiple Choices\r\n";
const std::string moved_permanently =
  "HTTP/1.0 301 Moved Permanently\r\n";
const std::string moved_temporarily =
  "HTTP/1.0 302 Moved Temporarily\r\n";
const std::string not_modified =
  "HTTP/1.0 304 Not Modified\r\n";
const std::string bad_request =
  "HTTP/1.0 400 Bad Request\r\n";
const std::string unauthorized =
  "HTTP/1.0 401 Unauthorized\r\n";
const std::string forbidden =
  "HTTP/1.0 403 Forbidden\r\n";
const std::string not_found =
  "HTTP/1.0 404 Not Found\r\n";
const std::string internal_server_error =
  "HTTP/1.0 500 Internal Server Error\r\n";
const std::string not_implemented =
  "HTTP/1.0 501 Not Implemented\r\n";
const std::string bad_gateway =
  "HTTP/1.0 502 Bad Gateway\r\n";
const std::string service_unavailable =
  "HTTP/1.0 503 Service Unavailable\r\n";

asio::const_buffer to_buffer(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return asio::buffer(ok);
  case reply::created:
    return asio::buffer(created);
  case reply::accepted:
    return asio::buffer(accepted);
  case reply::no_content:
    return asio::buffer(no_content);
  case reply::multiple_choices:
    return asio::buffer(multiple_choices);
  case reply::moved_permanently:
    return asio::buffer(moved_permanently);
  case reply::moved_temporarily:
    return asio::buffer(moved_temporarily);
  case reply::not_modified:
    return asio::buffer(not_modified);
  case reply::bad_request:
    return asio::buffer(bad_request);
  case reply::unauthorized:
    return asio::buffer(unauthorized);
  case reply::forbidden:
    return asio::buffer(forbidden);
  case reply::not_found:
    return asio::buffer(not_found);
  case reply::internal_server_error:
    return asio::buffer(internal_server_error);
  case reply::not_implemented:
    return asio::buffer(not_implemented);
  case reply::bad_gateway:
    return asio::buffer(bad_gateway);
  case reply::service_unavailable:
    return asio::buffer(service_unavailable);
  default:
    return asio::buffer(internal_server_error);
  }
}

} // namespace status_strings

namespace misc_strings {

const char name_value_separator[] = { ':', ' ' };
const char crlf[] = { '\r', '\n' };

} // namespace misc_strings

std::vector<asio::const_buffer> reply::to_buffers()
{
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(status_strings::to_buffer(status));
  for (std::size_t i = 0; i < headers.size(); ++i)
  {
    header& h = headers[i];
    buffers.push_back(asio::buffer(h.name));
    buffers.push_back(asio::buffer(misc_strings::name_value_separator));
    buffers.push_back(asio::buffer(h.value));
    buffers.push_back(asio::buffer(misc_strings::crlf));
  }
  buffers.push_back(asio::buffer(misc_strings::crlf));
  buffers.push_back(asio::buffer(content));
  return buffers;
}

namespace stock_replies {

const char ok[] = "";
const char created[] =
  "<html>"
  "<head><title>Created</title></head>"
  "<body><h1>201 Created</h1></body>"
  "</html>";
const char accepted[] =
  "<html>"
  "<head><title>Accepted</title></head>"
  "<body><h1>202 Accepted</h1></body>"
  "</html>";
const char no_content[] =
  "<html>"
  "<head><title>No Content</title></head>"
  "<body><h1>204 Content</h1></body>"
  "</html>";
const char multiple_choices[] =
  "<html>"
  "<head><title>Multiple Choices</title></head>"
  "<body><h1>300 Multiple Choices</h1></body>"
  "</html>";
const char moved_permanently[] =
  "<html>"
  "<head><title>Moved Permanently</title></head>"
  "<body><h1>301 Moved Permanently</h1></body>"
  "</html>";
const char moved_temporarily[] =
  "<html>"
  "<head><title>Moved Temporarily</title></head>"
  "<body><h1>302 Moved Temporarily</h1></body>"
  "</html>";
const char not_modified[] =
  "<html>"
  "<head><title>Not Modified</title></head>"
  "<body><h1>304 Not Modified</h1></body>"
  "</html>";
const char bad_request[] =
  "<html>"
  "<head><title>Bad Request</title></head>"
  "<body><h1>400 Bad Request</h1></body>"
  "</html>";
const char unauthorized[] =
  "<html>"
  "<head><title>Unauthorized</title></head>"
  "<body><h1>401 Unauthorized</h1></body>"
  "</html>";
const char forbidden[] =
  "<html>"
  "<head><title>Forbidden</title></head>"
  "<body><h1>403 Forbidden</h1></body>"
  "</html>";
const char not_found[] =
  "<html>"
  "<head><title>Not Found</title></head>"
  "<body><h1>404 Not Found</h1></body>"
  "</html>";
const char internal_server_error[] =
  "<html>"
  "<head><title>Internal Server Error</title></head>"
  "<body><h1>500 Internal Server Error</h1></body>"
  "</html>";
const char not_implemented[] =
  "<html>"
  "<head><title>Not Implemented</title></head>"
  "<body><h1>501 Not Implemented</h1></body>"
  "</html>";
const char bad_gateway[] =
  "<html>"
  "<head><title>Bad Gateway</title></head>"
  "<body><h1>502 Bad Gateway</h1></body>"
  "</html>";
const char service_unavailable[] =
  "<html>"
  "<head><title>Service Unavailable</title></head>"
  "<body><h1>503 Service Unavailable</h1></body>"
  "</html>";

std::string to_string(reply::status_type status)
{
  switch (status)
  {
  case reply::ok:
    return ok;
  case reply::created:
    return created;
  case reply::accepted:
    return accepted;
  case reply::no_content:
    return no_content;
  case reply::multiple_choices:
    return multiple_choices;
  case reply::moved_permanently:
    return moved_permanently;
  case reply::moved_temporarily:
    return moved_temporarily;
  case reply::not_modified:
    return not_modified;
  case reply::bad_request:
    return bad_request;
  case reply::unauthorized:
    return unauthorized;
  case reply::forbidden:
    return forbidden;
  case reply::not_found:
    return not_found;
  case reply::internal_server_error:
    return internal_server_error;
  case reply::not_implemented:
    return not_implemented;
  case reply::bad_gateway:
    return bad_gateway;
  case reply::service_unavailable:
    return service_unavailable;
  default:
    return internal_server_error;
  }
}

} // namespace stock_replies

reply reply::stock_reply(reply::status_type status)
{
  reply rep;
  rep.status = status;
  rep.content = stock_replies::to_string(status);
  rep.headers.resize(2);
  rep.headers[0].name = "Content-Length";
  rep.headers[0].value = std::to_string(rep.content.size());
  rep.headers[1].name = "Content-Type";
  rep.headers[1].value = "text/html";
  return rep;
}

} // namespace server4
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server4\request_parser.cpp
//
// request_parser.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "request_parser.hpp"
#include "request.hpp"

namespace http {
namespace server4 {

request_parser::request_parser()
  : state_(method_start)
{
}

void request_parser::reset()
{
  state_ = method_start;
}

request_parser::result_type request_parser::consume(request& req, char input)
{
  switch (state_)
  {
  case method_start:
    if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      state_ = method;
      req.method.push_back(input);
      return indeterminate;
    }
  case method:
    if (input == ' ')
    {
      state_ = uri;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.method.push_back(input);
      return indeterminate;
    }
  case uri:
    if (input == ' ')
    {
      state_ = http_version_h;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.uri.push_back(input);
      return indeterminate;
    }
  case http_version_h:
    if (input == 'H')
    {
      state_ = http_version_t_1;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_1:
    if (input == 'T')
    {
      state_ = http_version_t_2;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_t_2:
    if (input == 'T')
    {
      state_ = http_version_p;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_p:
    if (input == 'P')
    {
      state_ = http_version_slash;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_slash:
    if (input == '/')
    {
      req.http_version_major = 0;
      req.http_version_minor = 0;
      state_ = http_version_major_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major_start:
    if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      state_ = http_version_major;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_major:
    if (input == '.')
    {
      state_ = http_version_minor_start;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_major = req.http_version_major * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor_start:
    if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      state_ = http_version_minor;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case http_version_minor:
    if (input == '\r')
    {
      state_ = expecting_newline_1;
      return indeterminate;
    }
    else if (is_digit(input))
    {
      req.http_version_minor = req.http_version_minor * 10 + input - '0';
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_1:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_line_start:
    if (input == '\r')
    {
      state_ = expecting_newline_3;
      return indeterminate;
    }
    else if (!req.headers.empty() && (input == ' ' || input == '\t'))
    {
      state_ = header_lws;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.push_back(header());
      req.headers.back().name.push_back(input);
      state_ = header_name;
      return indeterminate;
    }
  case header_lws:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (input == ' ' || input == '\t')
    {
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      state_ = header_value;
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case header_name:
    if (input == ':')
    {
      state_ = space_before_header_value;
      return indeterminate;
    }
    else if (!is_char(input) || is_ctl(input) || is_tspecial(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().name.push_back(input);
      return indeterminate;
    }
  case space_before_header_value:
    if (input == ' ')
    {
      state_ = header_value;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case header_value:
    if (input == '\r')
    {
      state_ = expecting_newline_2;
      return indeterminate;
    }
    else if (is_ctl(input))
    {
      return bad;
    }
    else
    {
      req.headers.back().value.push_back(input);
      return indeterminate;
    }
  case expecting_newline_2:
    if (input == '\n')
    {
      state_ = header_line_start;
      return indeterminate;
    }
    else
    {
      return bad;
    }
  case expecting_newline_3:
    return (input == '\n') ? good : bad;
  default:
    return bad;
  }
}

bool request_parser::is_char(int c)
{
  return c >= 0 && c <= 127;
}

bool request_parser::is_ctl(int c)
{
  return (c >= 0 && c <= 31) || (c == 127);
}

bool request_parser::is_tspecial(int c)
{
  switch (c)
  {
  case '(': case ')': case '<': case '>': case '@':
  case ',': case ';': case ':': case '\\': case '"':
  case '/': case '[': case ']': case '?': case '=':
  case '{': case '}': case ' ': case '\t':
    return true;
  default:
    return false;
  }
}

bool request_parser::is_digit(int c)
{
  return c >= '0' && c <= '9';
}

} // namespace server4
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\http\server4\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "server.hpp"
#include "request.hpp"
#include "reply.hpp"

namespace http {
namespace server4 {

server::server(asio::io_context& io_context,
    const std::string& address, const std::string& port,
    std::function<void(const request&, reply&)> request_handler)
  : request_handler_(request_handler)
{
  tcp::resolver resolver(io_context);
  asio::ip::tcp::endpoint endpoint =
    *resolver.resolve(address, port).begin();
  acceptor_.reset(new tcp::acceptor(io_context, endpoint));
}

// Enable the pseudo-keywords reenter, yield and fork.
#include <asio/yield.hpp>

void server::operator()(std::error_code ec, std::size_t length)
{
  // In this example we keep the error handling code in one place by
  // hoisting it outside the coroutine. An alternative approach would be to
  // check the value of ec after each yield for an asynchronous operation.
  if (!ec)
  {
    // On reentering a coroutine, control jumps to the location of the last
    // yield or fork. The argument to the "reenter" pseudo-keyword can be a
    // pointer or reference to an object of type coroutine.
    reenter (this)
    {
      // Loop to accept incoming connections.
      do
      {
        // Create a new socket for the next incoming connection.
        socket_.reset(new tcp::socket(acceptor_->get_executor()));

        // Accept a new connection. The "yield" pseudo-keyword saves the current
        // line number and exits the coroutine's "reenter" block. We use the
        // server coroutine as the completion handler for the async_accept
        // operation. When the asynchronous operation completes, the io_context
        // invokes the function call operator, we "reenter" the coroutine, and
        // then control resumes at the following line.
        yield acceptor_->async_accept(*socket_, *this);

        // We "fork" by cloning a new server coroutine to handle the connection.
        // After forking we have a parent coroutine and a child coroutine. Both
        // parent and child continue execution at the following line. They can
        // be distinguished using the functions coroutine::is_parent() and
        // coroutine::is_child().
        fork server(*this)();

        // The parent continues looping to accept the next incoming connection.
        // The child exits the loop and processes the connection.
      } while (is_parent());

      // Create the objects needed to receive a request on the connection.
      buffer_.reset(new std::array<char, 8192>);
      request_.reset(new request);

      // Loop until a complete request (or an invalid one) has been received.
      do
      {
        // Receive some more data. When control resumes at the following line,
        // the ec and length parameters reflect the result of the asynchronous
        // operation.
        yield socket_->async_read_some(asio::buffer(*buffer_), *this);

        // Parse the data we just received.
        std::tie(parse_result_, std::ignore)
          = request_parser_.parse(*request_,
              buffer_->data(), buffer_->data() + length);

        // An indeterminate result means we need more data, so keep looping.
      } while (parse_result_ == request_parser::indeterminate);

      // Create the reply object that will be sent back to the client.
      reply_.reset(new reply);

      if (parse_result_ == request_parser::good)
      {
        // A valid request was received. Call the user-supplied function object
        // to process the request and compose a reply.
        request_handler_(*request_, *reply_);
      }
      else
      {
        // The request was invalid.
        *reply_ = reply::stock_reply(reply::bad_request);
      }

      // Send the reply back to the client.
      yield asio::async_write(*socket_, reply_->to_buffers(), *this);

      // Initiate graceful connection closure.
      socket_->shutdown(tcp::socket::shutdown_both, ec);
    }
  }

  // If an error occurs then the coroutine is not reentered. Consequently, no
  // new asynchronous operations are started. This means that all shared_ptr
  // references will disappear and the resources associated with the coroutine
  // will be destroyed automatically after this function call returns.
}

// Disable the pseudo-keywords reenter, yield and fork.
#include <asio/unyield.hpp>

} // namespace server4
} // namespace http

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\icmp\ping.cpp
//
// ping.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <istream>
#include <iostream>
#include <ostream>

#include "icmp_header.hpp"
#include "ipv4_header.hpp"

using asio::ip::icmp;
using asio::steady_timer;
namespace chrono = asio::chrono;

class pinger
{
public:
  pinger(asio::io_context& io_context, const char* destination)
    : resolver_(io_context), socket_(io_context, icmp::v4()),
      timer_(io_context), sequence_number_(0), num_replies_(0)
  {
    destination_ = *resolver_.resolve(icmp::v4(), destination, "").begin();

    start_send();
    start_receive();
  }

private:
  void start_send()
  {
    std::string body("\"Hello!\" from Asio ping.");

    // Create an ICMP header for an echo request.
    icmp_header echo_request;
    echo_request.type(icmp_header::echo_request);
    echo_request.code(0);
    echo_request.identifier(get_identifier());
    echo_request.sequence_number(++sequence_number_);
    compute_checksum(echo_request, body.begin(), body.end());

    // Encode the request packet.
    asio::streambuf request_buffer;
    std::ostream os(&request_buffer);
    os << echo_request << body;

    // Send the request.
    time_sent_ = steady_timer::clock_type::now();
    socket_.send_to(request_buffer.data(), destination_);

    // Wait up to five seconds for a reply.
    num_replies_ = 0;
    timer_.expires_at(time_sent_ + chrono::seconds(5));
    timer_.async_wait(std::bind(&pinger::handle_timeout, this));
  }

  void handle_timeout()
  {
    if (num_replies_ == 0)
      std::cout << "Request timed out" << std::endl;

    // Requests must be sent no less than one second apart.
    timer_.expires_at(time_sent_ + chrono::seconds(1));
    timer_.async_wait(std::bind(&pinger::start_send, this));
  }

  void start_receive()
  {
    // Discard any data already in the buffer.
    reply_buffer_.consume(reply_buffer_.size());

    // Wait for a reply. We prepare the buffer to receive up to 64KB.
    socket_.async_receive(reply_buffer_.prepare(65536),
        std::bind(&pinger::handle_receive, this, std::placeholders::_2));
  }

  void handle_receive(std::size_t length)
  {
    // The actual number of bytes received is committed to the buffer so that we
    // can extract it using a std::istream object.
    reply_buffer_.commit(length);

    // Decode the reply packet.
    std::istream is(&reply_buffer_);
    ipv4_header ipv4_hdr;
    icmp_header icmp_hdr;
    is >> ipv4_hdr >> icmp_hdr;

    // We can receive all ICMP packets received by the host, so we need to
    // filter out only the echo replies that match the our identifier and
    // expected sequence number.
    if (is && icmp_hdr.type() == icmp_header::echo_reply
          && icmp_hdr.identifier() == get_identifier()
          && icmp_hdr.sequence_number() == sequence_number_)
    {
      // If this is the first reply, interrupt the five second timeout.
      if (num_replies_++ == 0)
        timer_.cancel();

      // Print out some information about the reply packet.
      chrono::steady_clock::time_point now = chrono::steady_clock::now();
      chrono::steady_clock::duration elapsed = now - time_sent_;
      std::cout << length - ipv4_hdr.header_length()
        << " bytes from " << ipv4_hdr.source_address()
        << ": icmp_seq=" << icmp_hdr.sequence_number()
        << ", ttl=" << ipv4_hdr.time_to_live()
        << ", time="
        << chrono::duration_cast<chrono::milliseconds>(elapsed).count()
        << std::endl;
    }

    start_receive();
  }

  static unsigned short get_identifier()
  {
#if defined(ASIO_WINDOWS)
    return static_cast<unsigned short>(::GetCurrentProcessId());
#else
    return static_cast<unsigned short>(::getpid());
#endif
  }

  icmp::resolver resolver_;
  icmp::endpoint destination_;
  icmp::socket socket_;
  steady_timer timer_;
  unsigned short sequence_number_;
  chrono::steady_clock::time_point time_sent_;
  asio::streambuf reply_buffer_;
  std::size_t num_replies_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: ping <host>" << std::endl;
#if !defined(ASIO_WINDOWS)
      std::cerr << "(You may need to run this program as root.)" << std::endl;
#endif
      return 1;
    }

    asio::io_context io_context;
    pinger p(io_context, argv[1]);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << std::endl;
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\invocation\prioritised_handlers.cpp
//
// prioritised_handlers.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio.hpp"
#include <iostream>
#include <memory>
#include <queue>

using asio::ip::tcp;

class handler_priority_queue : public asio::execution_context
{
public:
  template <typename Function>
  void add(int priority, Function function)
  {
    std::unique_ptr<queued_handler_base> handler(
        new queued_handler<Function>(
          priority, std::move(function)));

    handlers_.push(std::move(handler));
  }

  void execute_all()
  {
    while (!handlers_.empty())
    {
      handlers_.top()->execute();
      handlers_.pop();
    }
  }

  class executor
  {
  public:
    executor(handler_priority_queue& q, int p)
      : context_(q), priority_(p)
    {
    }

    handler_priority_queue& context() const noexcept
    {
      return context_;
    }

    template <typename Function, typename Allocator>
    void dispatch(Function f, const Allocator&) const
    {
      context_.add(priority_, std::move(f));
    }

    template <typename Function, typename Allocator>
    void post(Function f, const Allocator&) const
    {
      context_.add(priority_, std::move(f));
    }

    template <typename Function, typename Allocator>
    void defer(Function f, const Allocator&) const
    {
      context_.add(priority_, std::move(f));
    }

    void on_work_started() const noexcept {}
    void on_work_finished() const noexcept {}

    bool operator==(const executor& other) const noexcept
    {
      return &context_ == &other.context_ && priority_ == other.priority_;
    }

    bool operator!=(const executor& other) const noexcept
    {
      return !operator==(other);
    }

  private:
    handler_priority_queue& context_;
    int priority_;
  };

  template <typename Handler>
  asio::executor_binder<Handler, executor>
  wrap(int priority, Handler handler)
  {
    return asio::bind_executor(
        executor(*this, priority), std::move(handler));
  }

private:
  class queued_handler_base
  {
  public:
    queued_handler_base(int p)
      : priority_(p)
    {
    }

    virtual ~queued_handler_base()
    {
    }

    virtual void execute() = 0;

    friend bool operator<(const std::unique_ptr<queued_handler_base>& a,
        const std::unique_ptr<queued_handler_base>& b) noexcept
    {
      return a->priority_ < b->priority_;
    }

  private:
    int priority_;
  };

  template <typename Function>
  class queued_handler : public queued_handler_base
  {
  public:
    queued_handler(int p, Function f)
      : queued_handler_base(p), function_(std::move(f))
    {
    }

    void execute() override
    {
      function_();
    }

  private:
    Function function_;
  };

  std::priority_queue<std::unique_ptr<queued_handler_base>> handlers_;
};

//----------------------------------------------------------------------

void high_priority_handler(const std::error_code& /*ec*/,
    tcp::socket /*socket*/)
{
  std::cout << "High priority handler\n";
}

void middle_priority_handler(const std::error_code& /*ec*/)
{
  std::cout << "Middle priority handler\n";
}

struct low_priority_handler
{
  // Make the handler a move-only type.
  low_priority_handler() = default;
  low_priority_handler(const low_priority_handler&) = delete;
  low_priority_handler(low_priority_handler&&) = default;

  void operator()()
  {
    std::cout << "Low priority handler\n";
  }
};

int main()
{
  asio::io_context io_context;

  handler_priority_queue pri_queue;

  // Post a completion handler to be run immediately.
  asio::post(io_context, pri_queue.wrap(0, low_priority_handler()));

  // Start an asynchronous accept that will complete immediately.
  tcp::endpoint endpoint(asio::ip::address_v4::loopback(), 0);
  tcp::acceptor acceptor(io_context, endpoint);
  tcp::socket server_socket(io_context);
  acceptor.async_accept(pri_queue.wrap(100, high_priority_handler));
  tcp::socket client_socket(io_context);
  client_socket.connect(acceptor.local_endpoint());

  // Set a deadline timer to expire immediately.
  asio::steady_timer timer(io_context);
  timer.expires_at(asio::steady_timer::clock_type::time_point::min());
  timer.async_wait(pri_queue.wrap(42, middle_priority_handler));

  while (io_context.run_one())
  {
    // The custom invocation hook adds the handlers to the priority queue
    // rather than executing them from within the poll_one() call.
    while (io_context.poll_one())
      ;

    pri_queue.execute_all();
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\iostreams\daytime_client.cpp
//
// daytime_client.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: daytime_client <host>" << std::endl;
      return 1;
    }

    tcp::iostream s(argv[1], "daytime");
    if (!s)
    {
      std::cout << "Unable to connect: " << s.error().message() << std::endl;
      return 1;
    }

    std::string line;
    std::getline(s, line);
    std::cout << line << std::endl;
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\iostreams\daytime_server.cpp
//
// daytime_server.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <ctime>
#include <iostream>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;

std::string make_daytime_string()
{
  using namespace std; // For time_t, time and ctime;
  time_t now = time(0);
  return ctime(&now);
}

int main()
{
  try
  {
    asio::io_context io_context;

    tcp::endpoint endpoint(tcp::v4(), 13);
    tcp::acceptor acceptor(io_context, endpoint);

    for (;;)
    {
      tcp::iostream stream;
      std::error_code ec;
      acceptor.accept(stream.socket(), ec);
      if (!ec)
      {
        stream << make_daytime_string();
      }
    }
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\iostreams\http_client.cpp
//
// http_client.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <istream>
#include <ostream>
#include <string>
#include <asio/ip/tcp.hpp>

using asio::ip::tcp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cout << "Usage: http_client <server> <path>\n";
      std::cout << "Example:\n";
      std::cout << "  http_client www.boost.org /LICENSE_1_0.txt\n";
      return 1;
    }

    asio::ip::tcp::iostream s;

    // The entire sequence of I/O operations must complete within 60 seconds.
    // If an expiry occurs, the socket is automatically closed and the stream
    // becomes bad.
    s.expires_after(std::chrono::seconds(60));

    // Establish a connection to the server.
    s.connect(argv[1], "http");
    if (!s)
    {
      std::cout << "Unable to connect: " << s.error().message() << "\n";
      return 1;
    }

    // Send the request. We specify the "Connection: close" header so that the
    // server will close the socket after transmitting the response. This will
    // allow us to treat all data up until the EOF as the content.
    s << "GET " << argv[2] << " HTTP/1.0\r\n";
    s << "Host: " << argv[1] << "\r\n";
    s << "Accept: */*\r\n";
    s << "Connection: close\r\n\r\n";

    // By default, the stream is tied with itself. This means that the stream
    // automatically flush the buffered output before attempting a read. It is
    // not necessary not explicitly flush the stream at this point.

    // Check that response is OK.
    std::string http_version;
    s >> http_version;
    unsigned int status_code;
    s >> status_code;
    std::string status_message;
    std::getline(s, status_message);
    if (!s || http_version.substr(0, 5) != "HTTP/")
    {
      std::cout << "Invalid response\n";
      return 1;
    }
    if (status_code != 200)
    {
      std::cout << "Response returned with status code " << status_code << "\n";
      return 1;
    }

    // Process the response headers, which are terminated by a blank line.
    std::string header;
    while (std::getline(s, header) && header != "\r")
      std::cout << header << "\n";
    std::cout << "\n";

    // Write the remaining data to output.
    std::cout << s.rdbuf();
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\local\connect_pair.cpp
//
// connect_pair.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <iostream>
#include <string>
#include <cctype>
#include <asio.hpp>

#if defined(ASIO_HAS_LOCAL_SOCKETS)

using asio::local::stream_protocol;

class uppercase_filter
{
public:
  uppercase_filter(stream_protocol::socket sock)
    : socket_(std::move(sock))
  {
    read();
  }

private:
  void read()
  {
    socket_.async_read_some(asio::buffer(data_),
        [this](std::error_code ec, std::size_t size)
        {
          if (!ec)
          {
            // Compute result.
            for (std::size_t i = 0; i < size; ++i)
              data_[i] = std::toupper(data_[i]);

            // Send result.
            write(size);
          }
          else
          {
            throw std::system_error(ec);
          }
        });
  }

  void write(std::size_t size)
  {
    asio::async_write(socket_, asio::buffer(data_, size),
        [this](std::error_code ec, std::size_t /*size*/)
        {
          if (!ec)
          {
            // Wait for request.
            read();
          }
          else
          {
            throw std::system_error(ec);
          }
        });
  }

  stream_protocol::socket socket_;
  std::array<char, 512> data_;
};

int main()
{
  try
  {
    asio::io_context io_context;

    // Create a connected pair and pass one end to a filter.
    stream_protocol::socket socket(io_context);
    stream_protocol::socket filter_socket(io_context);
    asio::local::connect_pair(socket, filter_socket);
    uppercase_filter filter(std::move(filter_socket));

    // The io_context runs in a background thread to perform filtering.
    asio::thread thread(
        [&io_context]()
        {
          try
          {
            io_context.run();
          }
          catch (std::exception& e)
          {
            std::cerr << "Exception in thread: " << e.what() << "\n";
            std::exit(1);
          }
        });

    for (;;)
    {
      // Collect request from user.
      std::cout << "Enter a string: ";
      std::string request;
      std::getline(std::cin, request);

      // Send request to filter.
      asio::write(socket, asio::buffer(request));

      // Wait for reply from filter.
      std::vector<char> reply(request.size());
      asio::read(socket, asio::buffer(reply));

      // Show reply to user.
      std::cout << "Result: ";
      std::cout.write(&reply[0], request.size());
      std::cout << std::endl;
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
    std::exit(1);
  }
}

#else // defined(ASIO_HAS_LOCAL_SOCKETS)
# error Local sockets not available on this platform.
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\local\fd_passing_stream_client.cpp
//
// fd_passing_stream_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2021 Heiko Hund (heiko at openvpn dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Demonstrates how to pass file descriptors between processes with Asio.
// The client send a file name (destfile) to the server. The server opens
// the file and the associated file descriptor back to the client.

#include <cstdlib>
#include <cstring>
#include <iostream>
#include "asio.hpp"

#if defined(ASIO_HAS_LOCAL_SOCKETS)

#include <sys/types.h>
#include <sys/socket.h>

using asio::local::stream_protocol;

constexpr std::size_t max_length = 1024;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: fd_passing_stream_client <serversocket>\n";
      return 1;
    }

    asio::io_context io_context;

    stream_protocol::socket s(io_context);
    s.connect(stream_protocol::endpoint(argv[1]));

    std::cout << "Enter path to write to: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t request_length = std::strlen(request);
    asio::write(s, asio::buffer(request, request_length));

    char reply[max_length];
    struct msghdr msg = {};
    struct iovec iov = { reply, sizeof(reply) };
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    union
    {
      struct cmsghdr align;
      char buf[CMSG_SPACE(sizeof(int))];
    } cmsgu;
    msg.msg_control = cmsgu.buf;
    msg.msg_controllen = sizeof(cmsgu.buf);

    ::recvmsg(s.native_handle(), &msg, 0);

    int fd = -1;
    struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
    while (cmsg != NULL)
    {
      if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS)
      {
        std::memcpy(&fd, CMSG_DATA(cmsg), sizeof(fd));
        break;
      }
      cmsg = CMSG_NXTHDR(&msg, cmsg);
    }

    if (fd != -1)
    {
      std::cout << "File descriptor received is: " << fd << "\n";
      FILE* f(::fdopen(fd, "w+"));
      if (f)
      {
        ::fprintf(f, "stream_client writing to received fd #%d\n", fd);
        ::fclose(f);
      }
      else
        ::close(fd);
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

#else // defined(ASIO_HAS_LOCAL_SOCKETS)
# error Local sockets not available on this platform.
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\local\fd_passing_stream_server.cpp
//
// fd_passing_stream_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2021 Heiko Hund (heiko at openvpn dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Demonstrates how to pass file descriptors between processes with Asio.
// The client sends a file name to the server. The server opens the file and
// passes the associated file descriptor back to the client.

#include <array>
#include <cstdio>
#include <cassert>
#include <iostream>
#include <memory>
#include "asio.hpp"

#if defined(ASIO_HAS_LOCAL_SOCKETS)

using asio::local::stream_protocol;

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(stream_protocol::socket sock)
    : socket_(std::move(sock))
  {
  }

  void start()
  {
    do_read();
  }

private:
  void do_read()
  {
    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_),
        [this, self](std::error_code ec, std::size_t length)
        {
          if (ec)
            return;

          assert(length < data_.size());
          data_[length] = 0;
          do_write(data_.data());
        });
  }

  void do_write(const char* filename)
  {
    auto self(shared_from_this());
    socket_.async_wait(stream_protocol::socket::wait_write,
        [this, self, filename](std::error_code ec)
        {
          if (ec)
            return;

          FILE* f(::fopen(filename, "w+"));
          if (!f)
            return;

          struct msghdr msg = {};
          char buf[] = { 0 };
          struct iovec iov = { buf, sizeof(buf) };
          msg.msg_iov = &iov;
          msg.msg_iovlen = 1;

          union
          {
            struct cmsghdr align;
            char buf[CMSG_SPACE(sizeof(int))];
          } cmsgu;
          msg.msg_control = cmsgu.buf;
          msg.msg_controllen = sizeof(cmsgu.buf);

          struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
          cmsg->cmsg_len = CMSG_LEN(sizeof(int));
          cmsg->cmsg_level = SOL_SOCKET;
          cmsg->cmsg_type = SCM_RIGHTS;
          int fd = ::fileno(f);
          std::memcpy(CMSG_DATA(cmsg), &fd, sizeof(int));

          ssize_t s(::sendmsg(socket_.native_handle(), &msg, 0));
          ::fclose(f);
          if (s != -1)
            do_read();
        });
  }

  // The socket used to communicate with the client.
  stream_protocol::socket socket_;

  // Buffer used to store data received from the client.
  std::array<char, 1024> data_;
};

class server
{
public:
  server(asio::io_context& io_context, const std::string& file)
    : acceptor_(io_context, stream_protocol::endpoint(file))
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, stream_protocol::socket socket)
        {
          if (!ec)
          {
            std::make_shared<session>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  stream_protocol::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: fd_passing_stream_server <socketfile>\n";
      std::cerr << "*** WARNING: existing file is removed ***\n";
      return 1;
    }

    asio::io_context io_context;

    std::remove(argv[1]);
    server s(io_context, argv[1]);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

#else // defined(ASIO_HAS_LOCAL_SOCKETS)
# error Local sockets not available on this platform.
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\local\iostream_client.cpp
//
// stream_client.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstring>
#include <iostream>
#include "asio.hpp"

#if defined(ASIO_HAS_LOCAL_SOCKETS)

using asio::local::stream_protocol;

constexpr std::size_t max_length = 1024;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: iostream_client <file>\n";
      return 1;
    }

    stream_protocol::endpoint ep(argv[1]);
    stream_protocol::iostream s(ep);
    if (!s)
    {
      std::cerr << "Unable to connect: " << s.error().message() << std::endl;
      return 1;
    }

    std::cout << "Enter message: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t length = std::strlen(request);
    s << request;

    char reply[max_length];
    s.read(reply, length);
    std::cout << "Reply is: ";
    std::cout.write(reply, length);
    std::cout << "\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

#else // defined(ASIO_HAS_LOCAL_SOCKETS)
# error Local sockets not available on this platform.
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\local\stream_client.cpp
//
// stream_client.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <cstring>
#include <iostream>
#include "asio.hpp"

#if defined(ASIO_HAS_LOCAL_SOCKETS)

using asio::local::stream_protocol;

constexpr std::size_t max_length = 1024;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: stream_client <file>\n";
      return 1;
    }

    asio::io_context io_context;

    stream_protocol::socket s(io_context);
    s.connect(stream_protocol::endpoint(argv[1]));

    std::cout << "Enter message: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t request_length = std::strlen(request);
    asio::write(s, asio::buffer(request, request_length));

    char reply[max_length];
    size_t reply_length = asio::read(s,
        asio::buffer(reply, request_length));
    std::cout << "Reply is: ";
    std::cout.write(reply, reply_length);
    std::cout << "\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

#else // defined(ASIO_HAS_LOCAL_SOCKETS)
# error Local sockets not available on this platform.
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\local\stream_server.cpp
//
// stream_server.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <cstdio>
#include <iostream>
#include <memory>
#include "asio.hpp"

#if defined(ASIO_HAS_LOCAL_SOCKETS)

using asio::local::stream_protocol;

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(stream_protocol::socket sock)
    : socket_(std::move(sock))
  {
  }

  void start()
  {
    do_read();
  }

private:
  void do_read()
  {
    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_),
        [this, self](std::error_code ec, std::size_t length)
        {
          if (!ec)
            do_write(length);
        });
  }

  void do_write(std::size_t length)
  {
    auto self(shared_from_this());
    asio::async_write(socket_,
        asio::buffer(data_, length),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
            do_read();
        });
  }

  // The socket used to communicate with the client.
  stream_protocol::socket socket_;

  // Buffer used to store data received from the client.
  std::array<char, 1024> data_;
};

class server
{
public:
  server(asio::io_context& io_context, const std::string& file)
    : acceptor_(io_context, stream_protocol::endpoint(file))
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, stream_protocol::socket socket)
        {
          if (!ec)
          {
            std::make_shared<session>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  stream_protocol::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: stream_server <file>\n";
      std::cerr << "*** WARNING: existing file is removed ***\n";
      return 1;
    }

    asio::io_context io_context;

    std::remove(argv[1]);
    server s(io_context, argv[1]);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

#else // defined(ASIO_HAS_LOCAL_SOCKETS)
# error Local sockets not available on this platform.
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\multicast\receiver.cpp
//
// receiver.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <iostream>
#include <string>
#include "asio.hpp"

constexpr short multicast_port = 30001;

class receiver
{
public:
  receiver(asio::io_context& io_context,
      const asio::ip::address& listen_address,
      const asio::ip::address& multicast_address)
    : socket_(io_context)
  {
    // Create the socket so that multiple may be bound to the same address.
    asio::ip::udp::endpoint listen_endpoint(
        listen_address, multicast_port);
    socket_.open(listen_endpoint.protocol());
    socket_.set_option(asio::ip::udp::socket::reuse_address(true));
    socket_.bind(listen_endpoint);

    // Join the multicast group.
    socket_.set_option(
        asio::ip::multicast::join_group(multicast_address));

    do_receive();
  }

private:
  void do_receive()
  {
    socket_.async_receive_from(
        asio::buffer(data_), sender_endpoint_,
        [this](std::error_code ec, std::size_t length)
        {
          if (!ec)
          {
            std::cout.write(data_.data(), length);
            std::cout << std::endl;

            do_receive();
          }
        });
  }

  asio::ip::udp::socket socket_;
  asio::ip::udp::endpoint sender_endpoint_;
  std::array<char, 1024> data_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: receiver <listen_address> <multicast_address>\n";
      std::cerr << "  For IPv4, try:\n";
      std::cerr << "    receiver 0.0.0.0 239.255.0.1\n";
      std::cerr << "  For IPv6, try:\n";
      std::cerr << "    receiver 0::0 ff31::8000:1234\n";
      return 1;
    }

    asio::io_context io_context;
    receiver r(io_context,
        asio::ip::make_address(argv[1]),
        asio::ip::make_address(argv[2]));
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\multicast\sender.cpp
//
// sender.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <sstream>
#include <string>
#include "asio.hpp"

constexpr short multicast_port = 30001;
constexpr int max_message_count = 10;

class sender
{
public:
  sender(asio::io_context& io_context,
      const asio::ip::address& multicast_address)
    : endpoint_(multicast_address, multicast_port),
      socket_(io_context, endpoint_.protocol()),
      timer_(io_context),
      message_count_(0)
  {
    do_send();
  }

private:
  void do_send()
  {
    std::ostringstream os;
    os << "Message " << message_count_++;
    message_ = os.str();

    socket_.async_send_to(
        asio::buffer(message_), endpoint_,
        [this](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec && message_count_ < max_message_count)
            do_timeout();
        });
  }

  void do_timeout()
  {
    timer_.expires_after(std::chrono::seconds(1));
    timer_.async_wait(
        [this](std::error_code ec)
        {
          if (!ec)
            do_send();
        });
  }

private:
  asio::ip::udp::endpoint endpoint_;
  asio::ip::udp::socket socket_;
  asio::steady_timer timer_;
  int message_count_;
  std::string message_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: sender <multicast_address>\n";
      std::cerr << "  For IPv4, try:\n";
      std::cerr << "    sender 239.255.0.1\n";
      std::cerr << "  For IPv6, try:\n";
      std::cerr << "    sender ff31::8000:1234\n";
      return 1;
    }

    asio::io_context io_context;
    sender s(io_context, asio::ip::make_address(argv[1]));
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\nonblocking\third_party_lib.cpp
//
// third_party_lib.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <array>
#include <iostream>
#include <memory>

using asio::ip::tcp;

namespace third_party_lib {

// Simulation of a third party library that wants to perform read and write
// operations directly on a socket. It needs to be polled to determine whether
// it requires a read or write operation, and notified when the socket is ready
// for reading or writing.
class session
{
public:
  session(tcp::socket& socket)
    : socket_(socket)
  {
  }

  // Returns true if the third party library wants to be notified when the
  // socket is ready for reading.
  bool want_read() const
  {
    return state_ == reading;
  }

  // Notify that third party library that it should perform its read operation.
  void do_read(std::error_code& ec)
  {
    if (std::size_t len = socket_.read_some(asio::buffer(data_), ec))
    {
      write_buffer_ = asio::buffer(data_, len);
      state_ = writing;
    }
  }

  // Returns true if the third party library wants to be notified when the
  // socket is ready for writing.
  bool want_write() const
  {
    return state_ == writing;
  }

  // Notify that third party library that it should perform its write operation.
  void do_write(std::error_code& ec)
  {
    if (std::size_t len = socket_.write_some(
          asio::buffer(write_buffer_), ec))
    {
      write_buffer_ = write_buffer_ + len;
      state_ = asio::buffer_size(write_buffer_) > 0 ? writing : reading;
    }
  }

private:
  tcp::socket& socket_;
  enum { reading, writing } state_ = reading;
  std::array<char, 128> data_;
  asio::const_buffer write_buffer_;
};

} // namespace third_party_lib

// The glue between asio's sockets and the third party library.
class connection
  : public std::enable_shared_from_this<connection>
{
public:
  connection(tcp::socket socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    // Put the socket into non-blocking mode.
    socket_.non_blocking(true);

    do_operations();
  }

private:
  void do_operations()
  {
    auto self(shared_from_this());

    // Start a read operation if the third party library wants one.
    if (session_impl_.want_read() && !read_in_progress_)
    {
      read_in_progress_ = true;
      socket_.async_wait(tcp::socket::wait_read,
          [this, self](std::error_code ec)
          {
            read_in_progress_ = false;

            // Notify third party library that it can perform a read.
            if (!ec)
              session_impl_.do_read(ec);

            // The third party library successfully performed a read on the
            // socket. Start new read or write operations based on what it now
            // wants.
            if (!ec || ec == asio::error::would_block)
              do_operations();

            // Otherwise, an error occurred. Closing the socket cancels any
            // outstanding asynchronous read or write operations. The
            // connection object will be destroyed automatically once those
            // outstanding operations complete.
            else
              socket_.close();
          });
    }

    // Start a write operation if the third party library wants one.
    if (session_impl_.want_write() && !write_in_progress_)
    {
      write_in_progress_ = true;
      socket_.async_wait(tcp::socket::wait_write,
          [this, self](std::error_code ec)
          {
            write_in_progress_ = false;

            // Notify third party library that it can perform a write.
            if (!ec)
              session_impl_.do_write(ec);

            // The third party library successfully performed a write on the
            // socket. Start new read or write operations based on what it now
            // wants.
            if (!ec || ec == asio::error::would_block)
              do_operations();

            // Otherwise, an error occurred. Closing the socket cancels any
            // outstanding asynchronous read or write operations. The
            // connection object will be destroyed automatically once those
            // outstanding operations complete.
            else
              socket_.close();
          });
    }
  }

private:
  tcp::socket socket_;
  third_party_lib::session session_impl_{socket_};
  bool read_in_progress_ = false;
  bool write_in_progress_ = false;
};

class server
{
public:
  server(asio::io_context& io_context, unsigned short port)
    : acceptor_(io_context, {tcp::v4(), port})
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(
        [this](std::error_code ec, tcp::socket socket)
        {
          if (!ec)
          {
            std::make_shared<connection>(std::move(socket))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: third_party_lib <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_1.cpp
//
// composed_1.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

//------------------------------------------------------------------------------

// This is the simplest example of a composed asynchronous operation, where we
// simply repackage an existing operation. The asynchronous operation
// requirements are met by delegating responsibility to the underlying
// operation.

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is void.
  // However, when the completion token is asio::yield_context (used for
  // stackful coroutines) the return type would be std::size_t, and when the
  // completion token is asio::use_future it would be std::future<std::size_t>.
  // When the completion token is asio::deferred, the return type differs for
  // each asynchronous operation.
  //
  // In this example we are trivially delegating to an underlying asynchronous
  // operation, so we can deduce the return type from that.
  -> decltype(
      asio::async_write(socket,
        asio::buffer(message, std::strlen(message)),
        std::forward<CompletionToken>(token)))
{
  // When delegating to the underlying operation we must take care to perfectly
  // forward the completion token. This ensures that our operation works
  // correctly with move-only function objects as callbacks, as well as other
  // completion token types.
  return asio::async_write(socket,
      asio::buffer(message, std::strlen(message)),
      std::forward<CompletionToken>(token));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n",
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      "Testing deferred\r\n", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::size_t> f = async_write_message(
      socket, "Testing future\r\n", asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    std::size_t n = f.get();
    std::cout << n << " bytes transferred\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_2.cpp
//
// composed_2.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This next simplest example of a composed asynchronous operation involves
// repackaging multiple operations but choosing to invoke just one of them. All
// of these underlying operations have the same completion signature. The
// asynchronous operation requirements are met by delegating responsibility to
// the underlying operations.

// In addition to determining the mechanism by which an asynchronous operation
// delivers its result, a completion token also determines the time when the
// operation commences. For example, when the completion token is a simple
// callback the operation commences before the initiating function returns.
// However, if the completion token's delivery mechanism uses a future, we
// might instead want to defer initiation of the operation until the returned
// future object is waited upon.
//
// To enable this, when implementing an asynchronous operation we must package
// the initiation step as a function object.
struct async_write_message_initiation
{
  // The initiation function object's call operator is passed the concrete
  // completion handler produced by the completion token. This completion
  // handler matches the asynchronous operation's completion handler signature,
  // which in this example is:
  //
  //   void(std::error_code error, std::size_t)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments as members in the initiaton function object. However, we should
  // prefer to propagate them as function call arguments as this allows the
  // completion token to optimise how they are passed. For example, a lazy
  // future which defers initiation would need to make a decay-copy of the
  // arguments, but when using a simple callback the arguments can be trivially
  // forwarded straight through.)
  template <typename CompletionHandler>
  void operator()(CompletionHandler&& completion_handler, tcp::socket& socket,
      const char* message, bool allow_partial_write) const
  {
    if (allow_partial_write)
    {
      // When delegating to an underlying operation we must take care to
      // perfectly forward the completion handler. This ensures that our
      // operation works correctly with move-only function objects as
      // callbacks.
      return socket.async_write_some(
          asio::buffer(message, std::strlen(message)),
          std::forward<CompletionHandler>(completion_handler));
    }
    else
    {
      // As above, we must perfectly forward the completion handler when calling
      // the alternate underlying operation.
      return asio::async_write(socket,
          asio::buffer(message, std::strlen(message)),
          std::forward<CompletionHandler>(completion_handler));
    }
  }
};

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, bool allow_partial_write,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is void.
  // However, when the completion token is asio::yield_context (used for
  // stackful coroutines) the return type would be std::size_t, and when the
  // completion token is asio::use_future it would be std::future<std::size_t>.
  // When the completion token is asio::deferred, the return type differs for
  // each asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_initiate.
  -> decltype(
      asio::async_initiate<
        CompletionToken, void(std::error_code, std::size_t)>(
          async_write_message_initiation(),
          token, std::ref(socket), message, allow_partial_write))
{
  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code, std::size_t)>(
      async_write_message_initiation(),
      token, std::ref(socket), message, allow_partial_write);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n", false,
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      "Testing deferred\r\n", false, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::size_t> f = async_write_message(
      socket, "Testing future\r\n", false, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    std::size_t n = f.get();
    std::cout << n << " bytes transferred\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_3.cpp
//
// composed_3.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/bind_executor.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// In this composed operation we repackage an existing operation, but with a
// different completion handler signature. The asynchronous operation
// requirements are met by delegating responsibility to the underlying
// operation.

// In addition to determining the mechanism by which an asynchronous operation
// delivers its result, a completion token also determines the time when the
// operation commences. For example, when the completion token is a simple
// callback the operation commences before the initiating function returns.
// However, if the completion token's delivery mechanism uses a future, we
// might instead want to defer initiation of the operation until the returned
// future object is waited upon.
//
// To enable this, when implementing an asynchronous operation we must package
// the initiation step as a function object.
struct async_write_message_initiation
{
  // The initiation function object's call operator is passed the concrete
  // completion handler produced by the completion token. This completion
  // handler matches the asynchronous operation's completion handler signature,
  // which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments as members in the initiaton function object. However, we should
  // prefer to propagate them as function call arguments as this allows the
  // completion token to optimise how they are passed. For example, a lazy
  // future which defers initiation would need to make a decay-copy of the
  // arguments, but when using a simple callback the arguments can be trivially
  // forwarded straight through.)
  template <typename CompletionHandler>
  void operator()(CompletionHandler&& completion_handler,
      tcp::socket& socket, const char* message) const
  {
    // The async_write operation has a completion handler signature of:
    //
    //   void(std::error_code error, std::size n)
    //
    // This differs from our operation's signature in that it is also passed
    // the number of bytes transferred as an argument of type std::size_t. We
    // will adapt our completion handler to async_write's completion handler
    // signature by using std::bind, which drops the additional argument.
    //
    // However, it is essential to the correctness of our composed operation
    // that we preserve the executor of the user-supplied completion handler.
    // The std::bind function will not do this for us, so we must do this by
    // first obtaining the completion handler's associated executor (defaulting
    // to the I/O executor - in this case the executor of the socket - if the
    // completion handler does not have its own) ...
    auto executor = asio::get_associated_executor(
        completion_handler, socket.get_executor());

    // ... and then binding this executor to our adapted completion handler
    // using the asio::bind_executor function.
    asio::async_write(socket,
        asio::buffer(message, std::strlen(message)),
        asio::bind_executor(executor,
          std::bind(std::forward<CompletionHandler>(
            completion_handler), std::placeholders::_1)));
  }
};

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_initiate.
  -> decltype(
      asio::async_initiate<
        CompletionToken, void(std::error_code)>(
          async_write_message_initiation(),
          token, std::ref(socket), message))
{
  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      async_write_message_initiation(),
      token, std::ref(socket), message);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n",
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      "Testing deferred\r\n", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, "Testing future\r\n", asio::use_future);

  io_context.run();

  // Get the result of the operation.
  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_4.cpp
//
// composed_4.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/bind_executor.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// In this composed operation we repackage an existing operation, but with a
// different completion handler signature. We will also intercept an empty
// message as an invalid argument, and propagate the corresponding error to the
// user. The asynchronous operation requirements are met by delegating
// responsibility to the underlying operation.

// In addition to determining the mechanism by which an asynchronous operation
// delivers its result, a completion token also determines the time when the
// operation commences. For example, when the completion token is a simple
// callback the operation commences before the initiating function returns.
// However, if the completion token's delivery mechanism uses a future, we
// might instead want to defer initiation of the operation until the returned
// future object is waited upon.
//
// To enable this, when implementing an asynchronous operation we must package
// the initiation step as a function object.
struct async_write_message_initiation
{
  // The initiation function object's call operator is passed the concrete
  // completion handler produced by the completion token. This completion
  // handler matches the asynchronous operation's completion handler signature,
  // which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments as members in the initiaton function object. However, we should
  // prefer to propagate them as function call arguments as this allows the
  // completion token to optimise how they are passed. For example, a lazy
  // future which defers initiation would need to make a decay-copy of the
  // arguments, but when using a simple callback the arguments can be trivially
  // forwarded straight through.)
  template <typename CompletionHandler>
  void operator()(CompletionHandler&& completion_handler,
      tcp::socket& socket, const char* message) const
  {
    // The post operation has a completion handler signature of:
    //
    //   void()
    //
    // and the async_write operation has a completion handler signature of:
    //
    //   void(std::error_code error, std::size n)
    //
    // Both of these operations' completion handler signatures differ from our
    // operation's completion handler signature. We will adapt our completion
    // handler to these signatures by using std::bind, which drops the
    // additional arguments.
    //
    // However, it is essential to the correctness of our composed operation
    // that we preserve the executor of the user-supplied completion handler.
    // The std::bind function will not do this for us, so we must do this by
    // first obtaining the completion handler's associated executor (defaulting
    // to the I/O executor - in this case the executor of the socket - if the
    // completion handler does not have its own) ...
    auto executor = asio::get_associated_executor(
        completion_handler, socket.get_executor());

    // ... and then binding this executor to our adapted completion handler
    // using the asio::bind_executor function.
    std::size_t length = std::strlen(message);
    if (length == 0)
    {
      asio::post(
          asio::bind_executor(executor,
            std::bind(std::forward<CompletionHandler>(completion_handler),
              asio::error::invalid_argument)));
    }
    else
    {
      asio::async_write(socket,
          asio::buffer(message, length),
          asio::bind_executor(executor,
            std::bind(std::forward<CompletionHandler>(completion_handler),
              std::placeholders::_1)));
    }
  }
};

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_initiate.
  -> decltype(
      asio::async_initiate<
        CompletionToken, void(std::error_code)>(
          async_write_message_initiation(),
          token, std::ref(socket), message))
{
  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      async_write_message_initiation(),
      token, std::ref(socket), message);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "",
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket, "", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, "", asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_5.cpp
//
// composed_5.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation automatically serialises a message, using its I/O
// streams insertion operator, before sending it on the socket. To do this, it
// must allocate a buffer for the encoded message and ensure this buffer's
// validity until the underlying async_write operation completes.

// In addition to determining the mechanism by which an asynchronous operation
// delivers its result, a completion token also determines the time when the
// operation commences. For example, when the completion token is a simple
// callback the operation commences before the initiating function returns.
// However, if the completion token's delivery mechanism uses a future, we
// might instead want to defer initiation of the operation until the returned
// future object is waited upon.
//
// To enable this, when implementing an asynchronous operation we must package
// the initiation step as a function object.
struct async_write_message_initiation
{
  // The initiation function object's call operator is passed the concrete
  // completion handler produced by the completion token. This completion
  // handler matches the asynchronous operation's completion handler signature,
  // which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments as members in the initiaton function object. However, we should
  // prefer to propagate them as function call arguments as this allows the
  // completion token to optimise how they are passed. For example, a lazy
  // future which defers initiation would need to make a decay-copy of the
  // arguments, but when using a simple callback the arguments can be trivially
  // forwarded straight through.)
  template <typename CompletionHandler>
  void operator()(CompletionHandler&& completion_handler,
      tcp::socket& socket, std::unique_ptr<std::string> encoded_message) const
  {
    // In this example, the composed operation's intermediate completion
    // handler is implemented as a hand-crafted function object, rather than
    // using a lambda or std::bind.
    struct intermediate_completion_handler
    {
      // The intermediate completion handler holds a reference to the socket so
      // that it can obtain the I/O executor (see get_executor below).
      tcp::socket& socket_;

      // The allocated buffer for the encoded message. The std::unique_ptr
      // smart pointer is move-only, and as a consequence our intermediate
      // completion handler is also move-only.
      std::unique_ptr<std::string> encoded_message_;

      // The user-supplied completion handler.
      typename std::decay<CompletionHandler>::type handler_;

      // The function call operator matches the completion signature of the
      // async_write operation.
      void operator()(const std::error_code& error, std::size_t /*n*/)
      {
        // Deallocate the encoded message before calling the user-supplied
        // completion handler.
        encoded_message_.reset();

        // Call the user-supplied handler with the result of the operation.
        // The arguments must match the completion signature of our composed
        // operation.
        handler_(error);
      }

      // It is essential to the correctness of our composed operation that we
      // preserve the executor of the user-supplied completion handler. With a
      // hand-crafted function object we can do this by defining a nested type
      // executor_type and member function get_executor. These obtain the
      // completion handler's associated executor, and default to the I/O
      // executor - in this case the executor of the socket - if the completion
      // handler does not have its own.
      using executor_type = asio::associated_executor_t<
          typename std::decay<CompletionHandler>::type,
          tcp::socket::executor_type>;

      executor_type get_executor() const noexcept
      {
        return asio::get_associated_executor(
            handler_, socket_.get_executor());
      }

      // Although not necessary for correctness, we may also preserve the
      // allocator of the user-supplied completion handler. This is achieved by
      // defining a nested type allocator_type and member function
      // get_allocator. These obtain the completion handler's associated
      // allocator, and default to std::allocator<void> if the completion
      // handler does not have its own.
      using allocator_type = asio::associated_allocator_t<
          typename std::decay<CompletionHandler>::type,
          std::allocator<void>>;

      allocator_type get_allocator() const noexcept
      {
        return asio::get_associated_allocator(
            handler_, std::allocator<void>{});
      }
    };

    // Initiate the underlying async_write operation using our intermediate
    // completion handler.
    auto encoded_message_buffer = asio::buffer(*encoded_message);
    asio::async_write(socket, encoded_message_buffer,
        intermediate_completion_handler{socket, std::move(encoded_message),
          std::forward<CompletionHandler>(completion_handler)});
  }
};

template <typename T, typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const T& message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_initiate.
  -> decltype(
      asio::async_initiate<
        CompletionToken, void(std::error_code)>(
          async_write_message_initiation(), token,
          std::ref(socket), std::declval<std::unique_ptr<std::string>>()))
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      async_write_message_initiation(), token,
      std::ref(socket), std::move(encoded_message));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, 123456,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      std::string("abcdef"), asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, 654.321, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_6.cpp
//
// composed_6.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/executor_work_guard.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations.
// It automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

// In addition to determining the mechanism by which an asynchronous operation
// delivers its result, a completion token also determines the time when the
// operation commences. For example, when the completion token is a simple
// callback the operation commences before the initiating function returns.
// However, if the completion token's delivery mechanism uses a future, we
// might instead want to defer initiation of the operation until the returned
// future object is waited upon.
//
// To enable this, when implementing an asynchronous operation we must package
// the initiation step as a function object.
struct async_write_message_initiation
{
  // The initiation function object's call operator is passed the concrete
  // completion handler produced by the completion token. This completion
  // handler matches the asynchronous operation's completion handler signature,
  // which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments as members in the initiaton function object. However, we should
  // prefer to propagate them as function call arguments as this allows the
  // completion token to optimise how they are passed. For example, a lazy
  // future which defers initiation would need to make a decay-copy of the
  // arguments, but when using a simple callback the arguments can be trivially
  // forwarded straight through.)
  template <typename CompletionHandler>
  void operator()(CompletionHandler&& completion_handler, tcp::socket& socket,
      std::unique_ptr<std::string> encoded_message, std::size_t repeat_count,
      std::unique_ptr<asio::steady_timer> delay_timer) const
  {
    // In this example, the composed operation's intermediate completion
    // handler is implemented as a hand-crafted function object.
    struct intermediate_completion_handler
    {
      // The intermediate completion handler holds a reference to the socket as
      // it is used for multiple async_write operations, as well as for
      // obtaining the I/O executor (see get_executor below).
      tcp::socket& socket_;

      // The allocated buffer for the encoded message. The std::unique_ptr
      // smart pointer is move-only, and as a consequence our intermediate
      // completion handler is also move-only.
      std::unique_ptr<std::string> encoded_message_;

      // The repeat count remaining.
      std::size_t repeat_count_;

      // A steady timer used for introducing a delay.
      std::unique_ptr<asio::steady_timer> delay_timer_;

      // To manage the cycle between the multiple underlying asychronous
      // operations, our intermediate completion handler is implemented as a
      // state machine.
      enum { starting, waiting, writing } state_;

      // As our composed operation performs multiple underlying I/O operations,
      // we should maintain a work object against the I/O executor. This tells
      // the I/O executor that there is still more work to come in the future.
      asio::executor_work_guard<tcp::socket::executor_type> io_work_;

      // The user-supplied completion handler, called once only on completion
      // of the entire composed operation.
      typename std::decay<CompletionHandler>::type handler_;

      // By having a default value for the second argument, this function call
      // operator matches the completion signature of both the async_write and
      // steady_timer::async_wait operations.
      void operator()(const std::error_code& error, std::size_t = 0)
      {
        if (!error)
        {
          switch (state_)
          {
          case starting:
          case writing:
            if (repeat_count_ > 0)
            {
              --repeat_count_;
              state_ = waiting;
              delay_timer_->expires_after(std::chrono::seconds(1));
              delay_timer_->async_wait(std::move(*this));
              return; // Composed operation not yet complete.
            }
            break; // Composed operation complete, continue below.
          case waiting:
            state_ = writing;
            asio::async_write(socket_,
                asio::buffer(*encoded_message_), std::move(*this));
            return; // Composed operation not yet complete.
          }
        }

        // This point is reached only on completion of the entire composed
        // operation.

        // We no longer have any future work coming for the I/O executor.
        io_work_.reset();

        // Deallocate the encoded message before calling the user-supplied
        // completion handler.
        encoded_message_.reset();

        // Call the user-supplied handler with the result of the operation.
        handler_(error);
      }

      // It is essential to the correctness of our composed operation that we
      // preserve the executor of the user-supplied completion handler. With a
      // hand-crafted function object we can do this by defining a nested type
      // executor_type and member function get_executor. These obtain the
      // completion handler's associated executor, and default to the I/O
      // executor - in this case the executor of the socket - if the completion
      // handler does not have its own.
      using executor_type = asio::associated_executor_t<
          typename std::decay<CompletionHandler>::type,
          tcp::socket::executor_type>;

      executor_type get_executor() const noexcept
      {
        return asio::get_associated_executor(
            handler_, socket_.get_executor());
      }

      // Although not necessary for correctness, we may also preserve the
      // allocator of the user-supplied completion handler. This is achieved by
      // defining a nested type allocator_type and member function
      // get_allocator. These obtain the completion handler's associated
      // allocator, and default to std::allocator<void> if the completion
      // handler does not have its own.
      using allocator_type = asio::associated_allocator_t<
          typename std::decay<CompletionHandler>::type,
          std::allocator<void>>;

      allocator_type get_allocator() const noexcept
      {
        return asio::get_associated_allocator(
            handler_, std::allocator<void>{});
      }
    };

    // Initiate the underlying async_write operation using our intermediate
    // completion handler.
    auto encoded_message_buffer = asio::buffer(*encoded_message);
    asio::async_write(socket, encoded_message_buffer,
        intermediate_completion_handler{
          socket, std::move(encoded_message),
          repeat_count, std::move(delay_timer),
          intermediate_completion_handler::starting,
          asio::make_work_guard(socket.get_executor()),
          std::forward<CompletionHandler>(completion_handler)});
  }
};

template <typename T, typename CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_initiate.
  -> decltype(
      asio::async_initiate<
        CompletionToken, void(std::error_code)>(
          async_write_message_initiation(), token, std::ref(socket),
          std::declval<std::unique_ptr<std::string>>(), repeat_count,
          std::declval<std::unique_ptr<asio::steady_timer>>()))
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      async_write_message_initiation(), token, std::ref(socket),
      std::move(encoded_message), repeat_count, std::move(delay_timer));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_messages(socket,
      "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_7.cpp
//
// composed_7.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/compose.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_compose function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations.
// It automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

// In this example, the composed operation's logic is implemented as a state
// machine within a hand-crafted function object.
struct async_write_messages_implementation
{
  // The implementation holds a reference to the socket as it is used for
  // multiple async_write operations.
  tcp::socket& socket_;

  // The allocated buffer for the encoded message. The std::unique_ptr smart
  // pointer is move-only, and as a consequence our implementation is also
  // move-only.
  std::unique_ptr<std::string> encoded_message_;

  // The repeat count remaining.
  std::size_t repeat_count_;

  // A steady timer used for introducing a delay.
  std::unique_ptr<asio::steady_timer> delay_timer_;

  // To manage the cycle between the multiple underlying asychronous
  // operations, our implementation is a state machine.
  enum { starting, waiting, writing } state_;

  // The first argument to our function object's call operator is a reference
  // to the enclosing intermediate completion handler. This intermediate
  // completion handler is provided for us by the asio::async_compose
  // function, and takes care of all the details required to implement a
  // conforming asynchronous operation. When calling an underlying asynchronous
  // operation, we pass it this enclosing intermediate completion handler
  // as the completion token.
  //
  // All arguments after the first must be defaulted to allow the state machine
  // to be started, as well as to allow the completion handler to match the
  // completion signature of both the async_write and steady_timer::async_wait
  // operations.
  template <typename Self>
  void operator()(Self& self,
      const std::error_code& error = std::error_code(),
      std::size_t = 0)
  {
    if (!error)
    {
      switch (state_)
      {
      case starting:
      case writing:
        if (repeat_count_ > 0)
        {
          --repeat_count_;
          state_ = waiting;
          delay_timer_->expires_after(std::chrono::seconds(1));
          delay_timer_->async_wait(std::move(self));
          return; // Composed operation not yet complete.
        }
        break; // Composed operation complete, continue below.
      case waiting:
        state_ = writing;
        asio::async_write(socket_,
            asio::buffer(*encoded_message_), std::move(self));
        return; // Composed operation not yet complete.
      }
    }

    // This point is reached only on completion of the entire composed
    // operation.

    // Deallocate the encoded message and delay timer before calling the
    // user-supplied completion handler.
    encoded_message_.reset();
    delay_timer_.reset();

    // Call the user-supplied handler with the result of the operation.
    self.complete(error);
  }
};

template <typename T, typename CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_compose.
  -> decltype(
      asio::async_compose<
        CompletionToken, void(std::error_code)>(
          std::declval<async_write_messages_implementation>(),
          token, socket))
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_compose function takes:
  //
  // - our asynchronous operation implementation,
  // - the completion token,
  // - the completion handler signature, and
  // - any I/O objects (or executors) used by the operation
  //
  // It then wraps our implementation in an intermediate completion handler
  // that meets the requirements of a conforming asynchronous operation. This
  // includes tracking outstanding work against the I/O executors associated
  // with the operation (in this example, this is the socket's executor).
  return asio::async_compose<
    CompletionToken, void(std::error_code)>(
      async_write_messages_implementation{
        socket, std::move(encoded_message),
        repeat_count, std::move(delay_timer),
        async_write_messages_implementation::starting},
      token, socket);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_messages(socket,
      "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\operations\composed_8.cpp
//
// composed_8.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/compose.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_compose function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations,
// using asio's stackless coroutines support to express the flow of control. It
// automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

#include <asio/yield.hpp>

// In this example, the composed operation's logic is implemented as a state
// machine within a hand-crafted function object.
struct async_write_messages_implementation
{
  // The implementation holds a reference to the socket as it is used for
  // multiple async_write operations.
  tcp::socket& socket_;

  // The allocated buffer for the encoded message. The std::unique_ptr smart
  // pointer is move-only, and as a consequence our implementation is also
  // move-only.
  std::unique_ptr<std::string> encoded_message_;

  // The repeat count remaining.
  std::size_t repeat_count_;

  // A steady timer used for introducing a delay.
  std::unique_ptr<asio::steady_timer> delay_timer_;

  // The coroutine state.
  asio::coroutine coro_;

  // The first argument to our function object's call operator is a reference
  // to the enclosing intermediate completion handler. This intermediate
  // completion handler is provided for us by the asio::async_compose
  // function, and takes care of all the details required to implement a
  // conforming asynchronous operation. When calling an underlying asynchronous
  // operation, we pass it this enclosing intermediate completion handler
  // as the completion token.
  //
  // All arguments after the first must be defaulted to allow the state machine
  // to be started, as well as to allow the completion handler to match the
  // completion signature of both the async_write and steady_timer::async_wait
  // operations.
  template <typename Self>
  void operator()(Self& self,
      const std::error_code& error = std::error_code(),
      std::size_t = 0)
  {
    reenter (coro_)
    {
      while (repeat_count_ > 0)
      {
        --repeat_count_;

        delay_timer_->expires_after(std::chrono::seconds(1));
        yield delay_timer_->async_wait(std::move(self));
        if (error)
          break;

        yield asio::async_write(socket_,
            asio::buffer(*encoded_message_), std::move(self));
        if (error)
          break;
      }

      // Deallocate the encoded message and delay timer before calling the
      // user-supplied completion handler.
      encoded_message_.reset();
      delay_timer_.reset();

      // Call the user-supplied handler with the result of the operation.
      self.complete(error);
    }
  }
};

#include <asio/unyield.hpp>

template <typename T, typename CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++11 we deduce the type from the call to asio::async_compose.
  -> decltype(
      asio::async_compose<
        CompletionToken, void(std::error_code)>(
          std::declval<async_write_messages_implementation>(),
          token, socket))
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_compose function takes:
  //
  // - our asynchronous operation implementation,
  // - the completion token,
  // - the completion handler signature, and
  // - any I/O objects (or executors) used by the operation
  //
  // It then wraps our implementation in an intermediate completion handler
  // that meets the requirements of a conforming asynchronous operation. This
  // includes tracking outstanding work against the I/O executors associated
  // with the operation (in this example, this is the socket's executor).
  return asio::async_compose<
    CompletionToken, void(std::error_code)>(
      async_write_messages_implementation{socket,
        std::move(encoded_message), repeat_count,
        std::move(delay_timer), asio::coroutine()},
      token, socket);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation and its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_messages(socket,
      "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\parallel_group\ranged_wait_for_all.cpp
//
// ranged_wait_for_all.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>
#include <vector>

#ifdef ASIO_HAS_POSIX_STREAM_DESCRIPTOR

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor out(ctx, ::dup(STDOUT_FILENO));
  asio::posix::stream_descriptor err(ctx, ::dup(STDERR_FILENO));

  using op_type = decltype(
      out.async_write_some(
        asio::buffer("", 0),
        asio::deferred
      )
    );

  std::vector<op_type> ops;

  ops.push_back(
      out.async_write_some(
        asio::buffer("first\r\n", 7),
        asio::deferred
      )
    );

  ops.push_back(
      err.async_write_some(
        asio::buffer("second\r\n", 8),
        asio::deferred
      )
    );

  asio::experimental::make_parallel_group(ops).async_wait(
      asio::experimental::wait_for_all(),
      [](
          std::vector<std::size_t> completion_order,
          std::vector<std::error_code> ec,
          std::vector<std::size_t> n
      )
      {
        for (std::size_t i = 0; i < completion_order.size(); ++i)
        {
          std::size_t idx = completion_order[i];
          std::cout << "operation " << idx << " finished: ";
          std::cout << ec[idx] << ", " << n[idx] << "\n";
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\parallel_group\wait_for_all.cpp
//
// wait_for_all.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/deferred.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#ifdef ASIO_HAS_POSIX_STREAM_DESCRIPTOR

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      in.async_read_some(
        asio::buffer(data),
        asio::deferred),
      timer.async_wait(
        asio::deferred)
    ).async_wait(
      asio::experimental::wait_for_all(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\parallel_group\wait_for_one_error.cpp
//
// wait_for_one_error.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/deferred.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      in.async_read_some(
        asio::buffer(data),
        asio::deferred),
      timer.async_wait(
        asio::deferred)
    ).async_wait(
      asio::experimental::wait_for_one_error(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\parallel_group\wait_for_one_success.cpp
//
// wait_for_one_error.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/deferred.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      in.async_read_some(
        asio::buffer(data),
        asio::deferred),
      timer.async_wait(
        asio::deferred)
    ).async_wait(
      asio::experimental::wait_for_one_success(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\parallel_group\wait_for_one.cpp
//
// wait_for_one.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/deferred.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      in.async_read_some(
        asio::buffer(data),
        asio::deferred),
      timer.async_wait(
        asio::deferred)
    ).async_wait(
      asio::experimental::wait_for_one(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\porthopper\client.cpp
//
// client.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <algorithm>
#include <cstdlib>
#include <exception>
#include <iostream>
#include <memory>
#include <string>
#include <utility>
#include "protocol.hpp"

using asio::ip::tcp;
using asio::ip::udp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: client <host> <port>\n";
      return 1;
    }
    using namespace std; // For atoi.
    std::string host_name = argv[1];
    std::string port = argv[2];

    asio::io_context io_context;

    // Determine the location of the server.
    tcp::resolver resolver(io_context);
    tcp::endpoint remote_endpoint = *resolver.resolve(host_name, port).begin();

    // Establish the control connection to the server.
    tcp::socket control_socket(io_context);
    control_socket.connect(remote_endpoint);

    // Create a datagram socket to receive data from the server.
    udp::socket data_socket(io_context, udp::endpoint(udp::v4(), 0));

    // Determine what port we will receive data on.
    udp::endpoint data_endpoint = data_socket.local_endpoint();

    // Ask the server to start sending us data.
    control_request start = control_request::start(data_endpoint.port());
    asio::write(control_socket, start.to_buffers());

    unsigned long last_frame_number = 0;
    for (;;)
    {
      // Receive 50 messages on the current data socket.
      for (int i = 0; i < 50; ++i)
      {
        // Receive a frame from the server.
        frame f;
        data_socket.receive(f.to_buffers(), 0);
        if (f.number() > last_frame_number)
        {
          last_frame_number = f.number();
          std::cout << "\n" << f.payload();
        }
      }

      // Time to switch to a new socket. To ensure seamless handover we will
      // continue to receive packets using the old socket until data arrives on
      // the new one.
      std::cout << " Starting renegotiation";

      // Create the new data socket.
      udp::socket new_data_socket(io_context, udp::endpoint(udp::v4(), 0));

      // Determine the new port we will use to receive data.
      udp::endpoint new_data_endpoint = new_data_socket.local_endpoint();

      // Ask the server to switch over to the new port.
      control_request change = control_request::change(
          data_endpoint.port(), new_data_endpoint.port());
      std::error_code control_result;
      asio::async_write(control_socket, change.to_buffers(),
          [&](std::error_code ec, std::size_t /*length*/)
          {
            control_result = ec;
          });

      // Try to receive a frame from the server on the new data socket. If we
      // successfully receive a frame on this new data socket we can consider
      // the renegotation complete. In that case we will close the old data
      // socket, which will cause any outstanding receive operation on it to be
      // cancelled.
      frame f1;
      std::error_code new_data_socket_result;
      new_data_socket.async_receive(f1.to_buffers(),
          [&](std::error_code ec, std::size_t /*length*/)
          {
            new_data_socket_result = ec;
            if (!ec)
            {
              // We have successfully received a frame on the new data socket,
              // so we can close the old data socket. This will cancel any
              // outstanding receive operation on the old data socket.
              data_socket.close();
            }
          });

      // This loop will continue until we have successfully completed the
      // renegotiation (i.e. received a frame on the new data socket), or some
      // unrecoverable error occurs.
      bool done = false;
      while (!done)
      {
        // Even though we're performing a renegotation, we want to continue
        // receiving data as smoothly as possible. Therefore we will continue to
        // try to receive a frame from the server on the old data socket. If we
        // receive a frame on this socket we will interrupt the io_context,
        // print the frame, and resume waiting for the other operations to
        // complete.
        frame f2;
        done = true; // Let's be optimistic.
        if (data_socket.is_open()) // May have been closed by receive handler.
        {
          data_socket.async_receive(f2.to_buffers(), 0,
              [&](std::error_code ec, std::size_t /*length*/)
              {
                if (!ec)
                {
                  // We have successfully received a frame on the old data
                  // socket. Stop the io_context so that we can print it.
                  io_context.stop();
                  done = false;
                }
              });
        }

        // Run the operations in parallel. This will block until all operations
        // have finished, or until the io_context is interrupted. (No threads!)
        io_context.restart();
        io_context.run();

        // If the io_context.run() was interrupted then we have received a frame
        // on the old data socket. We need to keep waiting for the renegotation
        // operations to complete.
        if (!done)
        {
          if (f2.number() > last_frame_number)
          {
            last_frame_number = f2.number();
            std::cout << "\n" << f2.payload();
          }
        }
      }

      // Since the loop has finished, we have either successfully completed
      // the renegotation, or an error has occurred. First we'll check for
      // errors.
      if (control_result)
        throw std::system_error(control_result);
      if (new_data_socket_result)
        throw std::system_error(new_data_socket_result);

      // If we get here it means we have successfully started receiving data on
      // the new data socket. This new data socket will be used from now on
      // (until the next time we renegotiate).
      std::cout << " Renegotiation complete";
      data_socket = std::move(new_data_socket);
      data_endpoint = new_data_endpoint;
      if (f1.number() > last_frame_number)
      {
        last_frame_number = f1.number();
        std::cout << "\n" << f1.payload();
      }
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\porthopper\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <cmath>
#include <cstdlib>
#include <exception>
#include <functional>
#include <iostream>
#include <memory>
#include <set>
#include "protocol.hpp"

using asio::ip::tcp;
using asio::ip::udp;

typedef std::shared_ptr<tcp::socket> tcp_socket_ptr;
typedef std::shared_ptr<asio::steady_timer> timer_ptr;
typedef std::shared_ptr<control_request> control_request_ptr;

class server
{
public:
  // Construct the server to wait for incoming control connections.
  server(asio::io_context& io_context, unsigned short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),
      timer_(io_context),
      udp_socket_(io_context, udp::endpoint(udp::v4(), 0)),
      next_frame_number_(1)
  {
    // Start waiting for a new control connection.
    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));
    acceptor_.async_accept(*new_socket,
        std::bind(&server::handle_accept, this,
          asio::placeholders::error, new_socket));

    // Start the timer used to generate outgoing frames.
    timer_.expires_after(asio::chrono::milliseconds(100));
    timer_.async_wait(std::bind(&server::handle_timer, this));
  }

  // Handle a new control connection.
  void handle_accept(const std::error_code& ec, tcp_socket_ptr socket)
  {
    if (!ec)
    {
      // Start receiving control requests on the connection.
      control_request_ptr request(new control_request);
      asio::async_read(*socket, request->to_buffers(),
          std::bind(&server::handle_control_request, this,
            asio::placeholders::error, socket, request));
    }

    // Start waiting for a new control connection.
    tcp_socket_ptr new_socket(new tcp::socket(acceptor_.get_executor()));
    acceptor_.async_accept(*new_socket,
        std::bind(&server::handle_accept, this,
          asio::placeholders::error, new_socket));
  }

  // Handle a new control request.
  void handle_control_request(const std::error_code& ec,
      tcp_socket_ptr socket, control_request_ptr request)
  {
    if (!ec)
    {
      // Delay handling of the control request to simulate network latency.
      timer_ptr delay_timer(
          new asio::steady_timer(acceptor_.get_executor()));
      delay_timer->expires_after(asio::chrono::seconds(2));
      delay_timer->async_wait(
          std::bind(&server::handle_control_request_timer, this,
            socket, request, delay_timer));
    }
  }

  void handle_control_request_timer(tcp_socket_ptr socket,
      control_request_ptr request, timer_ptr /*delay_timer*/)
  {
    // Determine what address this client is connected from, since
    // subscriptions must be stored on the server as a complete endpoint, not
    // just a port. We use the non-throwing overload of remote_endpoint() since
    // it may fail if the socket is no longer connected.
    std::error_code ec;
    tcp::endpoint remote_endpoint = socket->remote_endpoint(ec);
    if (!ec)
    {
      // Remove old port subscription, if any.
      if (unsigned short old_port = request->old_port())
      {
        udp::endpoint old_endpoint(remote_endpoint.address(), old_port);
        subscribers_.erase(old_endpoint);
        std::cout << "Removing subscription " << old_endpoint << std::endl;
      }

      // Add new port subscription, if any.
      if (unsigned short new_port = request->new_port())
      {
        udp::endpoint new_endpoint(remote_endpoint.address(), new_port);
        subscribers_.insert(new_endpoint);
        std::cout << "Adding subscription " << new_endpoint << std::endl;
      }
    }

    // Wait for next control request on this connection.
    asio::async_read(*socket, request->to_buffers(),
        std::bind(&server::handle_control_request, this,
          asio::placeholders::error, socket, request));
  }

  // Every time the timer fires we will generate a new frame and send it to all
  // subscribers.
  void handle_timer()
  {
    // Generate payload.
    double x = next_frame_number_ * 0.2;
    double y = std::sin(x);
    int char_index = static_cast<int>((y + 1.0) * (frame::payload_size / 2));
    std::string payload;
    for (int i = 0; i < frame::payload_size; ++i)
      payload += (i == char_index ? '*' : '.');

    // Create the frame to be sent to all subscribers.
    frame f(next_frame_number_++, payload);

    // Send frame to all subscribers. We can use synchronous calls here since
    // UDP send operations typically do not block.
    std::set<udp::endpoint>::iterator j;
    for (j = subscribers_.begin(); j != subscribers_.end(); ++j)
    {
      std::error_code ec;
      udp_socket_.send_to(f.to_buffers(), *j, 0, ec);
    }

    // Wait for next timeout.
    timer_.expires_after(asio::chrono::milliseconds(100));
    timer_.async_wait(std::bind(&server::handle_timer, this));
  }

private:
  // The acceptor used to accept incoming control connections.
  tcp::acceptor acceptor_;

  // The timer used for generating data.
  asio::steady_timer timer_;

  // The socket used to send data to subscribers.
  udp::socket udp_socket_;

  // The next frame number.
  unsigned long next_frame_number_;

  // The set of endpoints that are subscribed.
  std::set<udp::endpoint> subscribers_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    using namespace std; // For atoi.
    server s(io_context, atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\serialization\client.cpp
//
// client.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <functional>
#include <iostream>
#include <vector>
#include "connection.hpp" // Must come before boost/serialization headers.
#include <boost/serialization/vector.hpp>
#include "stock.hpp"

namespace s11n_example {

/// Downloads stock quote information from a server.
class client
{
public:
  /// Constructor starts the asynchronous connect operation.
  client(asio::io_context& io_context,
      const std::string& host, const std::string& service)
    : connection_(io_context.get_executor())
  {
    // Resolve the host name into an IP address.
    asio::ip::tcp::resolver resolver(io_context);
    asio::ip::tcp::resolver::query query(host, service);
    asio::ip::tcp::resolver::iterator endpoint_iterator =
      resolver.resolve(query);

    // Start an asynchronous connect operation.
    asio::async_connect(connection_.socket(), endpoint_iterator,
        std::bind(&client::handle_connect, this,
          asio::placeholders::error));
  }

  /// Handle completion of a connect operation.
  void handle_connect(const asio::error_code& e)
  {
    if (!e)
    {
      // Successfully established connection. Start operation to read the list
      // of stocks. The connection::async_read() function will automatically
      // decode the data that is read from the underlying socket.
      connection_.async_read(stocks_,
          std::bind(&client::handle_read, this,
            asio::placeholders::error));
    }
    else
    {
      // An error occurred. Log it and return. Since we are not starting a new
      // operation the io_context will run out of work to do and the client will
      // exit.
      std::cerr << e.message() << std::endl;
    }
  }

  /// Handle completion of a read operation.
  void handle_read(const asio::error_code& e)
  {
    if (!e)
    {
      // Print out the data that was received.
      for (std::size_t i = 0; i < stocks_.size(); ++i)
      {
        std::cout << "Stock number " << i << "\n";
        std::cout << "  code: " << stocks_[i].code << "\n";
        std::cout << "  name: " << stocks_[i].name << "\n";
        std::cout << "  open_price: " << stocks_[i].open_price << "\n";
        std::cout << "  high_price: " << stocks_[i].high_price << "\n";
        std::cout << "  low_price: " << stocks_[i].low_price << "\n";
        std::cout << "  last_price: " << stocks_[i].last_price << "\n";
        std::cout << "  buy_price: " << stocks_[i].buy_price << "\n";
        std::cout << "  buy_quantity: " << stocks_[i].buy_quantity << "\n";
        std::cout << "  sell_price: " << stocks_[i].sell_price << "\n";
        std::cout << "  sell_quantity: " << stocks_[i].sell_quantity << "\n";
      }
    }
    else
    {
      // An error occurred.
      std::cerr << e.message() << std::endl;
    }

    // Since we are not starting a new operation the io_context will run out of
    // work to do and the client will exit.
  }

private:
  /// The connection to the server.
  connection connection_;

  /// The data received from the server.
  std::vector<stock> stocks_;
};

} // namespace s11n_example

int main(int argc, char* argv[])
{
  try
  {
    // Check command line arguments.
    if (argc != 3)
    {
      std::cerr << "Usage: client <host> <port>" << std::endl;
      return 1;
    }

    asio::io_context io_context;
    s11n_example::client client(io_context, argv[1], argv[2]);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\serialization\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <functional>
#include <iostream>
#include <vector>
#include "connection.hpp" // Must come before boost/serialization headers.
#include <boost/serialization/vector.hpp>
#include "stock.hpp"

namespace s11n_example {

/// Serves stock quote information to any client that connects to it.
class server
{
public:
  /// Constructor opens the acceptor and starts waiting for the first incoming
  /// connection.
  server(asio::io_context& io_context, unsigned short port)
    : acceptor_(io_context,
        asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))
  {
    // Create the data to be sent to each client.
    stock s;
    s.code = "ABC";
    s.name = "A Big Company";
    s.open_price = 4.56;
    s.high_price = 5.12;
    s.low_price = 4.33;
    s.last_price = 4.98;
    s.buy_price = 4.96;
    s.buy_quantity = 1000;
    s.sell_price = 4.99;
    s.sell_quantity = 2000;
    stocks_.push_back(s);
    s.code = "DEF";
    s.name = "Developer Entertainment Firm";
    s.open_price = 20.24;
    s.high_price = 22.88;
    s.low_price = 19.50;
    s.last_price = 19.76;
    s.buy_price = 19.72;
    s.buy_quantity = 34000;
    s.sell_price = 19.85;
    s.sell_quantity = 45000;
    stocks_.push_back(s);

    // Start an accept operation for a new connection.
    connection_ptr new_conn(new connection(acceptor_.get_executor()));
    acceptor_.async_accept(new_conn->socket(),
        std::bind(&server::handle_accept, this,
          asio::placeholders::error, new_conn));
  }

  /// Handle completion of a accept operation.
  void handle_accept(const std::error_code& e, connection_ptr conn)
  {
    if (!e)
    {
      // Successfully accepted a new connection. Send the list of stocks to the
      // client. The connection::async_write() function will automatically
      // serialize the data structure for us.
      conn->async_write(stocks_,
          std::bind(&server::handle_write, this,
            asio::placeholders::error, conn));
    }

    // Start an accept operation for a new connection.
    connection_ptr new_conn(new connection(acceptor_.get_executor()));
    acceptor_.async_accept(new_conn->socket(),
        std::bind(&server::handle_accept, this,
          asio::placeholders::error, new_conn));
  }

  /// Handle completion of a write operation.
  void handle_write(const std::error_code& e, connection_ptr conn)
  {
    // Nothing to do. The socket will be closed automatically when the last
    // reference to the connection object goes away.
  }

private:
  /// The acceptor object used to accept incoming socket connections.
  asio::ip::tcp::acceptor acceptor_;

  /// The data to be sent to each client.
  std::vector<stock> stocks_;
};

} // namespace s11n_example

int main(int argc, char* argv[])
{
  try
  {
    // Check command line arguments.
    if (argc != 2)
    {
      std::cerr << "Usage: server <port>" << std::endl;
      return 1;
    }
    unsigned short port = std::stoi(argv[1]);

    asio::io_context io_context;
    s11n_example::server server(io_context, port);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\services\daytime_client.cpp
//
// daytime_client.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <functional>
#include <iostream>
#include "logger.hpp"

using asio::ip::tcp;

char read_buffer[1024];

void read_handler(const asio::error_code& e,
    std::size_t bytes_transferred, tcp::socket* s)
{
  if (!e)
  {
    std::cout.write(read_buffer, bytes_transferred);

    s->async_read_some(asio::buffer(read_buffer),
        std::bind(read_handler, asio::placeholders::error,
          asio::placeholders::bytes_transferred, s));
  }
  else
  {
    asio::execution_context& context = asio::query(
        s->get_executor(), asio::execution::context);
    services::logger logger(context, "read_handler");

    std::string msg = "Read error: ";
    msg += e.message();
    logger.log(msg);
  }
}

void connect_handler(const asio::error_code& e, tcp::socket* s)
{
  asio::execution_context& context = asio::query(
      s->get_executor(), asio::execution::context);
  services::logger logger(context, "connect_handler");

  if (!e)
  {
    logger.log("Connection established");

    s->async_read_some(asio::buffer(read_buffer),
        std::bind(read_handler, asio::placeholders::error,
          asio::placeholders::bytes_transferred, s));
  }
  else
  {
    std::string msg = "Unable to establish connection: ";
    msg += e.message();
    logger.log(msg);
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: daytime_client <host>" << std::endl;
      return 1;
    }

    asio::io_context io_context;

    // Set the name of the file that all logger instances will use.
    services::logger logger(io_context, "");
    logger.use_file("log.txt");

    // Resolve the address corresponding to the given host.
    tcp::resolver resolver(io_context);
    tcp::resolver::results_type endpoints =
      resolver.resolve(argv[1], "daytime");

    // Start an asynchronous connect.
    tcp::socket socket(io_context);
    asio::async_connect(socket, endpoints,
        std::bind(connect_handler,
          asio::placeholders::error, &socket));

    // Run the io_context until all operations have finished.
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\services\logger_service.cpp
//
// logger_service.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "logger_service.hpp"

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\socks4\sync_client.cpp
//
// sync_client.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <iostream>
#include <iomanip>
#include <ostream>
#include <string>
#include <asio.hpp>
#include "socks4.hpp"

using asio::ip::tcp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 4)
    {
      std::cout << "Usage: sync_client <socks4server> <socks4port> <user>\n";
      std::cout << "Examples:\n";
      std::cout << "  sync_client 127.0.0.1 1080 chris\n";
      std::cout << "  sync_client localhost socks chris\n";
      return 1;
    }

    asio::io_context io_context;

    // Get a list of endpoints corresponding to the SOCKS 4 server name.
    tcp::resolver resolver(io_context);
    auto endpoints = resolver.resolve(argv[1], argv[2]);

    // Try each endpoint until we successfully establish a connection to the
    // SOCKS 4 server.
    tcp::socket socket(io_context);
    asio::connect(socket, endpoints);

    // Get an endpoint for the Boost website. This will be passed to the SOCKS
    // 4 server. Explicitly specify IPv4 since SOCKS 4 does not support IPv6.
    auto http_endpoint =
      *resolver.resolve(tcp::v4(), "www.boost.org", "http").begin();

    // Send the request to the SOCKS 4 server.
    socks4::request socks_request(
        socks4::request::connect, http_endpoint, argv[3]);
    asio::write(socket, socks_request.buffers());

    // Receive a response from the SOCKS 4 server.
    socks4::reply socks_reply;
    asio::read(socket, socks_reply.buffers());

    // Check whether we successfully negotiated with the SOCKS 4 server.
    if (!socks_reply.success())
    {
      std::cout << "Connection failed.\n";
      std::cout << "status = 0x" << std::hex << socks_reply.status();
      return 1;
    }

    // Form the HTTP request. We specify the "Connection: close" header so that
    // the server will close the socket after transmitting the response. This
    // will allow us to treat all data up until the EOF as the response.
    std::string request =
      "GET / HTTP/1.0\r\n"
      "Host: www.boost.org\r\n"
      "Accept: */*\r\n"
      "Connection: close\r\n\r\n";

    // Send the HTTP request.
    asio::write(socket, asio::buffer(request));

    // Read until EOF, writing data to output as we go.
    std::array<char, 512> response;
    std::error_code error;
    while (std::size_t s = socket.read_some(
          asio::buffer(response), error))
      std::cout.write(response.data(), s);
    if (error != asio::error::eof)
      throw std::system_error(error);
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\spawn\echo_server.cpp
//
// echo_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/spawn.hpp>
#include <asio/steady_timer.hpp>
#include <asio/write.hpp>
#include <iostream>
#include <memory>

using asio::ip::tcp;

class session : public std::enable_shared_from_this<session>
{
public:
  explicit session(asio::io_context& io_context, tcp::socket socket)
    : socket_(std::move(socket)),
      timer_(io_context),
      strand_(io_context.get_executor())
  {
  }

  void go()
  {
    auto self(shared_from_this());
    asio::spawn(strand_,
        [this, self](asio::yield_context yield)
        {
          try
          {
            char data[128];
            for (;;)
            {
              timer_.expires_after(std::chrono::seconds(10));
              std::size_t n = socket_.async_read_some(asio::buffer(data), yield);
              asio::async_write(socket_, asio::buffer(data, n), yield);
            }
          }
          catch (std::exception& e)
          {
            socket_.close();
            timer_.cancel();
          }
        }, asio::detached);

    asio::spawn(strand_,
        [this, self](asio::yield_context yield)
        {
          while (socket_.is_open())
          {
            std::error_code ignored_ec;
            timer_.async_wait(yield[ignored_ec]);
            if (timer_.expiry() <= asio::steady_timer::clock_type::now())
              socket_.close();
          }
        }, asio::detached);
  }

private:
  tcp::socket socket_;
  asio::steady_timer timer_;
  asio::strand<asio::io_context::executor_type> strand_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    asio::spawn(io_context,
        [&](asio::yield_context yield)
        {
          tcp::acceptor acceptor(io_context,
            tcp::endpoint(tcp::v4(), std::atoi(argv[1])));

          for (;;)
          {
            std::error_code ec;
            tcp::socket socket(io_context);
            acceptor.async_accept(socket, yield[ec]);
            if (!ec)
            {
              std::make_shared<session>(io_context, std::move(socket))->go();
            }
          }
        },
        [](std::exception_ptr e)
        {
          if (e)
            std::rethrow_exception(e);
        });

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\spawn\parallel_grep.cpp
//
// parallel_grep.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/detached.hpp>
#include <asio/dispatch.hpp>
#include <asio/post.hpp>
#include <asio/spawn.hpp>
#include <asio/strand.hpp>
#include <asio/thread_pool.hpp>
#include <fstream>
#include <iostream>
#include <string>

using asio::detached;
using asio::dispatch;
using asio::spawn;
using asio::strand;
using asio::thread_pool;
using asio::yield_context;

int main(int argc, char* argv[])
{
  try
  {
    if (argc < 2)
    {
      std::cerr << "Usage: parallel_grep <string> <files...>\n";
      return 1;
    }

    // We use a fixed size pool of threads for reading the input files. The
    // number of threads is automatically determined based on the number of
    // CPUs available in the system.
    thread_pool pool;

    // To prevent the output from being garbled, we use a strand to synchronise
    // printing.
    strand<thread_pool::executor_type> output_strand(pool.get_executor());

    // Spawn a new coroutine for each file specified on the command line.
    std::string search_string = argv[1];
    for (int argn = 2; argn < argc; ++argn)
    {
      std::string input_file = argv[argn];
      spawn(pool,
        [=](yield_context yield)
        {
          std::ifstream is(input_file.c_str());
          std::string line;
          std::size_t line_num = 0;
          while (std::getline(is, line))
          {
            // If we find a match, send a message to the output.
            if (line.find(search_string) != std::string::npos)
            {
              dispatch(output_strand,
                  [=]
                  {
                    std::cout << input_file << ':' << line << std::endl;
                  });
            }

            // Every so often we yield control to another coroutine.
            if (++line_num % 10 == 0)
              post(yield);
          }
        }, detached);
    }

    // Join the thread pool to wait for all the spawned tasks to complete.
    pool.join();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\ssl\client.cpp
//
// client.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <cstring>
#include <functional>
#include <iostream>
#include "asio.hpp"
#include "asio/ssl.hpp"

using asio::ip::tcp;
using std::placeholders::_1;
using std::placeholders::_2;

enum { max_length = 1024 };

class client
{
public:
  client(asio::io_context& io_context,
      asio::ssl::context& context,
      const tcp::resolver::results_type& endpoints)
    : socket_(io_context, context)
  {
    socket_.set_verify_mode(asio::ssl::verify_peer);
    socket_.set_verify_callback(
        std::bind(&client::verify_certificate, this, _1, _2));

    connect(endpoints);
  }

private:
  bool verify_certificate(bool preverified,
      asio::ssl::verify_context& ctx)
  {
    // The verify callback can be used to check whether the certificate that is
    // being presented is valid for the peer. For example, RFC 2818 describes
    // the steps involved in doing this for HTTPS. Consult the OpenSSL
    // documentation for more details. Note that the callback is called once
    // for each certificate in the certificate chain, starting from the root
    // certificate authority.

    // In this example we will simply print the certificate's subject name.
    char subject_name[256];
    X509* cert = X509_STORE_CTX_get_current_cert(ctx.native_handle());
    X509_NAME_oneline(X509_get_subject_name(cert), subject_name, 256);
    std::cout << "Verifying " << subject_name << "\n";

    return preverified;
  }

  void connect(const tcp::resolver::results_type& endpoints)
  {
    asio::async_connect(socket_.lowest_layer(), endpoints,
        [this](const std::error_code& error,
          const tcp::endpoint& /*endpoint*/)
        {
          if (!error)
          {
            handshake();
          }
          else
          {
            std::cout << "Connect failed: " << error.message() << "\n";
          }
        });
  }

  void handshake()
  {
    socket_.async_handshake(asio::ssl::stream_base::client,
        [this](const std::error_code& error)
        {
          if (!error)
          {
            send_request();
          }
          else
          {
            std::cout << "Handshake failed: " << error.message() << "\n";
          }
        });
  }

  void send_request()
  {
    std::cout << "Enter message: ";
    std::cin.getline(request_, max_length);
    size_t request_length = std::strlen(request_);

    asio::async_write(socket_,
        asio::buffer(request_, request_length),
        [this](const std::error_code& error, std::size_t length)
        {
          if (!error)
          {
            receive_response(length);
          }
          else
          {
            std::cout << "Write failed: " << error.message() << "\n";
          }
        });
  }

  void receive_response(std::size_t length)
  {
    asio::async_read(socket_,
        asio::buffer(reply_, length),
        [this](const std::error_code& error, std::size_t length)
        {
          if (!error)
          {
            std::cout << "Reply: ";
            std::cout.write(reply_, length);
            std::cout << "\n";
          }
          else
          {
            std::cout << "Read failed: " << error.message() << "\n";
          }
        });
  }

  asio::ssl::stream<tcp::socket> socket_;
  char request_[max_length];
  char reply_[max_length];
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    tcp::resolver resolver(io_context);
    auto endpoints = resolver.resolve(argv[1], argv[2]);

    asio::ssl::context ctx(asio::ssl::context::sslv23);
    ctx.load_verify_file("ca.pem");

    client c(io_context, ctx, endpoints);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\ssl\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <functional>
#include <iostream>
#include "asio.hpp"
#include "asio/ssl.hpp"

using asio::ip::tcp;

class session : public std::enable_shared_from_this<session>
{
public:
  session(asio::ssl::stream<tcp::socket> socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    do_handshake();
  }

private:
  void do_handshake()
  {
    auto self(shared_from_this());
    socket_.async_handshake(asio::ssl::stream_base::server, 
        [this, self](const std::error_code& error)
        {
          if (!error)
          {
            do_read();
          }
        });
  }

  void do_read()
  {
    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_),
        [this, self](const std::error_code& ec, std::size_t length)
        {
          if (!ec)
          {
            do_write(length);
          }
        });
  }

  void do_write(std::size_t length)
  {
    auto self(shared_from_this());
    asio::async_write(socket_, asio::buffer(data_, length),
        [this, self](const std::error_code& ec,
          std::size_t /*length*/)
        {
          if (!ec)
          {
            do_read();
          }
        });
  }

  asio::ssl::stream<tcp::socket> socket_;
  char data_[1024];
};

class server
{
public:
  server(asio::io_context& io_context, unsigned short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),
      context_(asio::ssl::context::sslv23)
  {
    context_.set_options(
        asio::ssl::context::default_workarounds
        | asio::ssl::context::no_sslv2
        | asio::ssl::context::single_dh_use);
    context_.set_password_callback(std::bind(&server::get_password, this));
    context_.use_certificate_chain_file("server.pem");
    context_.use_private_key_file("server.pem", asio::ssl::context::pem);
    context_.use_tmp_dh_file("dh4096.pem");

    do_accept();
  }

private:
  std::string get_password() const
  {
    return "test";
  }

  void do_accept()
  {
    acceptor_.async_accept(
        [this](const std::error_code& error, tcp::socket socket)
        {
          if (!error)
          {
            std::make_shared<session>(
                asio::ssl::stream<tcp::socket>(
                  std::move(socket), context_))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
  asio::ssl::context context_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    using namespace std; // For atoi.
    server s(io_context, atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\timeouts\async_tcp_client.cpp
//
// async_tcp_client.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/buffer.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/read_until.hpp"
#include "asio/steady_timer.hpp"
#include "asio/write.hpp"
#include <functional>
#include <iostream>
#include <string>

using asio::steady_timer;
using asio::ip::tcp;
using std::placeholders::_1;
using std::placeholders::_2;

//
// This class manages socket timeouts by applying the concept of a deadline.
// Some asynchronous operations are given deadlines by which they must complete.
// Deadlines are enforced by an "actor" that persists for the lifetime of the
// client object:
//
//  +----------------+
//  |                |
//  | check_deadline |<---+
//  |                |    |
//  +----------------+    | async_wait()
//              |         |
//              +---------+
//
// If the deadline actor determines that the deadline has expired, the socket
// is closed and any outstanding operations are consequently cancelled.
//
// Connection establishment involves trying each endpoint in turn until a
// connection is successful, or the available endpoints are exhausted. If the
// deadline actor closes the socket, the connect actor is woken up and moves to
// the next endpoint.
//
//  +---------------+
//  |               |
//  | start_connect |<---+
//  |               |    |
//  +---------------+    |
//           |           |
//  async_-  |    +----------------+
// connect() |    |                |
//           +--->| handle_connect |
//                |                |
//                +----------------+
//                          :
// Once a connection is     :
// made, the connect        :
// actor forks in two -     :
//                          :
// an actor for reading     :       and an actor for
// inbound messages:        :       sending heartbeats:
//                          :
//  +------------+          :          +-------------+
//  |            |<- - - - -+- - - - ->|             |
//  | start_read |                     | start_write |<---+
//  |            |<---+                |             |    |
//  +------------+    |                +-------------+    | async_wait()
//          |         |                        |          |
//  async_- |    +-------------+       async_- |    +--------------+
//   read_- |    |             |       write() |    |              |
//  until() +--->| handle_read |               +--->| handle_write |
//               |             |                    |              |
//               +-------------+                    +--------------+
//
// The input actor reads messages from the socket, where messages are delimited
// by the newline character. The deadline for a complete message is 30 seconds.
//
// The heartbeat actor sends a heartbeat (a message that consists of a single
// newline character) every 10 seconds. In this example, no deadline is applied
// to message sending.
//
class client
{
public:
  client(asio::io_context& io_context)
    : socket_(io_context),
      deadline_(io_context),
      heartbeat_timer_(io_context)
  {
  }

  // Called by the user of the client class to initiate the connection process.
  // The endpoints will have been obtained using a tcp::resolver.
  void start(tcp::resolver::results_type endpoints)
  {
    // Start the connect actor.
    endpoints_ = endpoints;
    start_connect(endpoints_.begin());

    // Start the deadline actor. You will note that we're not setting any
    // particular deadline here. Instead, the connect and input actors will
    // update the deadline prior to each asynchronous operation.
    deadline_.async_wait(std::bind(&client::check_deadline, this));
  }

  // This function terminates all the actors to shut down the connection. It
  // may be called by the user of the client class, or by the class itself in
  // response to graceful termination or an unrecoverable error.
  void stop()
  {
    stopped_ = true;
    std::error_code ignored_error;
    socket_.close(ignored_error);
    deadline_.cancel();
    heartbeat_timer_.cancel();
  }

private:
  void start_connect(tcp::resolver::results_type::iterator endpoint_iter)
  {
    if (endpoint_iter != endpoints_.end())
    {
      std::cout << "Trying " << endpoint_iter->endpoint() << "...\n";

      // Set a deadline for the connect operation.
      deadline_.expires_after(std::chrono::seconds(60));

      // Start the asynchronous connect operation.
      socket_.async_connect(endpoint_iter->endpoint(),
          std::bind(&client::handle_connect,
            this, _1, endpoint_iter));
    }
    else
    {
      // There are no more endpoints to try. Shut down the client.
      stop();
    }
  }

  void handle_connect(const std::error_code& error,
      tcp::resolver::results_type::iterator endpoint_iter)
  {
    if (stopped_)
      return;

    // The async_connect() function automatically opens the socket at the start
    // of the asynchronous operation. If the socket is closed at this time then
    // the timeout handler must have run first.
    if (!socket_.is_open())
    {
      std::cout << "Connect timed out\n";

      // Try the next available endpoint.
      start_connect(++endpoint_iter);
    }

    // Check if the connect operation failed before the deadline expired.
    else if (error)
    {
      std::cout << "Connect error: " << error.message() << "\n";

      // We need to close the socket used in the previous connection attempt
      // before starting a new one.
      socket_.close();

      // Try the next available endpoint.
      start_connect(++endpoint_iter);
    }

    // Otherwise we have successfully established a connection.
    else
    {
      std::cout << "Connected to " << endpoint_iter->endpoint() << "\n";

      // Start the input actor.
      start_read();

      // Start the heartbeat actor.
      start_write();
    }
  }

  void start_read()
  {
    // Set a deadline for the read operation.
    deadline_.expires_after(std::chrono::seconds(30));

    // Start an asynchronous operation to read a newline-delimited message.
    asio::async_read_until(socket_,
        asio::dynamic_buffer(input_buffer_), '\n',
        std::bind(&client::handle_read, this, _1, _2));
  }

  void handle_read(const std::error_code& error, std::size_t n)
  {
    if (stopped_)
      return;

    if (!error)
    {
      // Extract the newline-delimited message from the buffer.
      std::string line(input_buffer_.substr(0, n - 1));
      input_buffer_.erase(0, n);

      // Empty messages are heartbeats and so ignored.
      if (!line.empty())
      {
        std::cout << "Received: " << line << "\n";
      }

      start_read();
    }
    else
    {
      std::cout << "Error on receive: " << error.message() << "\n";

      stop();
    }
  }

  void start_write()
  {
    if (stopped_)
      return;

    // Start an asynchronous operation to send a heartbeat message.
    asio::async_write(socket_, asio::buffer("\n", 1),
        std::bind(&client::handle_write, this, _1));
  }

  void handle_write(const std::error_code& error)
  {
    if (stopped_)
      return;

    if (!error)
    {
      // Wait 10 seconds before sending the next heartbeat.
      heartbeat_timer_.expires_after(std::chrono::seconds(10));
      heartbeat_timer_.async_wait(std::bind(&client::start_write, this));
    }
    else
    {
      std::cout << "Error on heartbeat: " << error.message() << "\n";

      stop();
    }
  }

  void check_deadline()
  {
    if (stopped_)
      return;

    // Check whether the deadline has passed. We compare the deadline against
    // the current time since a new asynchronous operation may have moved the
    // deadline before this actor had a chance to run.
    if (deadline_.expiry() <= steady_timer::clock_type::now())
    {
      // The deadline has passed. The socket is closed so that any outstanding
      // asynchronous operations are cancelled.
      socket_.close();

      // There is no longer an active deadline. The expiry is set to the
      // maximum time point so that the actor takes no action until a new
      // deadline is set.
      deadline_.expires_at(steady_timer::time_point::max());
    }

    // Put the actor back to sleep.
    deadline_.async_wait(std::bind(&client::check_deadline, this));
  }

private:
  bool stopped_ = false;
  tcp::resolver::results_type endpoints_;
  tcp::socket socket_;
  std::string input_buffer_;
  steady_timer deadline_;
  steady_timer heartbeat_timer_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;
    tcp::resolver r(io_context);
    client c(io_context);

    c.start(r.resolve(argv[1], argv[2]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\timeouts\blocking_tcp_client.cpp
//
// blocking_tcp_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/buffer.hpp"
#include "asio/connect.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/read_until.hpp"
#include "asio/system_error.hpp"
#include "asio/write.hpp"
#include <cstdlib>
#include <iostream>
#include <string>

using asio::ip::tcp;

//----------------------------------------------------------------------

//
// This class manages socket timeouts by running the io_context using the timed
// io_context::run_for() member function. Each asynchronous operation is given
// a timeout within which it must complete. The socket operations themselves
// use lambdas as completion handlers. For a given socket operation, the client
// object runs the io_context to block thread execution until the operation
// completes or the timeout is reached. If the io_context::run_for() function
// times out, the socket is closed and the outstanding asynchronous operation
// is cancelled.
//
class client
{
public:
  void connect(const std::string& host, const std::string& service,
      std::chrono::steady_clock::duration timeout)
  {
    // Resolve the host name and service to a list of endpoints.
    auto endpoints = tcp::resolver(io_context_).resolve(host, service);

    // Start the asynchronous operation itself. The lambda that is used as a
    // callback will update the error variable when the operation completes.
    // The blocking_udp_client.cpp example shows how you can use std::bind
    // rather than a lambda.
    std::error_code error;
    asio::async_connect(socket_, endpoints,
        [&](const std::error_code& result_error,
            const tcp::endpoint& /*result_endpoint*/)
        {
          error = result_error;
        });

    // Run the operation until it completes, or until the timeout.
    run(timeout);

    // Determine whether a connection was successfully established.
    if (error)
      throw std::system_error(error);
  }

  std::string read_line(std::chrono::steady_clock::duration timeout)
  {
    // Start the asynchronous operation. The lambda that is used as a callback
    // will update the error and n variables when the operation completes. The
    // blocking_udp_client.cpp example shows how you can use std::bind rather
    // than a lambda.
    std::error_code error;
    std::size_t n = 0;
    asio::async_read_until(socket_,
        asio::dynamic_buffer(input_buffer_), '\n',
        [&](const std::error_code& result_error,
            std::size_t result_n)
        {
          error = result_error;
          n = result_n;
        });

    // Run the operation until it completes, or until the timeout.
    run(timeout);

    // Determine whether the read completed successfully.
    if (error)
      throw std::system_error(error);

    std::string line(input_buffer_.substr(0, n - 1));
    input_buffer_.erase(0, n);
    return line;
  }

  void write_line(const std::string& line,
      std::chrono::steady_clock::duration timeout)
  {
    std::string data = line + "\n";

    // Start the asynchronous operation itself. The lambda that is used as a
    // callback will update the error variable when the operation completes.
    // The blocking_udp_client.cpp example shows how you can use std::bind
    // rather than a lambda.
    std::error_code error;
    asio::async_write(socket_, asio::buffer(data),
        [&](const std::error_code& result_error,
            std::size_t /*result_n*/)
        {
          error = result_error;
        });

    // Run the operation until it completes, or until the timeout.
    run(timeout);

    // Determine whether the read completed successfully.
    if (error)
      throw std::system_error(error);
  }

private:
  void run(std::chrono::steady_clock::duration timeout)
  {
    // Restart the io_context, as it may have been left in the "stopped" state
    // by a previous operation.
    io_context_.restart();

    // Block until the asynchronous operation has completed, or timed out. If
    // the pending asynchronous operation is a composed operation, the deadline
    // applies to the entire operation, rather than individual operations on
    // the socket.
    io_context_.run_for(timeout);

    // If the asynchronous operation completed successfully then the io_context
    // would have been stopped due to running out of work. If it was not
    // stopped, then the io_context::run_for call must have timed out.
    if (!io_context_.stopped())
    {
      // Close the socket to cancel the outstanding asynchronous operation.
      socket_.close();

      // Run the io_context again until the operation completes.
      io_context_.run();
    }
  }

  asio::io_context io_context_;
  tcp::socket socket_{io_context_};
  std::string input_buffer_;
};

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 4)
    {
      std::cerr << "Usage: blocking_tcp_client <host> <port> <message>\n";
      return 1;
    }

    client c;
    c.connect(argv[1], argv[2], std::chrono::seconds(10));

    auto time_sent = std::chrono::steady_clock::now();

    c.write_line(argv[3], std::chrono::seconds(10));

    for (;;)
    {
      std::string line = c.read_line(std::chrono::seconds(10));

      // Keep going until we get back the line that was sent.
      if (line == argv[3])
        break;
    }

    auto time_received = std::chrono::steady_clock::now();

    std::cout << "Round trip time: ";
    std::cout << std::chrono::duration_cast<
      std::chrono::microseconds>(
        time_received - time_sent).count();
    std::cout << " microseconds\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\timeouts\blocking_token_tcp_client.cpp
//
// blocking_token_tcp_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/connect.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/read_until.hpp"
#include "asio/streambuf.hpp"
#include "asio/system_error.hpp"
#include "asio/write.hpp"
#include <cstdlib>
#include <iostream>
#include <memory>
#include <string>

using asio::ip::tcp;

// NOTE: This example uses the new form of the asio::async_result trait.
// For an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

// We will use our sockets only with an io_context.
using tcp_socket = asio::basic_stream_socket<
    tcp, asio::io_context::executor_type>;

//----------------------------------------------------------------------

// A custom completion token that makes asynchronous operations behave as
// though they are blocking calls with a timeout.
struct close_after
{
  close_after(std::chrono::steady_clock::duration t, tcp_socket& s)
    : timeout_(t), socket_(s)
  {
  }

  // The maximum time to wait for an asynchronous operation to complete.
  std::chrono::steady_clock::duration timeout_;

  // The socket to be closed if the operation does not complete in time.
  tcp_socket& socket_;
};

namespace asio {

// The async_result template is specialised to allow the close_after token to
// be used with asynchronous operations that have a completion signature of
// void(error_code, T). Generalising this for all completion signature forms is
// left as an exercise for the reader.
template <typename T>
class async_result<close_after, void(std::error_code, T)>
{
public:
  // The initiate() function is used to launch the asynchronous operation by
  // calling the operation's initiation function object. For the close_after
  // completion token, we use this function to run the io_context until the
  // operation is complete.
  template <typename Init, typename... Args>
  static T initiate(Init init, close_after token, Args&&... args)
  {
    asio::io_context& io_context = asio::query(
        token.socket_.get_executor(), asio::execution::context);

    // Call the operation's initiation function object to start the operation.
    // A lambda is supplied as the completion handler, to be called when the
    // operation completes.
    std::error_code error;
    T result;
    init([&](std::error_code e, T t)
        {
          error = e;
          result = t;
        }, std::forward<Args>(args)...);

    // Restart the io_context, as it may have been left in the "stopped" state
    // by a previous operation.
    io_context.restart();

    // Block until the asynchronous operation has completed, or timed out. If
    // the pending asynchronous operation is a composed operation, the deadline
    // applies to the entire operation, rather than individual operations on
    // the socket.
    io_context.run_for(token.timeout_);

    // If the asynchronous operation completed successfully then the io_context
    // would have been stopped due to running out of work. If it was not
    // stopped, then the io_context::run_for call must have timed out and the
    // operation is still incomplete.
    if (!io_context.stopped())
    {
      // Close the socket to cancel the outstanding asynchronous operation.
      token.socket_.close();

      // Run the io_context again until the operation completes.
      io_context.run();
    }

    // If the operation failed, throw an exception. Otherwise return the result.
    return error ? throw std::system_error(error) : result;
  }
};

} // namespace asio

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 4)
    {
      std::cerr << "Usage: blocking_tcp_client <host> <port> <message>\n";
      return 1;
    }

    asio::io_context io_context;

    // Resolve the host name and service to a list of endpoints.
    auto endpoints = tcp::resolver(io_context).resolve(argv[1], argv[2]);

    tcp_socket socket(io_context);

    // Run an asynchronous connect operation with a timeout.
    asio::async_connect(socket, endpoints,
        close_after(std::chrono::seconds(10), socket));

    auto time_sent = std::chrono::steady_clock::now();

    // Run an asynchronous write operation with a timeout.
    std::string msg = argv[3] + std::string("\n");
    asio::async_write(socket, asio::buffer(msg),
        close_after(std::chrono::seconds(10), socket));

    for (std::string input_buffer;;)
    {
      // Run an asynchronous read operation with a timeout.
      std::size_t n = asio::async_read_until(socket,
          asio::dynamic_buffer(input_buffer), '\n',
          close_after(std::chrono::seconds(10), socket));

      std::string line(input_buffer.substr(0, n - 1));
      input_buffer.erase(0, n);

      // Keep going until we get back the line that was sent.
      if (line == argv[3])
        break;
    }

    auto time_received = std::chrono::steady_clock::now();

    std::cout << "Round trip time: ";
    std::cout << std::chrono::duration_cast<
      std::chrono::microseconds>(
        time_received - time_sent).count();
    std::cout << " microseconds\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\timeouts\blocking_udp_client.cpp
//
// blocking_udp_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/buffer.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/udp.hpp"
#include <cstdlib>
#include <functional>
#include <iostream>

using asio::ip::udp;
using std::placeholders::_1;
using std::placeholders::_2;

//----------------------------------------------------------------------

//
// This class manages socket timeouts by running the io_context using the timed
// io_context::run_for() member function. Each asynchronous operation is given
// a timeout within which it must complete. The socket operations themselves
// use std::bind to specify the completion handler:
//
//   +---------------+
//   |               |
//   |    receive    |
//   |               |
//   +---------------+
//           |
//  async_-  |    +----------------+
// receive() |    |                |
//           +--->| handle_receive |
//                |                |
//                +----------------+
//
// For a given socket operation, the client object runs the io_context to block
// thread execution until the operation completes or the timeout is reached. If
// the io_context::run_for() function times out, the socket is closed and the
// outstanding asynchronous operation is cancelled.
//
class client
{
public:
  client(const udp::endpoint& listen_endpoint)
    : socket_(io_context_, listen_endpoint)
  {
  }

  std::size_t receive(const asio::mutable_buffer& buffer,
      std::chrono::steady_clock::duration timeout,
      std::error_code& error)
  {
    // Start the asynchronous operation. The handle_receive function used as a
    // callback will update the error and length variables.
    std::size_t length = 0;
    socket_.async_receive(asio::buffer(buffer),
        std::bind(&client::handle_receive, _1, _2, &error, &length));

    // Run the operation until it completes, or until the timeout.
    run(timeout);

    return length;
  }

private:
  void run(std::chrono::steady_clock::duration timeout)
  {
    // Restart the io_context, as it may have been left in the "stopped" state
    // by a previous operation.
    io_context_.restart();

    // Block until the asynchronous operation has completed, or timed out. If
    // the pending asynchronous operation is a composed operation, the deadline
    // applies to the entire operation, rather than individual operations on
    // the socket.
    io_context_.run_for(timeout);

    // If the asynchronous operation completed successfully then the io_context
    // would have been stopped due to running out of work. If it was not
    // stopped, then the io_context::run_for call must have timed out.
    if (!io_context_.stopped())
    {
      // Cancel the outstanding asynchronous operation.
      socket_.cancel();

      // Run the io_context again until the operation completes.
      io_context_.run();
    }
  }

  static void handle_receive(
      const std::error_code& error, std::size_t length,
      std::error_code* out_error, std::size_t* out_length)
  {
    *out_error = error;
    *out_length = length;
  }

private:
  asio::io_context io_context_;
  udp::socket socket_;
};

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    using namespace std; // For atoi.

    if (argc != 3)
    {
      std::cerr << "Usage: blocking_udp_client <listen_addr> <listen_port>\n";
      return 1;
    }

    udp::endpoint listen_endpoint(
        asio::ip::make_address(argv[1]),
        std::atoi(argv[2]));

    client c(listen_endpoint);

    for (;;)
    {
      char data[1024];
      std::error_code error;
      std::size_t n = c.receive(asio::buffer(data),
          std::chrono::seconds(10), error);

      if (error)
      {
        std::cout << "Receive error: " << error.message() << "\n"; 
      }
      else
      {
        std::cout << "Received: ";
        std::cout.write(data, n);
        std::cout << "\n";
      }
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\timeouts\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <algorithm>
#include <cstdlib>
#include <deque>
#include <iostream>
#include <memory>
#include <set>
#include <string>
#include "asio/buffer.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/ip/udp.hpp"
#include "asio/read_until.hpp"
#include "asio/steady_timer.hpp"
#include "asio/write.hpp"

using asio::steady_timer;
using asio::ip::tcp;
using asio::ip::udp;

//----------------------------------------------------------------------

class subscriber
{
public:
  virtual ~subscriber() = default;
  virtual void deliver(const std::string& msg) = 0;
};

typedef std::shared_ptr<subscriber> subscriber_ptr;

//----------------------------------------------------------------------

class channel
{
public:
  void join(subscriber_ptr subscriber)
  {
    subscribers_.insert(subscriber);
  }

  void leave(subscriber_ptr subscriber)
  {
    subscribers_.erase(subscriber);
  }

  void deliver(const std::string& msg)
  {
    for (const auto& s : subscribers_)
    {
      s->deliver(msg);
    }
  }

private:
  std::set<subscriber_ptr> subscribers_;
};

//----------------------------------------------------------------------

//
// This class manages socket timeouts by applying the concept of a deadline.
// Some asynchronous operations are given deadlines by which they must complete.
// Deadlines are enforced by two "actors" that persist for the lifetime of the
// session object, one for input and one for output:
//
//  +----------------+                      +----------------+
//  |                |                      |                |
//  | check_deadline |<-------+             | check_deadline |<-------+
//  |                |        |             |                |        |
//  +----------------+        |             +----------------+        |
//               |            |                          |            |
//  async_wait() |    +----------------+    async_wait() |    +----------------+
//   on input    |    |     lambda     |     on output   |    |     lambda     |
//   deadline    +--->|       in       |     deadline    +--->|       in       |
//                    | check_deadline |                      | check_deadline |
//                    +----------------+                      +----------------+
//
// If either deadline actor determines that the corresponding deadline has
// expired, the socket is closed and any outstanding operations are cancelled.
//
// The input actor reads messages from the socket, where messages are delimited
// by the newline character:
//
//  +-------------+
//  |             |
//  |  read_line  |<----+
//  |             |     |
//  +-------------+     |
//          |           |
//  async_- |    +-------------+
//   read_- |    |   lambda    |
//  until() +--->|     in      |
//               |  read_line  |
//               +-------------+
//
// The deadline for receiving a complete message is 30 seconds. If a non-empty
// message is received, it is delivered to all subscribers. If a heartbeat (a
// message that consists of a single newline character) is received, a heartbeat
// is enqueued for the client, provided there are no other messages waiting to
// be sent.
//
// The output actor is responsible for sending messages to the client:
//
//  +----------------+
//  |                |<---------------------+
//  |  await_output  |                      |
//  |                |<-------+             |
//  +----------------+        |             |
//    |            |          |             |
//    |    async_- |  +----------------+    |
//    |     wait() |  |     lambda     |    |
//    |            +->|       in       |    |
//    |               |  await_output  |    |
//    |               +----------------+    |
//    V                                     |
//  +--------------+               +--------------+
//  |              | async_write() |    lambda    |
//  |  write_line  |-------------->|      in      |
//  |              |               |  write_line  |
//  +--------------+               +--------------+
//
// The output actor first waits for an output message to be enqueued. It does
// this by using a steady_timer as an asynchronous condition variable. The
// steady_timer will be signalled whenever the output queue is non-empty.
//
// Once a message is available, it is sent to the client. The deadline for
// sending a complete message is 30 seconds. After the message is successfully
// sent, the output actor again waits for the output queue to become non-empty.
//
class tcp_session
  : public subscriber,
    public std::enable_shared_from_this<tcp_session>
{
public:
  tcp_session(tcp::socket socket, channel& ch)
    : channel_(ch),
      socket_(std::move(socket))
  {
    input_deadline_.expires_at(steady_timer::time_point::max());
    output_deadline_.expires_at(steady_timer::time_point::max());

    // The non_empty_output_queue_ steady_timer is set to the maximum time
    // point whenever the output queue is empty. This ensures that the output
    // actor stays asleep until a message is put into the queue.
    non_empty_output_queue_.expires_at(steady_timer::time_point::max());
  }

  // Called by the server object to initiate the four actors.
  void start()
  {
    channel_.join(shared_from_this());

    read_line();
    check_deadline(input_deadline_);

    await_output();
    check_deadline(output_deadline_);
  }

private:
  void stop()
  {
    channel_.leave(shared_from_this());

    std::error_code ignored_error;
    socket_.close(ignored_error);
    input_deadline_.cancel();
    non_empty_output_queue_.cancel();
    output_deadline_.cancel();
  }

  bool stopped() const
  {
    return !socket_.is_open();
  }

  void deliver(const std::string& msg) override
  {
    output_queue_.push_back(msg + "\n");

    // Signal that the output queue contains messages. Modifying the expiry
    // will wake the output actor, if it is waiting on the timer.
    non_empty_output_queue_.expires_at(steady_timer::time_point::min());
  }

  void read_line()
  {
    // Set a deadline for the read operation.
    input_deadline_.expires_after(std::chrono::seconds(30));

    // Start an asynchronous operation to read a newline-delimited message.
    auto self(shared_from_this());
    asio::async_read_until(socket_,
        asio::dynamic_buffer(input_buffer_), '\n',
        [this, self](const std::error_code& error, std::size_t n)
        {
          // Check if the session was stopped while the operation was pending.
          if (stopped())
            return;

          if (!error)
          {
            // Extract the newline-delimited message from the buffer.
            std::string msg(input_buffer_.substr(0, n - 1));
            input_buffer_.erase(0, n);

            if (!msg.empty())
            {
              channel_.deliver(msg);
            }
            else
            {

              // We received a heartbeat message from the client. If there's
              // nothing else being sent or ready to be sent, send a heartbeat
              // right back.
              if (output_queue_.empty())
              {
                output_queue_.push_back("\n");

                // Signal that the output queue contains messages. Modifying
                // the expiry will wake the output actor, if it is waiting on
                // the timer.
                non_empty_output_queue_.expires_at(
                    steady_timer::time_point::min());
              }
            }

            read_line();
          }
          else
          {
            stop();
          }
        });
  }

  void await_output()
  {
    auto self(shared_from_this());
    non_empty_output_queue_.async_wait(
        [this, self](const std::error_code& /*error*/)
        {
          // Check if the session was stopped while the operation was pending.
          if (stopped())
            return;

          if (output_queue_.empty())
          {
            // There are no messages that are ready to be sent. The actor goes
            // to sleep by waiting on the non_empty_output_queue_ timer. When a
            // new message is added, the timer will be modified and the actor
            // will wake.
            non_empty_output_queue_.expires_at(steady_timer::time_point::max());
            await_output();
          }
          else
          {
            write_line();
          }
        });
  }

  void write_line()
  {
    // Set a deadline for the write operation.
    output_deadline_.expires_after(std::chrono::seconds(30));

    // Start an asynchronous operation to send a message.
    auto self(shared_from_this());
    asio::async_write(socket_,
        asio::buffer(output_queue_.front()),
        [this, self](const std::error_code& error, std::size_t /*n*/)
        {
          // Check if the session was stopped while the operation was pending.
          if (stopped())
            return;

          if (!error)
          {
            output_queue_.pop_front();

            await_output();
          }
          else
          {
            stop();
          }
        });
  }

  void check_deadline(steady_timer& deadline)
  {
    auto self(shared_from_this());
    deadline.async_wait(
        [this, self, &deadline](const std::error_code& /*error*/)
        {
          // Check if the session was stopped while the operation was pending.
          if (stopped())
            return;

          // Check whether the deadline has passed. We compare the deadline
          // against the current time since a new asynchronous operation may
          // have moved the deadline before this actor had a chance to run.
          if (deadline.expiry() <= steady_timer::clock_type::now())
          {
            // The deadline has passed. Stop the session. The other actors will
            // terminate as soon as possible.
            stop();
          }
          else
          {
            // Put the actor back to sleep.
            check_deadline(deadline);
          }
        });
  }

  channel& channel_;
  tcp::socket socket_;
  std::string input_buffer_;
  steady_timer input_deadline_{socket_.get_executor()};
  std::deque<std::string> output_queue_;
  steady_timer non_empty_output_queue_{socket_.get_executor()};
  steady_timer output_deadline_{socket_.get_executor()};
};

typedef std::shared_ptr<tcp_session> tcp_session_ptr;

//----------------------------------------------------------------------

class udp_broadcaster
  : public subscriber
{
public:
  udp_broadcaster(asio::io_context& io_context,
      const udp::endpoint& broadcast_endpoint)
    : socket_(io_context)
  {
    socket_.connect(broadcast_endpoint);
    socket_.set_option(udp::socket::broadcast(true));
  }

private:
  void deliver(const std::string& msg)
  {
    std::error_code ignored_error;
    socket_.send(asio::buffer(msg), 0, ignored_error);
  }

  udp::socket socket_;
};

//----------------------------------------------------------------------

class server
{
public:
  server(asio::io_context& io_context,
      const tcp::endpoint& listen_endpoint,
      const udp::endpoint& broadcast_endpoint)
    : io_context_(io_context),
      acceptor_(io_context, listen_endpoint)
  {
    channel_.join(
        std::make_shared<udp_broadcaster>(
          io_context_, broadcast_endpoint));

    accept();
  }

private:
  void accept()
  {
    acceptor_.async_accept(
        [this](const std::error_code& error, tcp::socket socket)
        {
          if (!error)
          {
            std::make_shared<tcp_session>(std::move(socket), channel_)->start();
          }

          accept();
        });
  }

  asio::io_context& io_context_;
  tcp::acceptor acceptor_;
  channel channel_;
};

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    using namespace std; // For atoi.

    if (argc != 4)
    {
      std::cerr << "Usage: server <listen_port> <bcast_address> <bcast_port>\n";
      return 1;
    }

    asio::io_context io_context;

    tcp::endpoint listen_endpoint(tcp::v4(), atoi(argv[1]));

    udp::endpoint broadcast_endpoint(
        asio::ip::make_address(argv[2]), atoi(argv[3]));

    server s(io_context, listen_endpoint, broadcast_endpoint);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\timers\time_t_timer.cpp
//
// time_t_timer.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <ctime>
#include <chrono>
#include <iostream>

// A custom implementation of the Clock concept from the standard C++ library.
struct time_t_clock
{
  // The duration type.
  typedef std::chrono::steady_clock::duration duration;

  // The duration's underlying arithmetic representation.
  typedef duration::rep rep;

  // The ratio representing the duration's tick period.
  typedef duration::period period;

  // An absolute time point represented using the clock.
  typedef std::chrono::time_point<time_t_clock> time_point;

  // The clock is not monotonically increasing.
  static constexpr bool is_steady = false;

  // Get the current time.
  static time_point now() noexcept
  {
    return time_point() + std::chrono::seconds(std::time(0));
  }
};

// The asio::basic_waitable_timer template accepts an optional WaitTraits
// template parameter. The underlying time_t clock has one-second granularity,
// so these traits may be customised to reduce the latency between the clock
// ticking over and a wait operation's completion. When the timeout is near
// (less than one second away) we poll the clock more frequently to detect the
// time change closer to when it occurs. The user can select the appropriate
// trade off between accuracy and the increased CPU cost of polling. In extreme
// cases, a zero duration may be returned to make the timers as accurate as
// possible, albeit with 100% CPU usage.
struct time_t_wait_traits
{
  // Determine how long until the clock should be next polled to determine
  // whether the duration has elapsed.
  static time_t_clock::duration to_wait_duration(
      const time_t_clock::duration& d)
  {
    if (d > std::chrono::seconds(1))
      return d - std::chrono::seconds(1);
    else if (d > std::chrono::seconds(0))
      return std::chrono::milliseconds(10);
    else
      return std::chrono::seconds(0);
  }

  // Determine how long until the clock should be next polled to determine
  // whether the absoluate time has been reached.
  static time_t_clock::duration to_wait_duration(
      const time_t_clock::time_point& t)
  {
    return to_wait_duration(t - time_t_clock::now());
  }
};

typedef asio::basic_waitable_timer<
  time_t_clock, time_t_wait_traits> time_t_timer;

int main()
{
  try
  {
    asio::io_context io_context;

    time_t_timer timer(io_context);

    timer.expires_after(std::chrono::seconds(5));
    std::cout << "Starting synchronous wait\n";
    timer.wait();
    std::cout << "Finished synchronous wait\n";

    timer.expires_after(std::chrono::seconds(5));
    std::cout << "Starting asynchronous wait\n";
    timer.async_wait(
        [](const std::error_code& /*error*/)
        {
          std::cout << "timeout\n";
        });
    io_context.run();
    std::cout << "Finished asynchronous wait\n";
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime1\client.cpp
//
// client.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <iostream>
#include <asio.hpp>

using asio::ip::tcp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: client <host>" << std::endl;
      return 1;
    }

    asio::io_context io_context;

    tcp::resolver resolver(io_context);
    tcp::resolver::results_type endpoints =
      resolver.resolve(argv[1], "daytime");

    tcp::socket socket(io_context);
    asio::connect(socket, endpoints);

    for (;;)
    {
      std::array<char, 128> buf;
      std::error_code error;

      size_t len = socket.read_some(asio::buffer(buf), error);

      if (error == asio::error::eof)
        break; // Connection closed cleanly by peer.
      else if (error)
        throw std::system_error(error); // Some other error.

      std::cout.write(buf.data(), len);
    }
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime2\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <ctime>
#include <iostream>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;

std::string make_daytime_string()
{
  using namespace std; // For time_t, time and ctime;
  time_t now = time(0);
  return ctime(&now);
}

int main()
{
  try
  {
    asio::io_context io_context;

    tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 13));

    for (;;)
    {
      tcp::socket socket(io_context);
      acceptor.accept(socket);

      std::string message = make_daytime_string();

      std::error_code ignored_error;
      asio::write(socket, asio::buffer(message), ignored_error);
    }
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime3\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <ctime>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;

std::string make_daytime_string()
{
  using namespace std; // For time_t, time and ctime;
  time_t now = time(0);
  return ctime(&now);
}

class tcp_connection
  : public std::enable_shared_from_this<tcp_connection>
{
public:
  typedef std::shared_ptr<tcp_connection> pointer;

  static pointer create(asio::io_context& io_context)
  {
    return pointer(new tcp_connection(io_context));
  }

  tcp::socket& socket()
  {
    return socket_;
  }

  void start()
  {
    message_ = make_daytime_string();

    asio::async_write(socket_, asio::buffer(message_),
        std::bind(&tcp_connection::handle_write, shared_from_this(),
          asio::placeholders::error,
          asio::placeholders::bytes_transferred));
  }

private:
  tcp_connection(asio::io_context& io_context)
    : socket_(io_context)
  {
  }

  void handle_write(const std::error_code& /*error*/,
      size_t /*bytes_transferred*/)
  {
  }

  tcp::socket socket_;
  std::string message_;
};

class tcp_server
{
public:
  tcp_server(asio::io_context& io_context)
    : io_context_(io_context),
      acceptor_(io_context, tcp::endpoint(tcp::v4(), 13))
  {
    start_accept();
  }

private:
  void start_accept()
  {
    tcp_connection::pointer new_connection =
      tcp_connection::create(io_context_);

    acceptor_.async_accept(new_connection->socket(),
        std::bind(&tcp_server::handle_accept, this, new_connection,
          asio::placeholders::error));
  }

  void handle_accept(tcp_connection::pointer new_connection,
      const std::error_code& error)
  {
    if (!error)
    {
      new_connection->start();
    }

    start_accept();
  }

  asio::io_context& io_context_;
  tcp::acceptor acceptor_;
};

int main()
{
  try
  {
    asio::io_context io_context;
    tcp_server server(io_context);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime4\client.cpp
//
// client.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <iostream>
#include <asio.hpp>

using asio::ip::udp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: client <host>" << std::endl;
      return 1;
    }

    asio::io_context io_context;

    udp::resolver resolver(io_context);
    udp::endpoint receiver_endpoint =
      *resolver.resolve(udp::v4(), argv[1], "daytime").begin();

    udp::socket socket(io_context);
    socket.open(udp::v4());

    std::array<char, 1> send_buf  = {{ 0 }};
    socket.send_to(asio::buffer(send_buf), receiver_endpoint);

    std::array<char, 128> recv_buf;
    udp::endpoint sender_endpoint;
    size_t len = socket.receive_from(
        asio::buffer(recv_buf), sender_endpoint);

    std::cout.write(recv_buf.data(), len);
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime5\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <ctime>
#include <iostream>
#include <string>
#include <asio.hpp>

using asio::ip::udp;

std::string make_daytime_string()
{
  using namespace std; // For time_t, time and ctime;
  time_t now = time(0);
  return ctime(&now);
}

int main()
{
  try
  {
    asio::io_context io_context;

    udp::socket socket(io_context, udp::endpoint(udp::v4(), 13));

    for (;;)
    {
      std::array<char, 1> recv_buf;
      udp::endpoint remote_endpoint;
      socket.receive_from(asio::buffer(recv_buf), remote_endpoint);

      std::string message = make_daytime_string();

      std::error_code ignored_error;
      socket.send_to(asio::buffer(message),
          remote_endpoint, 0, ignored_error);
    }
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime6\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <ctime>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <asio.hpp>

using asio::ip::udp;

std::string make_daytime_string()
{
  using namespace std; // For time_t, time and ctime;
  time_t now = time(0);
  return ctime(&now);
}

class udp_server
{
public:
  udp_server(asio::io_context& io_context)
    : socket_(io_context, udp::endpoint(udp::v4(), 13))
  {
    start_receive();
  }

private:
  void start_receive()
  {
    socket_.async_receive_from(
        asio::buffer(recv_buffer_), remote_endpoint_,
        std::bind(&udp_server::handle_receive, this,
          asio::placeholders::error,
          asio::placeholders::bytes_transferred));
  }

  void handle_receive(const std::error_code& error,
      std::size_t /*bytes_transferred*/)
  {
    if (!error)
    {
      std::shared_ptr<std::string> message(
          new std::string(make_daytime_string()));

      socket_.async_send_to(asio::buffer(*message), remote_endpoint_,
          std::bind(&udp_server::handle_send, this, message,
            asio::placeholders::error,
            asio::placeholders::bytes_transferred));

      start_receive();
    }
  }

  void handle_send(std::shared_ptr<std::string> /*message*/,
      const std::error_code& /*error*/,
      std::size_t /*bytes_transferred*/)
  {
  }

  udp::socket socket_;
  udp::endpoint remote_endpoint_;
  std::array<char, 1> recv_buffer_;
};

int main()
{
  try
  {
    asio::io_context io_context;
    udp_server server(io_context);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\daytime7\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <array>
#include <ctime>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <asio.hpp>

using asio::ip::tcp;
using asio::ip::udp;

std::string make_daytime_string()
{
  using namespace std; // For time_t, time and ctime;
  time_t now = time(0);
  return ctime(&now);
}

class tcp_connection
  : public std::enable_shared_from_this<tcp_connection>
{
public:
  typedef std::shared_ptr<tcp_connection> pointer;

  static pointer create(asio::io_context& io_context)
  {
    return pointer(new tcp_connection(io_context));
  }

  tcp::socket& socket()
  {
    return socket_;
  }

  void start()
  {
    message_ = make_daytime_string();

    asio::async_write(socket_, asio::buffer(message_),
        std::bind(&tcp_connection::handle_write, shared_from_this()));
  }

private:
  tcp_connection(asio::io_context& io_context)
    : socket_(io_context)
  {
  }

  void handle_write()
  {
  }

  tcp::socket socket_;
  std::string message_;
};

class tcp_server
{
public:
  tcp_server(asio::io_context& io_context)
    : io_context_(io_context),
      acceptor_(io_context, tcp::endpoint(tcp::v4(), 13))
  {
    start_accept();
  }

private:
  void start_accept()
  {
    tcp_connection::pointer new_connection =
      tcp_connection::create(io_context_);

    acceptor_.async_accept(new_connection->socket(),
        std::bind(&tcp_server::handle_accept, this, new_connection,
          asio::placeholders::error));
  }

  void handle_accept(tcp_connection::pointer new_connection,
      const std::error_code& error)
  {
    if (!error)
    {
      new_connection->start();
    }

    start_accept();
  }

  asio::io_context& io_context_;
  tcp::acceptor acceptor_;
};

class udp_server
{
public:
  udp_server(asio::io_context& io_context)
    : socket_(io_context, udp::endpoint(udp::v4(), 13))
  {
    start_receive();
  }

private:
  void start_receive()
  {
    socket_.async_receive_from(
        asio::buffer(recv_buffer_), remote_endpoint_,
        std::bind(&udp_server::handle_receive, this,
          asio::placeholders::error));
  }

  void handle_receive(const std::error_code& error)
  {
    if (!error)
    {
      std::shared_ptr<std::string> message(
          new std::string(make_daytime_string()));

      socket_.async_send_to(asio::buffer(*message), remote_endpoint_,
          std::bind(&udp_server::handle_send, this, message));

      start_receive();
    }
  }

  void handle_send(std::shared_ptr<std::string> /*message*/)
  {
  }

  udp::socket socket_;
  udp::endpoint remote_endpoint_;
  std::array<char, 1> recv_buffer_;
};

int main()
{
  try
  {
    asio::io_context io_context;
    tcp_server server1(io_context);
    udp_server server2(io_context);
    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\timer1\timer.cpp
//
// timer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <asio.hpp>

int main()
{
  asio::io_context io;

  asio::steady_timer t(io, asio::chrono::seconds(5));
  t.wait();

  std::cout << "Hello, world!" << std::endl;

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\timer2\timer.cpp
//
// timer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <asio.hpp>

void print(const std::error_code& /*e*/)
{
  std::cout << "Hello, world!" << std::endl;
}

int main()
{
  asio::io_context io;

  asio::steady_timer t(io, asio::chrono::seconds(5));
  t.async_wait(&print);

  io.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\timer3\timer.cpp
//
// timer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <functional>
#include <iostream>
#include <asio.hpp>

void print(const std::error_code& /*e*/,
    asio::steady_timer* t, int* count)
{
  if (*count < 5)
  {
    std::cout << *count << std::endl;
    ++(*count);

    t->expires_at(t->expiry() + asio::chrono::seconds(1));
    t->async_wait(std::bind(print,
          asio::placeholders::error, t, count));
  }
}

int main()
{
  asio::io_context io;

  int count = 0;
  asio::steady_timer t(io, asio::chrono::seconds(1));
  t.async_wait(std::bind(print,
        asio::placeholders::error, &t, &count));

  io.run();

  std::cout << "Final count is " << count << std::endl;

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\timer4\timer.cpp
//
// timer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <functional>
#include <iostream>
#include <asio.hpp>

class printer
{
public:
  printer(asio::io_context& io)
    : timer_(io, asio::chrono::seconds(1)),
      count_(0)
  {
    timer_.async_wait(std::bind(&printer::print, this));
  }

  ~printer()
  {
    std::cout << "Final count is " << count_ << std::endl;
  }

  void print()
  {
    if (count_ < 5)
    {
      std::cout << count_ << std::endl;
      ++count_;

      timer_.expires_at(timer_.expiry() + asio::chrono::seconds(1));
      timer_.async_wait(std::bind(&printer::print, this));
    }
  }

private:
  asio::steady_timer timer_;
  int count_;
};

int main()
{
  asio::io_context io;
  printer p(io);
  io.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\tutorial\timer5\timer.cpp
//
// timer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <functional>
#include <iostream>
#include <thread>
#include <asio.hpp>

class printer
{
public:
  printer(asio::io_context& io)
    : strand_(asio::make_strand(io)),
      timer1_(io, asio::chrono::seconds(1)),
      timer2_(io, asio::chrono::seconds(1)),
      count_(0)
  {
    timer1_.async_wait(asio::bind_executor(strand_,
          std::bind(&printer::print1, this)));

    timer2_.async_wait(asio::bind_executor(strand_,
          std::bind(&printer::print2, this)));
  }

  ~printer()
  {
    std::cout << "Final count is " << count_ << std::endl;
  }

  void print1()
  {
    if (count_ < 10)
    {
      std::cout << "Timer 1: " << count_ << std::endl;
      ++count_;

      timer1_.expires_at(timer1_.expiry() + asio::chrono::seconds(1));

      timer1_.async_wait(asio::bind_executor(strand_,
            std::bind(&printer::print1, this)));
    }
  }

  void print2()
  {
    if (count_ < 10)
    {
      std::cout << "Timer 2: " << count_ << std::endl;
      ++count_;

      timer2_.expires_at(timer2_.expiry() + asio::chrono::seconds(1));

      timer2_.async_wait(asio::bind_executor(strand_,
            std::bind(&printer::print2, this)));
    }
  }

private:
  asio::strand<asio::io_context::executor_type> strand_;
  asio::steady_timer timer1_;
  asio::steady_timer timer2_;
  int count_;
};

int main()
{
  asio::io_context io;
  printer p(io);
  std::thread t([&]{ io.run(); });
  io.run();
  t.join();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\type_erasure\main.cpp
//
// main.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "line_reader.hpp"
#include "sleep.hpp"
#include "stdin_line_reader.hpp"
#include <asio/coroutine.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/use_awaitable.hpp>
#include <iostream>

#include <asio/yield.hpp>

class read_loop : asio::coroutine
{
public:
  read_loop(asio::any_io_executor e, line_reader& r)
    : executor(std::move(e)),
      reader(r)
  {
  }

  void operator()(std::error_code ec = {}, std::string line = {})
  {
    reenter (this)
    {
      for (i = 0; i < 10; ++i)
      {
        yield reader.async_read_line("Enter something: ", *this);
        if (ec) break;
        std::cout << line;
        yield async_sleep(executor, std::chrono::seconds(1), *this);
        if (ec) break;
      }
    }
  }

private:
  asio::any_io_executor executor;
  line_reader& reader;
  int i;
};

#include <asio/unyield.hpp>

int main()
{
  asio::io_context ctx{1};
  stdin_line_reader reader{ctx.get_executor()};
  read_loop(ctx.get_executor(), reader)();
  ctx.run();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\type_erasure\sleep.cpp
//
// sleep.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "sleep.hpp"
#include <asio/consign.hpp>
#include <asio/steady_timer.hpp>
#include <memory>

void async_sleep_impl(
    asio::any_completion_handler<void(std::error_code)> handler,
    asio::any_io_executor ex, std::chrono::nanoseconds duration)
{
  auto timer = std::make_shared<asio::steady_timer>(ex, duration);
  timer->async_wait(asio::consign(std::move(handler), timer));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\type_erasure\stdin_line_reader.cpp
//
// stdin_line_reader.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "stdin_line_reader.hpp"
#include <asio/deferred.hpp>
#include <asio/read_until.hpp>
#include <iostream>

stdin_line_reader::stdin_line_reader(asio::any_io_executor ex)
  : stdin_(ex, ::dup(STDIN_FILENO))
{
}

void stdin_line_reader::async_read_line_impl(std::string prompt,
    asio::any_completion_handler<void(std::error_code, std::string)> handler)
{
  std::cout << prompt;
  std::cout.flush();

  asio::async_read_until(stdin_, asio::dynamic_buffer(buffer_), '\n',
      asio::deferred(
        [this](std::error_code ec, std::size_t n)
        {
          if (!ec)
          {
            std::string result = buffer_.substr(0, n);
            buffer_.erase(0, n);
            return asio::deferred.values(ec, std::move(result));
          }
          else
          {
            return asio::deferred.values(ec, std::string{});
          }
        }
      )
    )(std::move(handler));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp11\windows\transmit_file.cpp
//
// transmit_file.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <ctime>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include "asio.hpp"

#if defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)

using asio::ip::tcp;
using asio::windows::overlapped_ptr;
using asio::windows::random_access_handle;

typedef asio::basic_stream_socket<tcp,
    asio::io_context::executor_type> tcp_socket;

typedef asio::basic_socket_acceptor<tcp,
    asio::io_context::executor_type> tcp_acceptor;

// A wrapper for the TransmitFile overlapped I/O operation.
template <typename Handler>
void transmit_file(tcp_socket& socket,
    random_access_handle& file, Handler handler)
{
  // Construct an OVERLAPPED-derived object to contain the handler.
  overlapped_ptr overlapped(socket.get_executor().context(), handler);

  // Initiate the TransmitFile operation.
  BOOL ok = ::TransmitFile(socket.native_handle(),
      file.native_handle(), 0, 0, overlapped.get(), 0, 0);
  DWORD last_error = ::GetLastError();

  // Check if the operation completed immediately.
  if (!ok && last_error != ERROR_IO_PENDING)
  {
    // The operation completed immediately, so a completion notification needs
    // to be posted. When complete() is called, ownership of the OVERLAPPED-
    // derived object passes to the io_context.
    std::error_code ec(last_error,
        asio::error::get_system_category());
    overlapped.complete(ec, 0);
  }
  else
  {
    // The operation was successfully initiated, so ownership of the
    // OVERLAPPED-derived object has passed to the io_context.
    overlapped.release();
  }
}

class connection
  : public std::enable_shared_from_this<connection>
{
public:
  typedef std::shared_ptr<connection> pointer;

  static pointer create(asio::io_context& io_context,
      const std::string& filename)
  {
    return pointer(new connection(io_context, filename));
  }

  tcp_socket& socket()
  {
    return socket_;
  }

  void start()
  {
    std::error_code ec;
    file_.assign(::CreateFile(filename_.c_str(), GENERIC_READ, 0, 0,
          OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, 0), ec);
    if (file_.is_open())
    {
      transmit_file(socket_, file_,
          std::bind(&connection::handle_write, shared_from_this(),
            asio::placeholders::error,
            asio::placeholders::bytes_transferred));
    }
  }

private:
  connection(asio::io_context& io_context, const std::string& filename)
    : socket_(io_context),
      filename_(filename),
      file_(io_context)
  {
  }

  void handle_write(const std::error_code& /*error*/,
      size_t /*bytes_transferred*/)
  {
    std::error_code ignored_ec;
    socket_.shutdown(tcp_socket::shutdown_both, ignored_ec);
  }

  tcp_socket socket_;
  std::string filename_;
  random_access_handle file_;
};

class server
{
public:
  server(asio::io_context& io_context,
      unsigned short port, const std::string& filename)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),
      filename_(filename)
  {
    start_accept();
  }

private:
  void start_accept()
  {
    connection::pointer new_connection =
      connection::create(acceptor_.get_executor().context(), filename_);

    acceptor_.async_accept(new_connection->socket(),
        std::bind(&server::handle_accept, this, new_connection,
          asio::placeholders::error));
  }

  void handle_accept(connection::pointer new_connection,
      const std::error_code& error)
  {
    if (!error)
    {
      new_connection->start();
    }

    start_accept();
  }

  tcp_acceptor acceptor_;
  std::string filename_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: transmit_file <port> <filename>\n";
      return 1;
    }

    asio::io_context io_context;

    using namespace std; // For atoi.
    server s(io_context, atoi(argv[1]), argv[2]);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << e.what() << std::endl;
  }

  return 0;
}

#else // defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)
# error Overlapped I/O not available on this platform
#endif // defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_1.cpp
//
// deferred_1.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  auto deferred_op = timer.async_wait(deferred);

  std::move(deferred_op)(
      [](std::error_code ec)
      {
        std::cout << "timer wait finished: " << ec.message() << "\n";
      }
    );

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_2.cpp
//
// deferred_2.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  auto deferred_op = timer.async_wait(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer.expires_after(std::chrono::seconds(1));
          return timer.async_wait(deferred);
        }
      )
    );

  std::move(deferred_op)(
      [](std::error_code ec)
      {
        std::cout << "second timer wait finished: " << ec.message() << "\n";
      }
    );

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_3.cpp
//
// deferred_3.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

template <typename CompletionToken>
auto async_wait_twice(asio::steady_timer& timer, CompletionToken&& token)
{
  return timer.async_wait(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer.expires_after(std::chrono::seconds(1));
          return timer.async_wait(deferred);
        }
      )
    )(
      std::forward<CompletionToken>(token)
    );
}

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  async_wait_twice(
      timer,
      [](std::error_code ec)
      {
        std::cout << "second timer wait finished: " << ec.message() << "\n";
      }
    );

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_4.cpp
//
// deferred_4.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

template <typename CompletionToken>
auto async_wait_twice(asio::steady_timer& timer, CompletionToken&& token)
{
  return timer.async_wait(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer.expires_after(std::chrono::seconds(1));
          return timer.async_wait(deferred);
        }
      )
    )(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "second timer wait finished: " << ec.message() << "\n";
          return deferred.values(42);
        }
      )
    )(
      std::forward<CompletionToken>(token)
    );
}

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  async_wait_twice(
      timer,
      [](int result)
      {
        std::cout << "result is " << result << "\n";
      }
    );

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_5.cpp
//
// deferred_5.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::deferred;

template <typename CompletionToken>
auto async_wait_twice(asio::steady_timer& timer, CompletionToken&& token)
{
  return timer.async_wait(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer.expires_after(std::chrono::seconds(1));
          return deferred.when(!ec)
            .then(timer.async_wait(deferred))
            .otherwise(deferred.values(ec));
        }
      )
    )(
      deferred(
        [&](std::error_code ec)
        {
          std::cout << "second timer wait finished: " << ec.message() << "\n";
          return deferred.when(!ec)
            .then(deferred.values(42))
            .otherwise(deferred.values(0));
        }
      )
    )(
      std::forward<CompletionToken>(token)
    );
}

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  async_wait_twice(
      timer,
      [](int result)
      {
        std::cout << "result is " << result << "\n";
      }
    );

  // Uncomment the following line to trigger an error in async_wait_twice.
  //timer.cancel();

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_6.cpp
//
// deferred_6.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::append;
using asio::deferred;

template <typename CompletionToken>
auto async_wait_twice(asio::steady_timer& timer, CompletionToken&& token)
{
  return deferred.values(&timer)(
      deferred(
        [](asio::steady_timer* timer)
        {
          timer->expires_after(std::chrono::seconds(1));
          return timer->async_wait(append(deferred, timer));
        }
      )
    )(
      deferred(
        [](std::error_code ec, asio::steady_timer* timer)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer->expires_after(std::chrono::seconds(1));
          return deferred.when(!ec)
            .then(timer->async_wait(deferred))
            .otherwise(deferred.values(ec));
        }
      )
    )(
      deferred(
        [](std::error_code ec)
        {
          std::cout << "second timer wait finished: " << ec.message() << "\n";
          return deferred.when(!ec)
            .then(deferred.values(42))
            .otherwise(deferred.values(0));
        }
      )
    )(
      std::forward<CompletionToken>(token)
    );
}

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  async_wait_twice(
      timer,
      [](int result)
      {
        std::cout << "result is " << result << "\n";
      }
    );

  // Uncomment the following line to trigger an error in async_wait_twice.
  //timer.cancel();

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\deferred\deferred_7.cpp
//
// deferred_7.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

using asio::append;
using asio::deferred;

template <typename CompletionToken>
auto async_wait_twice(asio::steady_timer& timer, CompletionToken&& token)
{
  return deferred.values(&timer)
    | deferred(
        [](asio::steady_timer* timer)
        {
          timer->expires_after(std::chrono::seconds(1));
          return timer->async_wait(append(deferred, timer));
        }
      )
    | deferred(
        [](std::error_code ec, asio::steady_timer* timer)
        {
          std::cout << "first timer wait finished: " << ec.message() << "\n";
          timer->expires_after(std::chrono::seconds(1));
          return deferred.when(!ec)
            .then(timer->async_wait(deferred))
            .otherwise(deferred.values(ec));
        }
      )
    | deferred(
        [](std::error_code ec)
        {
          std::cout << "second timer wait finished: " << ec.message() << "\n";
          return deferred.when(!ec)
            .then(deferred.values(42))
            .otherwise(deferred.values(0));
        }
      )
    | std::forward<CompletionToken>(token);
}

int main()
{
  asio::io_context ctx;

  asio::steady_timer timer(ctx);
  timer.expires_after(std::chrono::seconds(1));

  async_wait_twice(
      timer,
      [](int result)
      {
        std::cout << "result is " << result << "\n";
      }
    );

  // Uncomment the following line to trigger an error in async_wait_twice.
  //timer.cancel();

  ctx.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\echo\async_tcp_echo_server.cpp
//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <memory>
#include <utility>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

using asio::ip::tcp;

class session
  : public std::enable_shared_from_this<session>
{
public:
  session(tcp::socket socket)
    : socket_(std::move(socket))
  {
  }

  void start()
  {
    do_read();
  }

private:
  void do_read()
  {
    auto self(shared_from_this());
    socket_.async_read_some(asio::buffer(data_, max_length),
        [this, self](std::error_code ec, std::size_t length)
        {
          if (!ec)
          {
            do_write(length);
          }
        });
  }

  void do_write(std::size_t length)
  {
    auto self(shared_from_this());
    asio::async_write(socket_, asio::buffer(data_, length),
        [this, self](std::error_code ec, std::size_t /*length*/)
        {
          if (!ec)
          {
            do_read();
          }
        });
  }

  tcp::socket socket_;
  enum { max_length = 1024 };
  char data_[max_length];
};

class server
{
public:
  server(asio::io_context& io_context, short port)
    : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)),
      socket_(io_context)
  {
    do_accept();
  }

private:
  void do_accept()
  {
    acceptor_.async_accept(socket_,
        [this](std::error_code ec)
        {
          if (!ec)
          {
            std::make_shared<session>(std::move(socket_))->start();
          }

          do_accept();
        });
  }

  tcp::acceptor acceptor_;
  tcp::socket socket_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_tcp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\echo\async_udp_echo_server.cpp
//
// async_udp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

using asio::ip::udp;

class server
{
public:
  server(asio::io_context& io_context, short port)
    : socket_(io_context, udp::endpoint(udp::v4(), port))
  {
    do_receive();
  }

  void do_receive()
  {
    socket_.async_receive_from(
        asio::buffer(data_, max_length), sender_endpoint_,
        [this](std::error_code ec, std::size_t bytes_recvd)
        {
          if (!ec && bytes_recvd > 0)
          {
            do_send(bytes_recvd);
          }
          else
          {
            do_receive();
          }
        });
  }

  void do_send(std::size_t length)
  {
    socket_.async_send_to(
        asio::buffer(data_, length), sender_endpoint_,
        [this](std::error_code /*ec*/, std::size_t /*bytes_sent*/)
        {
          do_receive();
        });
  }

private:
  udp::socket socket_;
  udp::endpoint sender_endpoint_;
  enum { max_length = 1024 };
  char data_[max_length];
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: async_udp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server s(io_context, std::atoi(argv[1]));

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\echo\blocking_tcp_echo_client.cpp
//
// blocking_tcp_echo_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <cstring>
#include <iostream>
#include "asio.hpp"

using asio::ip::tcp;

enum { max_length = 1024 };

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: blocking_tcp_echo_client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    tcp::socket s(io_context);
    tcp::resolver resolver(io_context);
    asio::connect(s, resolver.resolve(argv[1], argv[2]));

    std::cout << "Enter message: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t request_length = std::strlen(request);
    asio::write(s, asio::buffer(request, request_length));

    char reply[max_length];
    size_t reply_length = asio::read(s,
        asio::buffer(reply, request_length));
    std::cout << "Reply is: ";
    std::cout.write(reply, reply_length);
    std::cout << "\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\echo\blocking_tcp_echo_server.cpp
//
// blocking_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <thread>
#include <utility>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

using asio::ip::tcp;

const int max_length = 1024;

void session(tcp::socket sock)
{
  try
  {
    for (;;)
    {
      char data[max_length];

      std::error_code error;
      size_t length = sock.read_some(asio::buffer(data), error);
      if (error == asio::stream_errc::eof)
        break; // Connection closed cleanly by peer.
      else if (error)
        throw std::system_error(error); // Some other error.

      asio::write(sock, asio::buffer(data, length));
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception in thread: " << e.what() << "\n";
  }
}

void server(asio::io_context& io_context, unsigned short port)
{
  tcp::acceptor a(io_context, tcp::endpoint(tcp::v4(), port));
  for (;;)
  {
    tcp::socket sock(io_context);
    a.accept(sock);
    std::thread(session, std::move(sock)).detach();
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: blocking_tcp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server(io_context, std::atoi(argv[1]));
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\echo\blocking_udp_echo_client.cpp
//
// blocking_udp_echo_client.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <cstring>
#include <iostream>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

using asio::ip::udp;

enum { max_length = 1024 };

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: blocking_udp_echo_client <host> <port>\n";
      return 1;
    }

    asio::io_context io_context;

    udp::socket s(io_context, udp::endpoint(udp::v4(), 0));

    udp::resolver resolver(io_context);
    udp::endpoint endpoint =
      *resolver.resolve(udp::v4(), argv[1], argv[2]).begin();

    std::cout << "Enter message: ";
    char request[max_length];
    std::cin.getline(request, max_length);
    size_t request_length = std::strlen(request);
    s.send_to(asio::buffer(request, request_length), endpoint);

    char reply[max_length];
    udp::endpoint sender_endpoint;
    size_t reply_length = s.receive_from(
        asio::buffer(reply, max_length), sender_endpoint);
    std::cout << "Reply is: ";
    std::cout.write(reply, reply_length);
    std::cout << "\n";
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\echo\blocking_udp_echo_server.cpp
//
// blocking_udp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <iostream>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

using asio::ip::udp;

enum { max_length = 1024 };

void server(asio::io_context& io_context, unsigned short port)
{
  udp::socket sock(io_context, udp::endpoint(udp::v4(), port));
  for (;;)
  {
    char data[max_length];
    udp::endpoint sender_endpoint;
    size_t length = sock.receive_from(
        asio::buffer(data, max_length), sender_endpoint);
    sock.send_to(asio::buffer(data, length), sender_endpoint);
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 2)
    {
      std::cerr << "Usage: blocking_udp_echo_server <port>\n";
      return 1;
    }

    asio::io_context io_context;

    server(io_context, std::atoi(argv[1]));
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\actor.cpp
#include <asio/any_io_executor.hpp>
#include <asio/defer.hpp>
#include <asio/post.hpp>
#include <asio/strand.hpp>
#include <asio/system_executor.hpp>
#include <condition_variable>
#include <deque>
#include <memory>
#include <mutex>
#include <typeinfo>
#include <vector>

using asio::any_io_executor;
using asio::defer;
using asio::post;
using asio::strand;
using asio::system_executor;

//------------------------------------------------------------------------------
// A tiny actor framework
// ~~~~~~~~~~~~~~~~~~~~~~

class actor;

// Used to identify the sender and recipient of messages.
typedef actor* actor_address;

// Base class for all registered message handlers.
class message_handler_base
{
public:
  virtual ~message_handler_base() {}

  // Used to determine which message handlers receive an incoming message.
  virtual const std::type_info& message_id() const = 0;
};

// Base class for a handler for a specific message type.
template <class Message>
class message_handler : public message_handler_base
{
public:
  // Handle an incoming message.
  virtual void handle_message(Message msg, actor_address from) = 0;
};

// Concrete message handler for a specific message type.
template <class Actor, class Message>
class mf_message_handler : public message_handler<Message>
{
public:
  // Construct a message handler to invoke the specified member function.
  mf_message_handler(void (Actor::* mf)(Message, actor_address), Actor* a)
    : function_(mf), actor_(a)
  {
  }

  // Used to determine which message handlers receive an incoming message.
  virtual const std::type_info& message_id() const
  {
    return typeid(Message);
  }

  // Handle an incoming message.
  virtual void handle_message(Message msg, actor_address from)
  {
    (actor_->*function_)(std::move(msg), from);
  }

  // Determine whether the message handler represents the specified function.
  bool is_function(void (Actor::* mf)(Message, actor_address)) const
  {
    return mf == function_;
  }

private:
  void (Actor::* function_)(Message, actor_address);
  Actor* actor_;
};

// Base class for all actors.
class actor
{
public:
  virtual ~actor()
  {
  }

  // Obtain the actor's address for use as a message sender or recipient.
  actor_address address()
  {
    return this;
  }

  // Send a message from one actor to another.
  template <class Message>
  friend void send(Message msg, actor_address from, actor_address to)
  {
    // Execute the message handler in the context of the target's executor.
    post(to->executor_,
      [=, msg=std::move(msg)]() mutable
      {
        to->call_handler(std::move(msg), from);
      });
  }

protected:
  // Construct the actor to use the specified executor for all message handlers.
  actor(any_io_executor e)
    : executor_(std::move(e))
  {
  }

  // Register a handler for a specific message type. Duplicates are permitted.
  template <class Actor, class Message>
  void register_handler(void (Actor::* mf)(Message, actor_address))
  {
    handlers_.push_back(
      std::make_shared<mf_message_handler<Actor, Message>>(
        mf, static_cast<Actor*>(this)));
  }

  // Deregister a handler. Removes only the first matching handler.
  template <class Actor, class Message>
  void deregister_handler(void (Actor::* mf)(Message, actor_address))
  {
    const std::type_info& id = typeid(Message);
    for (auto iter = handlers_.begin(); iter != handlers_.end(); ++iter)
    {
      if ((*iter)->message_id() == id)
      {
        auto mh = static_cast<mf_message_handler<Actor, Message>*>(iter->get());
        if (mh->is_function(mf))
        {
          handlers_.erase(iter);
          return;
        }
      }
    }
  }

  // Send a message from within a message handler.
  template <class Message>
  void tail_send(Message msg, actor_address to)
  {
    // Execute the message handler in the context of the target's executor.
    defer(to->executor_,
      [=, msg=std::move(msg), from=this]
      {
        to->call_handler(std::move(msg), from);
      });
  }

private:
  // Find the matching message handlers, if any, and call them.
  template <class Message>
  void call_handler(Message msg, actor_address from)
  {
    const std::type_info& message_id = typeid(Message);
    for (auto& h: handlers_)
    {
      if (h->message_id() == message_id)
      {
        auto mh = static_cast<message_handler<Message>*>(h.get());
        mh->handle_message(msg, from);
      }
    }
  }

  // All messages associated with a single actor object should be processed
  // non-concurrently. We use a strand to ensure non-concurrent execution even
  // if the underlying executor may use multiple threads.
  strand<any_io_executor> executor_;

  std::vector<std::shared_ptr<message_handler_base>> handlers_;
};

// A concrete actor that allows synchronous message retrieval.
template <class Message>
class receiver : public actor
{
public:
  receiver()
    : actor(system_executor())
  {
    register_handler(&receiver::message_handler);
  }

  // Block until a message has been received.
  Message wait()
  {
    std::unique_lock<std::mutex> lock(mutex_);
    condition_.wait(lock, [this]{ return !message_queue_.empty(); });
    Message msg(std::move(message_queue_.front()));
    message_queue_.pop_front();
    return msg;
  }

private:
  // Handle a new message by adding it to the queue and waking a waiter.
  void message_handler(Message msg, actor_address /* from */)
  {
    std::lock_guard<std::mutex> lock(mutex_);
    message_queue_.push_back(std::move(msg));
    condition_.notify_one();
  }

  std::mutex mutex_;
  std::condition_variable condition_;
  std::deque<Message> message_queue_;
};

//------------------------------------------------------------------------------

#include <asio/thread_pool.hpp>
#include <iostream>

using asio::thread_pool;

class member : public actor
{
public:
  explicit member(any_io_executor e)
    : actor(std::move(e))
  {
    register_handler(&member::init_handler);
  }

private:
  void init_handler(actor_address next, actor_address from)
  {
    next_ = next;
    caller_ = from;

    register_handler(&member::token_handler);
    deregister_handler(&member::init_handler);
  }

  void token_handler(int token, actor_address /*from*/)
  {
    int msg(token);
    actor_address to(caller_);

    if (token > 0)
    {
      msg = token - 1;
      to = next_;
    }

    tail_send(msg, to);
  }

  actor_address next_;
  actor_address caller_;
};

int main()
{
  const std::size_t num_threads = 16;
  const int num_hops = 50000000;
  const std::size_t num_actors = 503;
  const int token_value = (num_hops + num_actors - 1) / num_actors;
  const std::size_t actors_per_thread = num_actors / num_threads;

  struct single_thread_pool : thread_pool { single_thread_pool() : thread_pool(1) {} };
  single_thread_pool pools[num_threads];
  std::vector<std::shared_ptr<member>> members(num_actors);
  receiver<int> rcvr;

  // Create the member actors.
  for (std::size_t i = 0; i < num_actors; ++i)
    members[i] = std::make_shared<member>(pools[(i / actors_per_thread) % num_threads].get_executor());

  // Initialise the actors by passing each one the address of the next actor in the ring.
  for (std::size_t i = num_actors, next_i = 0; i > 0; next_i = --i)
    send(members[next_i]->address(), rcvr.address(), members[i - 1]->address());

  // Send exactly one token to each actor, all with the same initial value, rounding up if required.
  for (std::size_t i = 0; i < num_actors; ++i)
    send(token_value, rcvr.address(), members[i]->address());

  // Wait for all signal messages, indicating the tokens have all reached zero.
  for (std::size_t i = 0; i < num_actors; ++i)
    rcvr.wait();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\async_1.cpp
#include <asio/associated_executor.hpp>
#include <asio/bind_executor.hpp>
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <iostream>
#include <string>

using asio::bind_executor;
using asio::get_associated_executor;
using asio::static_thread_pool;
namespace execution = asio::execution;

// A function to asynchronously read a single line from an input stream.
template <class IoExecutor, class Handler>
void async_getline(IoExecutor io_ex, std::istream& is, Handler handler)
{
  // Track work for the handler's associated executor.
  auto work_ex = asio::prefer(
      get_associated_executor(handler, io_ex),
      execution::outstanding_work.tracked);

  // Post a function object to do the work asynchronously.
  asio::require(io_ex, execution::blocking.never).execute(
      [&is, work_ex, handler=std::move(handler)]() mutable
      {
        std::string line;
        std::getline(is, line);

        // Pass the result to the handler, via the associated executor.
        asio::prefer(work_ex, execution::blocking.possibly).execute(
            [line=std::move(line), handler=std::move(handler)]() mutable
            {
              handler(std::move(line));
            });
      });
}

int main()
{
  static_thread_pool io_pool(1);
  static_thread_pool completion_pool(1);

  std::cout << "Enter a line: ";

  async_getline(io_pool.executor(), std::cin,
      bind_executor(completion_pool.executor(),
        [](std::string line)
        {
          std::cout << "Line: " << line << "\n";
        }));

  io_pool.wait();
  completion_pool.wait();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\async_2.cpp
#include <asio/associated_executor.hpp>
#include <asio/bind_executor.hpp>
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <iostream>
#include <string>

using asio::bind_executor;
using asio::get_associated_executor;
using asio::static_thread_pool;
namespace execution = asio::execution;

// A function to asynchronously read a single line from an input stream.
template <class IoExecutor, class Handler>
void async_getline(IoExecutor io_ex, std::istream& is, Handler handler)
{
  // Track work for the handler's associated executor.
  auto work_ex = asio::prefer(
      get_associated_executor(handler, io_ex),
      execution::outstanding_work.tracked);

  // Post a function object to do the work asynchronously.
  asio::require(io_ex, execution::blocking.never).execute(
      [&is, work_ex, handler=std::move(handler)]() mutable
      {
        std::string line;
        std::getline(is, line);

        // Pass the result to the handler, via the associated executor.
        asio::prefer(work_ex, execution::blocking.possibly).execute(
            [line=std::move(line), handler=std::move(handler)]() mutable
            {
              handler(std::move(line));
            });
      });
}

// A function to asynchronously read multiple lines from an input stream.
template <class IoExecutor, class Handler>
void async_getlines(IoExecutor io_ex, std::istream& is, std::string init, Handler handler)
{
  // Track work for the I/O executor.
  auto io_work_ex = asio::prefer(io_ex,
      execution::outstanding_work.tracked);

  // Track work for the handler's associated executor.
  auto handler_work_ex = asio::prefer(
      get_associated_executor(handler, io_ex),
      execution::outstanding_work.tracked);

  // Use the associated executor for each operation in the composition.
  async_getline(io_work_ex, is,
      bind_executor(handler_work_ex,
        [io_work_ex, &is, lines=std::move(init), handler=std::move(handler)]
        (std::string line) mutable
        {
          if (line.empty())
            handler(lines);
          else
            async_getlines(io_work_ex, is, lines + line + "\n", std::move(handler));
        }));
}

int main()
{
  static_thread_pool io_pool(1);
  static_thread_pool completion_pool(1);

  std::cout << "Enter text, terminating with a blank line:\n";

  async_getlines(io_pool.executor(), std::cin, "",
      bind_executor(completion_pool.executor(), [](std::string lines)
        {
          std::cout << "Lines:\n" << lines << "\n";
        }));

  io_pool.wait();
  completion_pool.wait();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\bank_account_1.cpp
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <iostream>

using asio::static_thread_pool;
namespace execution = asio::execution;

// Traditional active object pattern.
// Member functions do not block.

class bank_account
{
  int balance_ = 0;
  mutable static_thread_pool pool_{1};

public:
  void deposit(int amount)
  {
    pool_.executor().execute(
        [this, amount]
        {
          balance_ += amount;
        });
  }

  void withdraw(int amount)
  {
    pool_.executor().execute(
        [this, amount]
        {
          if (balance_ >= amount)
            balance_ -= amount;
        });
  }

  void print_balance() const
  {
    pool_.executor().execute(
        [this]
        {
          std::cout << "balance = " << balance_ << "\n";
        });
  }

  ~bank_account()
  {
    pool_.wait();
  }
};

int main()
{
  bank_account acct;
  acct.deposit(20);
  acct.withdraw(10);
  acct.print_balance();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\bank_account_2.cpp
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <iostream>

using asio::static_thread_pool;
namespace execution = asio::execution;

// Traditional active object pattern.
// Member functions block until operation is finished.

class bank_account
{
  int balance_ = 0;
  mutable static_thread_pool pool_{1};

public:
  void deposit(int amount)
  {
    asio::require(pool_.executor(), execution::blocking.always).execute(
        [this, amount]
        {
          balance_ += amount;
        });
  }

  void withdraw(int amount)
  {
    asio::require(pool_.executor(),
      execution::blocking.always).execute(
        [this, amount]
        {
          if (balance_ >= amount)
            balance_ -= amount;
        });
  }

  int balance() const
  {
    int result = 0;
    asio::require(pool_.executor(), execution::blocking.always).execute(
        [this, &result]
        {
          result = balance_;
        });
    return result;
  }
};

int main()
{
  bank_account acct;
  acct.deposit(20);
  acct.withdraw(10);
  std::cout << "balance = " << acct.balance() << "\n";
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\fork_join.cpp
#include <asio/execution.hpp>
#include <asio/static_thread_pool.hpp>
#include <algorithm>
#include <condition_variable>
#include <memory>
#include <mutex>
#include <queue>
#include <thread>
#include <numeric>

using asio::static_thread_pool;
namespace execution = asio::execution;

// A fixed-size thread pool used to implement fork/join semantics. Functions
// are scheduled using a simple FIFO queue. Implementing work stealing, or
// using a queue based on atomic operations, are left as tasks for the reader.
class fork_join_pool
{
public:
  // The constructor starts a thread pool with the specified number of threads.
  // Note that the thread_count is not a fixed limit on the pool's concurrency.
  // Additional threads may temporarily be added to the pool if they join a
  // fork_executor.
  explicit fork_join_pool(
      std::size_t thread_count = std::max(std::thread::hardware_concurrency(), 1u) * 2)
    : use_count_(1),
      threads_(thread_count)
  {
    try
    {
      // Ask each thread in the pool to dequeue and execute functions until
      // it is time to shut down, i.e. the use count is zero.
      for (thread_count_ = 0; thread_count_ < thread_count; ++thread_count_)
      {
        threads_.executor().execute(
            [this]
            {
              std::unique_lock<std::mutex> lock(mutex_);
              while (use_count_ > 0)
                if (!execute_next(lock))
                  condition_.wait(lock);
            });
      }
    }
    catch (...)
    {
      stop_threads();
      threads_.wait();
      throw;
    }
  }

  // The destructor waits for the pool to finish executing functions.
  ~fork_join_pool()
  {
    stop_threads();
    threads_.wait();
  }

private:
  friend class fork_executor;

  // The base for all functions that are queued in the pool.
  struct function_base
  {
    std::shared_ptr<std::size_t> work_count_;
    void (*execute_)(std::shared_ptr<function_base>& p);
  };

  // Execute the next function from the queue, if any. Returns true if a
  // function was executed, and false if the queue was empty.
  bool execute_next(std::unique_lock<std::mutex>& lock)
  {
    if (queue_.empty())
      return false;
    auto p(queue_.front());
    queue_.pop();
    lock.unlock();
    execute(lock, p); 
    return true;
  }

  // Execute a function and decrement the outstanding work.
  void execute(std::unique_lock<std::mutex>& lock,
      std::shared_ptr<function_base>& p)
  {
    std::shared_ptr<std::size_t> work_count(std::move(p->work_count_));
    try
    {
      p->execute_(p);
      lock.lock();
      do_work_finished(work_count);
    }
    catch (...)
    {
      lock.lock();
      do_work_finished(work_count);
      throw;
    }
  }

  // Increment outstanding work.
  void do_work_started(const std::shared_ptr<std::size_t>& work_count) noexcept
  {
    if (++(*work_count) == 1)
      ++use_count_;
  }

  // Decrement outstanding work. Notify waiting threads if we run out.
  void do_work_finished(const std::shared_ptr<std::size_t>& work_count) noexcept
  {
    if (--(*work_count) == 0)
    {
      --use_count_;
      condition_.notify_all();
    }
  }

  // Dispatch a function, executing it immediately if the queue is already
  // loaded. Otherwise adds the function to the queue and wakes a thread.
  void do_execute(std::shared_ptr<function_base> p,
      const std::shared_ptr<std::size_t>& work_count)
  {
    std::unique_lock<std::mutex> lock(mutex_);
    if (queue_.size() > thread_count_ * 16)
    {
      do_work_started(work_count);
      lock.unlock();
      execute(lock, p);
    }
    else
    {
      queue_.push(p);
      do_work_started(work_count);
      condition_.notify_one();
    }
  }

  // Ask all threads to shut down.
  void stop_threads()
  {
    std::lock_guard<std::mutex> lock(mutex_);
    --use_count_;
    condition_.notify_all();
  }

  std::mutex mutex_;
  std::condition_variable condition_;
  std::queue<std::shared_ptr<function_base>> queue_;
  std::size_t use_count_;
  std::size_t thread_count_;
  static_thread_pool threads_;
};

// A class that satisfies the Executor requirements. Every function or piece of
// work associated with a fork_executor is part of a single, joinable group.
class fork_executor
{
public:
  fork_executor(fork_join_pool& ctx)
    : context_(ctx),
      work_count_(std::make_shared<std::size_t>(0))
  {
  }

  fork_join_pool& query(execution::context_t) const noexcept
  {
    return context_;
  }

  template <class Func>
  void execute(Func f) const
  {
    auto p(std::make_shared<function<Func>>(std::move(f), work_count_));
    context_.do_execute(p, work_count_);
  }

  friend bool operator==(const fork_executor& a,
      const fork_executor& b) noexcept
  {
    return a.work_count_ == b.work_count_;
  }

  friend bool operator!=(const fork_executor& a,
      const fork_executor& b) noexcept
  {
    return a.work_count_ != b.work_count_;
  }

  // Block until all work associated with the executor is complete. While it is
  // waiting, the thread may be borrowed to execute functions from the queue.
  void join() const
  {
    std::unique_lock<std::mutex> lock(context_.mutex_);
    while (*work_count_ > 0)
      if (!context_.execute_next(lock))
        context_.condition_.wait(lock);
  }

private:
  template <class Func>
  struct function : fork_join_pool::function_base
  {
    explicit function(Func f, const std::shared_ptr<std::size_t>& w)
      : function_(std::move(f))
    {
      work_count_ = w;
      execute_ = [](std::shared_ptr<fork_join_pool::function_base>& p)
      {
        Func tmp(std::move(static_cast<function*>(p.get())->function_));
        p.reset();
        tmp();
      };
    }

    Func function_;
  };

  fork_join_pool& context_;
  std::shared_ptr<std::size_t> work_count_;
};

// Helper class to automatically join a fork_executor when exiting a scope.
class join_guard
{
public:
  explicit join_guard(const fork_executor& ex) : ex_(ex) {}
  join_guard(const join_guard&) = delete;
  join_guard(join_guard&&) = delete;
  ~join_guard() { ex_.join(); }

private:
  fork_executor ex_;
};

//------------------------------------------------------------------------------

#include <algorithm>
#include <iostream>
#include <random>
#include <vector>

fork_join_pool pool;

template <class Iterator>
void fork_join_sort(Iterator begin, Iterator end)
{
  std::size_t n = end - begin;
  if (n > 32768)
  {
    {
      fork_executor fork(pool);
      join_guard join(fork);
      fork.execute([=]{ fork_join_sort(begin, begin + n / 2); });
      fork.execute([=]{ fork_join_sort(begin + n / 2, end); });
    }
    std::inplace_merge(begin, begin + n / 2, end);
  }
  else
  {
    std::sort(begin, end);
  }
}

int main(int argc, char* argv[])
{
  if (argc != 2)
  {
    std::cerr << "Usage: fork_join <size>\n";
    return 1;
  }

  std::vector<double> vec(std::atoll(argv[1]));
  std::iota(vec.begin(), vec.end(), 0);

  std::random_device rd;
  std::mt19937 g(rd());
  std::shuffle(vec.begin(), vec.end(), g);

  std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();

  fork_join_sort(vec.begin(), vec.end());

  std::chrono::steady_clock::duration elapsed = std::chrono::steady_clock::now() - start;

  std::cout << "sort took ";
  std::cout << std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
  std::cout << " microseconds" << std::endl;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\pipeline.cpp
#include <asio/associated_executor.hpp>
#include <asio/bind_executor.hpp>
#include <asio/execution.hpp>
#include <condition_variable>
#include <future>
#include <memory>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>
#include <cctype>

using asio::executor_binder;
using asio::get_associated_executor;
namespace execution = asio::execution;

// An executor that launches a new thread for each function submitted to it.
// This class satisfies the executor requirements.
class thread_executor
{
private:
  // Singleton execution context that manages threads launched by the new_thread_executor.
  class thread_bag
  {
    friend class thread_executor;

    void add_thread(std::thread&& t)
    {
      std::unique_lock<std::mutex> lock(mutex_);
      threads_.push_back(std::move(t));
    }

    thread_bag() = default;

    ~thread_bag()
    {
      for (auto& t : threads_)
        t.join();
    }

    std::mutex mutex_;
    std::vector<std::thread> threads_;
  };

public:
  static thread_bag& query(execution::context_t)
  {
    static thread_bag threads;
    return threads;
  }

  static constexpr auto query(execution::blocking_t)
  {
    return execution::blocking.never;
  }

  template <class Func>
  void execute(Func f) const
  {
    thread_bag& bag = query(execution::context);
    bag.add_thread(std::thread(std::move(f)));
  }

  friend bool operator==(const thread_executor&,
      const thread_executor&) noexcept
  {
    return true;
  }

  friend bool operator!=(const thread_executor&,
      const thread_executor&) noexcept
  {
    return false;
  }
};

// Base class for all thread-safe queue implementations.
class queue_impl_base
{
  template <class> friend class queue_front;
  template <class> friend class queue_back;
  std::mutex mutex_;
  std::condition_variable condition_;
  bool stop_ = false;
};

// Underlying implementation of a thread-safe queue, shared between the
// queue_front and queue_back classes.
template <class T>
class queue_impl : public queue_impl_base
{
  template <class> friend class queue_front;
  template <class> friend class queue_back;
  std::queue<T> queue_;
};

// The front end of a queue between consecutive pipeline stages.
template <class T>
class queue_front
{
public:
  typedef T value_type;

  explicit queue_front(std::shared_ptr<queue_impl<T>> impl)
    : impl_(impl)
  {
  }

  void push(T t)
  {
    std::unique_lock<std::mutex> lock(impl_->mutex_);
    impl_->queue_.push(std::move(t));
    impl_->condition_.notify_one();
  }

  void stop()
  {
    std::unique_lock<std::mutex> lock(impl_->mutex_);
    impl_->stop_ = true;
    impl_->condition_.notify_one();
  }

private:
  std::shared_ptr<queue_impl<T>> impl_;
};

// The back end of a queue between consecutive pipeline stages.
template <class T>
class queue_back
{
public:
  typedef T value_type;

  explicit queue_back(std::shared_ptr<queue_impl<T>> impl)
    : impl_(impl)
  {
  }

  bool pop(T& t)
  {
    std::unique_lock<std::mutex> lock(impl_->mutex_);
    while (impl_->queue_.empty() && !impl_->stop_)
      impl_->condition_.wait(lock);
    if (!impl_->queue_.empty())
    {
      t = impl_->queue_.front();
      impl_->queue_.pop();
      return true;
    }
    return false;
  }

private:
  std::shared_ptr<queue_impl<T>> impl_;
};

// Launch the last stage in a pipeline.
template <class T, class F>
std::future<void> pipeline(queue_back<T> in, F f)
{
  // Get the function's associated executor, defaulting to thread_executor.
  auto ex = get_associated_executor(f, thread_executor());

  // Run the function, and as we're the last stage return a future so that the
  // caller can wait for the pipeline to finish.
  std::packaged_task<void()> task(
      [in, f = std::move(f)]() mutable
      {
        f(in);
      });
  std::future<void> fut = task.get_future();
  asio::require(ex, execution::blocking.never).execute(std::move(task));
  return fut;
}

// Launch an intermediate stage in a pipeline.
template <class T, class F, class... Tail>
std::future<void> pipeline(queue_back<T> in, F f, Tail... t)
{
  // Determine the output queue type.
  typedef typename executor_binder<F, thread_executor>::second_argument_type::value_type output_value_type;

  // Create the output queue and its implementation.
  auto out_impl = std::make_shared<queue_impl<output_value_type>>();
  queue_front<output_value_type> out(out_impl);
  queue_back<output_value_type> next_in(out_impl);

  // Get the function's associated executor, defaulting to thread_executor.
  auto ex = get_associated_executor(f, thread_executor());

  // Run the function.
  asio::require(ex, execution::blocking.never).execute(
      [in, out, f = std::move(f)]() mutable
      {
        f(in, out);
        out.stop();
      });

  // Launch the rest of the pipeline.
  return pipeline(next_in, std::move(t)...);
}

// Launch the first stage in a pipeline.
template <class F, class... Tail>
std::future<void> pipeline(F f, Tail... t)
{
  // Determine the output queue type.
  typedef typename executor_binder<F, thread_executor>::argument_type::value_type output_value_type;

  // Create the output queue and its implementation.
  auto out_impl = std::make_shared<queue_impl<output_value_type>>();
  queue_front<output_value_type> out(out_impl);
  queue_back<output_value_type> next_in(out_impl);

  // Get the function's associated executor, defaulting to thread_executor.
  auto ex = get_associated_executor(f, thread_executor());

  // Run the function.
  asio::require(ex, execution::blocking.never).execute(
      [out, f = std::move(f)]() mutable
      {
        f(out);
        out.stop();
      });

  // Launch the rest of the pipeline.
  return pipeline(next_in, std::move(t)...);
}

//------------------------------------------------------------------------------

#include <asio/static_thread_pool.hpp>
#include <iostream>
#include <string>

using asio::bind_executor;
using asio::static_thread_pool;

void reader(queue_front<std::string> out)
{
  std::string line;
  while (std::getline(std::cin, line))
    out.push(line);
}

void filter(queue_back<std::string> in, queue_front<std::string> out)
{
  std::string line;
  while (in.pop(line))
    if (line.length() > 5)
      out.push(line);
}

void upper(queue_back<std::string> in, queue_front<std::string> out)
{
  std::string line;
  while (in.pop(line))
  {
    std::string new_line;
    for (char c : line)
      new_line.push_back(std::toupper(c));
    out.push(new_line);
  }
}

void writer(queue_back<std::string> in)
{
  std::size_t count = 0;
  std::string line;
  while (in.pop(line))
    std::cout << count++ << ": " << line << std::endl;
}

int main()
{
  static_thread_pool pool(1);

  auto f = pipeline(reader, filter, bind_executor(pool.executor(), upper), writer);
  f.wait();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\executors\priority_scheduler.cpp
#include <asio/execution.hpp>
#include <condition_variable>
#include <iostream>
#include <memory>
#include <mutex>
#include <queue>

namespace execution = asio::execution;

namespace custom_props {

  struct priority
  {
    template <typename T>
    static constexpr bool is_applicable_property_v =
      execution::is_executor<T>::value;

    static constexpr bool is_requirable = true;
    static constexpr bool is_preferable = true;

    using polymorphic_query_result_type = int;

    int value() const { return value_; }

    int value_ = 1;
  };

  constexpr priority low_priority{0};
  constexpr priority normal_priority{1};
  constexpr priority high_priority{2};

} // namespace custom_props

class priority_scheduler
{
public:
  // A class that satisfies the Executor requirements.
  class executor_type
  {
  public:
    executor_type(priority_scheduler& ctx) noexcept
      : context_(ctx), priority_(custom_props::normal_priority.value())
    {
    }

    priority_scheduler& query(execution::context_t) const noexcept
    {
      return context_;
    }

    int query(custom_props::priority) const noexcept
    {
      return priority_;
    }

    executor_type require(custom_props::priority pri) const
    {
      executor_type new_ex(*this);
      new_ex.priority_ = pri.value();
      return new_ex;
    }

    template <class Func>
    void execute(Func f) const
    {
      auto p(std::make_shared<item<Func>>(priority_, std::move(f)));
      std::lock_guard<std::mutex> lock(context_.mutex_);
      context_.queue_.push(p);
      context_.condition_.notify_one();
    }

    friend bool operator==(const executor_type& a,
        const executor_type& b) noexcept
    {
      return &a.context_ == &b.context_;
    }

    friend bool operator!=(const executor_type& a,
        const executor_type& b) noexcept
    {
      return &a.context_ != &b.context_;
    }

  private:
    priority_scheduler& context_;
    int priority_;
  };

  executor_type executor() noexcept
  {
    return executor_type(*const_cast<priority_scheduler*>(this));
  }

  void run()
  {
    std::unique_lock<std::mutex> lock(mutex_);
    for (;;)
    {
      condition_.wait(lock, [&]{ return stopped_ || !queue_.empty(); });
      if (stopped_)
        return;
      auto p(queue_.top());
      queue_.pop();
      lock.unlock();
      p->execute_(p);
      lock.lock();
    }
  }

  void stop()
  {
    std::lock_guard<std::mutex> lock(mutex_);
    stopped_ = true;
    condition_.notify_all();
  }

private:
  struct item_base
  {
    int priority_;
    void (*execute_)(std::shared_ptr<item_base>&);
  };

  template <class Func>
  struct item : item_base
  {
    item(int pri, Func f) : function_(std::move(f))
    {
      priority_ = pri;
      execute_ = [](std::shared_ptr<item_base>& p)
      {
        Func tmp(std::move(static_cast<item*>(p.get())->function_));
        p.reset();
        tmp();
      };
    }

    Func function_;
  };

  struct item_comp
  {
    bool operator()(
        const std::shared_ptr<item_base>& a,
        const std::shared_ptr<item_base>& b)
    {
      return a->priority_ < b->priority_;
    }
  };

  std::mutex mutex_;
  std::condition_variable condition_;
  std::priority_queue<
    std::shared_ptr<item_base>,
    std::vector<std::shared_ptr<item_base>>,
    item_comp> queue_;
  bool stopped_ = false;
};

int main()
{
  priority_scheduler sched;
  auto ex = sched.executor();
  auto prefer_low = asio::prefer(ex, custom_props::low_priority);
  auto low = asio::require(ex, custom_props::low_priority);
  auto med = asio::require(ex, custom_props::normal_priority);
  auto high = asio::require(ex, custom_props::high_priority);
  execution::any_executor<custom_props::priority> poly_high(high);
  prefer_low.execute([]{ std::cout << "1\n"; });
  low.execute([]{ std::cout << "11\n"; });
  low.execute([]{ std::cout << "111\n"; });
  med.execute([]{ std::cout << "2\n"; });
  med.execute([]{ std::cout << "22\n"; });
  high.execute([]{ std::cout << "3\n"; });
  high.execute([]{ std::cout << "33\n"; });
  high.execute([]{ std::cout << "333\n"; });
  poly_high.execute([]{ std::cout << "3333\n"; });
  asio::require(ex, custom_props::priority{-1}).execute([&]{ sched.stop(); });
  sched.run();
  std::cout << "polymorphic query result = " << asio::query(poly_high, custom_props::priority{}) << "\n";
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\iostreams\http_client.cpp
//
// http_client.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <iostream>
#include <istream>
#include <ostream>
#include <string>
#include <asio/ts/internet.hpp>

using asio::ip::tcp;

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cout << "Usage: http_client <server> <path>\n";
      std::cout << "Example:\n";
      std::cout << "  http_client www.boost.org /LICENSE_1_0.txt\n";
      return 1;
    }

    asio::ip::tcp::iostream s;

    // The entire sequence of I/O operations must complete within 60 seconds.
    // If an expiry occurs, the socket is automatically closed and the stream
    // becomes bad.
    s.expires_after(std::chrono::seconds(60));

    // Establish a connection to the server.
    s.connect(argv[1], "http");
    if (!s)
    {
      std::cout << "Unable to connect: " << s.error().message() << "\n";
      return 1;
    }

    // Send the request. We specify the "Connection: close" header so that the
    // server will close the socket after transmitting the response. This will
    // allow us to treat all data up until the EOF as the content.
    s << "GET " << argv[2] << " HTTP/1.0\r\n";
    s << "Host: " << argv[1] << "\r\n";
    s << "Accept: */*\r\n";
    s << "Connection: close\r\n\r\n";

    // By default, the stream is tied with itself. This means that the stream
    // automatically flush the buffered output before attempting a read. It is
    // not necessary not explicitly flush the stream at this point.

    // Check that response is OK.
    std::string http_version;
    s >> http_version;
    unsigned int status_code;
    s >> status_code;
    std::string status_message;
    std::getline(s, status_message);
    if (!s || http_version.substr(0, 5) != "HTTP/")
    {
      std::cout << "Invalid response\n";
      return 1;
    }
    if (status_code != 200)
    {
      std::cout << "Response returned with status code " << status_code << "\n";
      return 1;
    }

    // Process the response headers, which are terminated by a blank line.
    std::string header;
    while (std::getline(s, header) && header != "\r")
      std::cout << header << "\n";
    std::cout << "\n";

    // Write the remaining data to output.
    std::cout << s.rdbuf();
  }
  catch (std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\c_callback_wrapper.cpp
//
// c_callback_wrapper.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>
#include <memory>
#include <new>

//------------------------------------------------------------------------------

// This is a mock implementation of a C-based API that uses the function pointer
// plus void* context idiom for exposing a callback.

void read_input(const char* prompt, void (*cb)(void*, const char*), void* arg)
{
  std::thread(
      [prompt = std::string(prompt), cb, arg]
      {
        std::cout << prompt << ": ";
        std::cout.flush();
        std::string line;
        std::getline(std::cin, line);
        cb(arg, line.c_str());
      }).detach();
}

//------------------------------------------------------------------------------

// This is an asynchronous operation that wraps the C-based API.

// To map our completion handler into a function pointer / void* callback, we
// need to allocate some state that will live for the duration of the
// operation. A pointer to this state will be passed to the C-based API.
template <typename Handler>
class read_input_state
{
public:
  read_input_state(Handler&& handler)
    : handler_(std::move(handler)),
      work_(asio::make_work_guard(handler_))
  {
  }

  // Create the state using the handler's associated allocator.
  static read_input_state* create(Handler&& handler)
  {
    // A unique_ptr deleter that is used to destroy uninitialised objects.
    struct deleter
    {
      // Get the handler's associated allocator type. If the handler does not
      // specify an associated allocator, we will use a recycling allocator as
      // the default. As the associated allocator is a proto-allocator, we must
      // rebind it to the correct type before we can use it to allocate objects.
      typename std::allocator_traits<
        asio::associated_allocator_t<Handler,
          asio::recycling_allocator<void>>>::template
            rebind_alloc<read_input_state> alloc;

      void operator()(read_input_state* ptr)
      {
        std::allocator_traits<decltype(alloc)>::deallocate(alloc, ptr, 1);
      }
    } d{asio::get_associated_allocator(handler,
          asio::recycling_allocator<void>())};

    // Allocate memory for the state.
    std::unique_ptr<read_input_state, deleter> uninit_ptr(
        std::allocator_traits<decltype(d.alloc)>::allocate(d.alloc, 1), d);

    // Construct the state into the newly allocated memory. This might throw.
    read_input_state* ptr =
      new (uninit_ptr.get()) read_input_state(std::move(handler));

    // Release ownership of the memory and return the newly allocated state.
    uninit_ptr.release();
    return ptr;
  }

  static void callback(void* arg, const char* result)
  {
    read_input_state* self = static_cast<read_input_state*>(arg);

    // A unique_ptr deleter that is used to destroy initialised objects.
    struct deleter
    {
      // Get the handler's associated allocator type. If the handler does not
      // specify an associated allocator, we will use a recycling allocator as
      // the default. As the associated allocator is a proto-allocator, we must
      // rebind it to the correct type before we can use it to allocate objects.
      typename std::allocator_traits<
        asio::associated_allocator_t<Handler,
          asio::recycling_allocator<void>>>::template
            rebind_alloc<read_input_state> alloc;

      void operator()(read_input_state* ptr)
      {
        std::allocator_traits<decltype(alloc)>::destroy(alloc, ptr);
        std::allocator_traits<decltype(alloc)>::deallocate(alloc, ptr, 1);
      }
    } d{asio::get_associated_allocator(self->handler_,
          asio::recycling_allocator<void>())};

    // To conform to the rules regarding asynchronous operations and memory
    // allocation, we must make a copy of the state and deallocate the memory
    // before dispatching the completion handler.
    std::unique_ptr<read_input_state, deleter> state_ptr(self, d);
    read_input_state state(std::move(*self));
    state_ptr.reset();

    // Dispatch the completion handler through the handler's associated
    // executor, using the handler's associated allocator.
    asio::dispatch(state.work_.get_executor(),
        asio::bind_allocator(d.alloc,
          [
            handler = std::move(state.handler_),
            result = std::string(result)
          ]() mutable
          {
            std::move(handler)(result);
          }));
  }

private:
  Handler handler_;

  // According to the rules for asynchronous operations, we need to track
  // outstanding work against the handler's associated executor until the
  // asynchronous operation is complete.
  asio::executor_work_guard<
    asio::associated_executor_t<Handler>> work_;
};

// The initiating function for the asynchronous operation.
template <typename CompletionToken>
auto async_read_input(const std::string& prompt, CompletionToken&& token)
{
  // Define a function object that contains the code to launch the asynchronous
  // operation. This is passed the concrete completion handler, followed by any
  // additional arguments that were passed through the call to async_initiate.
  auto init = [](auto handler, const std::string& prompt)
  {
    // The body of the initiation function object creates the long-lived state
    // and passes it to the C-based API, along with the function pointer.
    using state_type = read_input_state<decltype(handler)>;
    read_input(prompt.c_str(), &state_type::callback,
        state_type::create(std::move(handler)));
  };

  // The async_initiate function is used to transform the supplied completion
  // token to the completion handler. When calling this function we explicitly
  // specify the completion signature of the operation. We must also return the
  // result of the call since the completion token may produce a return value,
  // such as a future.
  return asio::async_initiate<CompletionToken, void(std::string)>(
      init, // First, pass the function object that launches the operation,
      token, // then the completion token that will be transformed to a handler,
      prompt); // and, finally, any additional arguments to the function object.
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  // Test our asynchronous operation using a lambda as a callback. We will use
  // an io_context to obtain an associated executor.
  async_read_input("Enter your name",
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_read_input("Enter your name", asio::deferred);

  // Launch our asynchronous operation using a lambda as a callback. We will use
  // an io_context to obtain an associated executor.
  std::move(op)(
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::string> f =
    async_read_input("Enter your name", asio::use_future);

  std::string result = f.get();
  std::cout << "Hello " << result << "\n";
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\callback_wrapper.cpp
//
// callback_wrapper.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

//------------------------------------------------------------------------------

// This is a mock implementation of an API that uses a move-only function object
// for exposing a callback. The callback has the signature void(std::string).

template <typename Callback>
void read_input(const std::string& prompt, Callback cb)
{
  std::thread(
      [prompt, cb = std::move(cb)]() mutable
      {
        std::cout << prompt << ": ";
        std::cout.flush();
        std::string line;
        std::getline(std::cin, line);
        std::move(cb)(std::move(line));
      }).detach();
}

//------------------------------------------------------------------------------

// This is an asynchronous operation that wraps the callback-based API.

// The initiating function for the asynchronous operation.
template <typename CompletionToken>
auto async_read_input(const std::string& prompt, CompletionToken&& token)
{
  // Define a function object that contains the code to launch the asynchronous
  // operation. This is passed the concrete completion handler, followed by any
  // additional arguments that were passed through the call to async_initiate.
  auto init = [](auto handler, const std::string& prompt)
  {
    // According to the rules for asynchronous operations, we need to track
    // outstanding work against the handler's associated executor until the
    // asynchronous operation is complete.
    auto work = asio::make_work_guard(handler);

    // Launch the operation with a callback that will receive the result and
    // pass it through to the asynchronous operation's completion handler.
    read_input(prompt,
        [
          handler = std::move(handler),
          work = std::move(work)
        ](std::string result) mutable
        {
          // Get the handler's associated allocator. If the handler does not
          // specify an allocator, use the recycling allocator as the default.
          auto alloc = asio::get_associated_allocator(
              handler, asio::recycling_allocator<void>());

          // Dispatch the completion handler through the handler's associated
          // executor, using the handler's associated allocator.
          asio::dispatch(work.get_executor(),
              asio::bind_allocator(alloc,
                [
                  handler = std::move(handler),
                  result = std::string(result)
                ]() mutable
                {
                  std::move(handler)(result);
                }));
        });
  };

  // The async_initiate function is used to transform the supplied completion
  // token to the completion handler. When calling this function we explicitly
  // specify the completion signature of the operation. We must also return the
  // result of the call since the completion token may produce a return value,
  // such as a future.
  return asio::async_initiate<CompletionToken, void(std::string)>(
      init, // First, pass the function object that launches the operation,
      token, // then the completion token that will be transformed to a handler,
      prompt); // and, finally, any additional arguments to the function object.
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  // Test our asynchronous operation using a lambda as a callback. We will use
  // an io_context to specify an associated executor.
  async_read_input("Enter your name",
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_read_input("Enter your name", asio::deferred);

  // Launch our asynchronous operation using a lambda as a callback. We will use
  // an io_context to obtain an associated executor.
  std::move(op)(
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::string> f =
    async_read_input("Enter your name", asio::use_future);

  std::string result = f.get();
  std::cout << "Hello " << result << "\n";
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_1.cpp
//
// composed_1.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

//------------------------------------------------------------------------------

// This is the simplest example of a composed asynchronous operation, where we
// simply repackage an existing operation. The asynchronous operation
// requirements are met by delegating responsibility to the underlying
// operation.

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is void.
  // However, when the completion token is asio::yield_context (used for
  // stackful coroutines) the return type would be std::size_t, and when the
  // completion token is asio::use_future it would be std::future<std::size_t>.
  // When the completion token is asio::deferred, the return type differs for
  // each asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of our underlying asynchronous operation.
{
  // When delegating to the underlying operation we must take care to perfectly
  // forward the completion token. This ensures that our operation works
  // correctly with move-only function objects as callbacks, as well as other
  // completion token types.
  return asio::async_write(socket,
      asio::buffer(message, std::strlen(message)),
      std::forward<CompletionToken>(token));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n",
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      "Testing deferred\r\n", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::size_t> f = async_write_message(
      socket, "Testing future\r\n", asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    std::size_t n = f.get();
    std::cout << n << " bytes transferred\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_2.cpp
//
// composed_2.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This next simplest example of a composed asynchronous operation involves
// repackaging multiple operations but choosing to invoke just one of them. All
// of these underlying operations have the same completion signature. The
// asynchronous operation requirements are met by delegating responsibility to
// the underlying operations.

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, bool allow_partial_write,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is void.
  // However, when the completion token is asio::yield_context (used for
  // stackful coroutines) the return type would be std::size_t, and when the
  // completion token is asio::use_future it would be std::future<std::size_t>.
  // When the completion token is asio::deferred, the return type differs for
  // each asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error, std::size_t)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](auto&& completion_handler, tcp::socket& socket,
      const char* message, bool allow_partial_write)
  {
    if (allow_partial_write)
    {
      // When delegating to an underlying operation we must take care to
      // perfectly forward the completion handler. This ensures that our
      // operation works correctly with move-only function objects as
      // callbacks.
      return socket.async_write_some(
          asio::buffer(message, std::strlen(message)),
          std::forward<decltype(completion_handler)>(completion_handler));
    }
    else
    {
      // As above, we must perfectly forward the completion handler when calling
      // the alternate underlying operation.
      return asio::async_write(socket,
          asio::buffer(message, std::strlen(message)),
          std::forward<decltype(completion_handler)>(completion_handler));
    }
  };

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code, std::size_t)>(
      initiation, token, std::ref(socket), message, allow_partial_write);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n", false,
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      "Testing deferred\r\n", false, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::size_t> f = async_write_message(
      socket, "Testing future\r\n", false, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    std::size_t n = f.get();
    std::cout << n << " bytes transferred\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_3.cpp
//
// composed_3.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/bind_executor.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// In this composed operation we repackage an existing operation, but with a
// different completion handler signature. The asynchronous operation
// requirements are met by delegating responsibility to the underlying
// operation.

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](auto&& completion_handler,
      tcp::socket& socket, const char* message)
  {
    // The async_write operation has a completion handler signature of:
    //
    //   void(std::error_code error, std::size n)
    //
    // This differs from our operation's signature in that it is also passed
    // the number of bytes transferred as an argument of type std::size_t. We
    // will adapt our completion handler to async_write's completion handler
    // signature by using std::bind, which drops the additional argument.
    //
    // However, it is essential to the correctness of our composed operation
    // that we preserve the executor of the user-supplied completion handler.
    // The std::bind function will not do this for us, so we must do this by
    // first obtaining the completion handler's associated executor (defaulting
    // to the I/O executor - in this case the executor of the socket - if the
    // completion handler does not have its own) ...
    auto executor = asio::get_associated_executor(
        completion_handler, socket.get_executor());

    // ... and then binding this executor to our adapted completion handler
    // using the asio::bind_executor function.
    asio::async_write(socket,
        asio::buffer(message, std::strlen(message)),
        asio::bind_executor(executor,
          std::bind(std::forward<decltype(completion_handler)>(
              completion_handler), std::placeholders::_1)));
  };

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket), message);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n",
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      "Testing deferred\r\n", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, "Testing future\r\n", asio::use_future);

  io_context.run();

  // Get the result of the operation.
  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_4.cpp
//
// composed_4.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/bind_executor.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// In this composed operation we repackage an existing operation, but with a
// different completion handler signature. We will also intercept an empty
// message as an invalid argument, and propagate the corresponding error to the
// user. The asynchronous operation requirements are met by delegating
// responsibility to the underlying operation.

template <typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](auto&& completion_handler,
      tcp::socket& socket, const char* message)
  {
    // The post operation has a completion handler signature of:
    //
    //   void()
    //
    // and the async_write operation has a completion handler signature of:
    //
    //   void(std::error_code error, std::size n)
    //
    // Both of these operations' completion handler signatures differ from our
    // operation's completion handler signature. We will adapt our completion
    // handler to these signatures by using std::bind, which drops the
    // additional arguments.
    //
    // However, it is essential to the correctness of our composed operation
    // that we preserve the executor of the user-supplied completion handler.
    // The std::bind function will not do this for us, so we must do this by
    // first obtaining the completion handler's associated executor (defaulting
    // to the I/O executor - in this case the executor of the socket - if the
    // completion handler does not have its own) ...
    auto executor = asio::get_associated_executor(
        completion_handler, socket.get_executor());

    // ... and then binding this executor to our adapted completion handler
    // using the asio::bind_executor function.
    std::size_t length = std::strlen(message);
    if (length == 0)
    {
      asio::post(
          asio::bind_executor(executor,
            std::bind(std::forward<decltype(completion_handler)>(
                completion_handler), asio::error::invalid_argument)));
    }
    else
    {
      asio::async_write(socket,
          asio::buffer(message, length),
          asio::bind_executor(executor,
            std::bind(std::forward<decltype(completion_handler)>(
                completion_handler), std::placeholders::_1)));
    }
  };

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket), message);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "",
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket, "", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, "", asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_5.cpp
//
// composed_5.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation automatically serialises a message, using its I/O
// streams insertion operator, before sending it on the socket. To do this, it
// must allocate a buffer for the encoded message and ensure this buffer's
// validity until the underlying async_write operation completes.

template <typename T, typename CompletionToken>
auto async_write_message(tcp::socket& socket,
    const T& message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](auto&& completion_handler,
      tcp::socket& socket, std::unique_ptr<std::string> encoded_message)
  {
    // In this example, the composed operation's intermediate completion
    // handler is implemented as a hand-crafted function object, rather than
    // using a lambda or std::bind.
    struct intermediate_completion_handler
    {
      // The intermediate completion handler holds a reference to the socket so
      // that it can obtain the I/O executor (see get_executor below).
      tcp::socket& socket_;

      // The allocated buffer for the encoded message. The std::unique_ptr
      // smart pointer is move-only, and as a consequence our intermediate
      // completion handler is also move-only.
      std::unique_ptr<std::string> encoded_message_;

      // The user-supplied completion handler.
      typename std::decay<decltype(completion_handler)>::type handler_;

      // The function call operator matches the completion signature of the
      // async_write operation.
      void operator()(const std::error_code& error, std::size_t /*n*/)
      {
        // Deallocate the encoded message before calling the user-supplied
        // completion handler.
        encoded_message_.reset();

        // Call the user-supplied handler with the result of the operation.
        // The arguments must match the completion signature of our composed
        // operation.
        handler_(error);
      }

      // It is essential to the correctness of our composed operation that we
      // preserve the executor of the user-supplied completion handler. With a
      // hand-crafted function object we can do this by defining a nested type
      // executor_type and member function get_executor. These obtain the
      // completion handler's associated executor, and default to the I/O
      // executor - in this case the executor of the socket - if the completion
      // handler does not have its own.
      using executor_type = asio::associated_executor_t<
          typename std::decay<decltype(completion_handler)>::type,
          tcp::socket::executor_type>;

      executor_type get_executor() const noexcept
      {
        return asio::get_associated_executor(
            handler_, socket_.get_executor());
      }

      // Although not necessary for correctness, we may also preserve the
      // allocator of the user-supplied completion handler. This is achieved by
      // defining a nested type allocator_type and member function
      // get_allocator. These obtain the completion handler's associated
      // allocator, and default to std::allocator<void> if the completion
      // handler does not have its own.
      using allocator_type = asio::associated_allocator_t<
          typename std::decay<decltype(completion_handler)>::type,
          std::allocator<void>>;

      allocator_type get_allocator() const noexcept
      {
        return asio::get_associated_allocator(
            handler_, std::allocator<void>{});
      }
    };

    // Initiate the underlying async_write operation using our intermediate
    // completion handler.
    auto encoded_message_buffer = asio::buffer(*encoded_message);
    asio::async_write(socket, encoded_message_buffer,
        intermediate_completion_handler{socket, std::move(encoded_message),
          std::forward<decltype(completion_handler)>(completion_handler)});
  };

  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket),
      std::move(encoded_message));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, 123456,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_message(socket,
      std::string("abcdef"), asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, 654.321, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_6.cpp
//
// composed_6.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/executor_work_guard.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations.
// It automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

template <typename T, typename CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](auto&& completion_handler, tcp::socket& socket,
      std::unique_ptr<std::string> encoded_message, std::size_t repeat_count,
      std::unique_ptr<asio::steady_timer> delay_timer)
  {
    // In this example, the composed operation's intermediate completion
    // handler is implemented as a hand-crafted function object.
    struct intermediate_completion_handler
    {
      // The intermediate completion handler holds a reference to the socket as
      // it is used for multiple async_write operations, as well as for
      // obtaining the I/O executor (see get_executor below).
      tcp::socket& socket_;

      // The allocated buffer for the encoded message. The std::unique_ptr
      // smart pointer is move-only, and as a consequence our intermediate
      // completion handler is also move-only.
      std::unique_ptr<std::string> encoded_message_;

      // The repeat count remaining.
      std::size_t repeat_count_;

      // A steady timer used for introducing a delay.
      std::unique_ptr<asio::steady_timer> delay_timer_;

      // To manage the cycle between the multiple underlying asychronous
      // operations, our intermediate completion handler is implemented as a
      // state machine.
      enum { starting, waiting, writing } state_;

      // As our composed operation performs multiple underlying I/O operations,
      // we should maintain a work object against the I/O executor. This tells
      // the I/O executor that there is still more work to come in the future.
      asio::executor_work_guard<tcp::socket::executor_type> io_work_;

      // The user-supplied completion handler, called once only on completion
      // of the entire composed operation.
      typename std::decay<decltype(completion_handler)>::type handler_;

      // By having a default value for the second argument, this function call
      // operator matches the completion signature of both the async_write and
      // steady_timer::async_wait operations.
      void operator()(const std::error_code& error, std::size_t = 0)
      {
        if (!error)
        {
          switch (state_)
          {
          case starting:
          case writing:
            if (repeat_count_ > 0)
            {
              --repeat_count_;
              state_ = waiting;
              delay_timer_->expires_after(std::chrono::seconds(1));
              delay_timer_->async_wait(std::move(*this));
              return; // Composed operation not yet complete.
            }
            break; // Composed operation complete, continue below.
          case waiting:
            state_ = writing;
            asio::async_write(socket_,
                asio::buffer(*encoded_message_), std::move(*this));
            return; // Composed operation not yet complete.
          }
        }

        // This point is reached only on completion of the entire composed
        // operation.

        // We no longer have any future work coming for the I/O executor.
        io_work_.reset();

        // Deallocate the encoded message before calling the user-supplied
        // completion handler.
        encoded_message_.reset();

        // Call the user-supplied handler with the result of the operation.
        handler_(error);
      }

      // It is essential to the correctness of our composed operation that we
      // preserve the executor of the user-supplied completion handler. With a
      // hand-crafted function object we can do this by defining a nested type
      // executor_type and member function get_executor. These obtain the
      // completion handler's associated executor, and default to the I/O
      // executor - in this case the executor of the socket - if the completion
      // handler does not have its own.
      using executor_type = asio::associated_executor_t<
          typename std::decay<decltype(completion_handler)>::type,
          tcp::socket::executor_type>;

      executor_type get_executor() const noexcept
      {
        return asio::get_associated_executor(
            handler_, socket_.get_executor());
      }

      // Although not necessary for correctness, we may also preserve the
      // allocator of the user-supplied completion handler. This is achieved by
      // defining a nested type allocator_type and member function
      // get_allocator. These obtain the completion handler's associated
      // allocator, and default to std::allocator<void> if the completion
      // handler does not have its own.
      using allocator_type = asio::associated_allocator_t<
          typename std::decay<decltype(completion_handler)>::type,
          std::allocator<void>>;

      allocator_type get_allocator() const noexcept
      {
        return asio::get_associated_allocator(
            handler_, std::allocator<void>{});
      }
    };

    // Initiate the underlying async_write operation using our intermediate
    // completion handler.
    auto encoded_message_buffer = asio::buffer(*encoded_message);
    asio::async_write(socket, encoded_message_buffer,
        intermediate_completion_handler{
          socket, std::move(encoded_message),
          repeat_count, std::move(delay_timer),
          intermediate_completion_handler::starting,
          asio::make_work_guard(socket.get_executor()),
          std::forward<decltype(completion_handler)>(completion_handler)});
  };

  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket),
      std::move(encoded_message), repeat_count,
      std::move(delay_timer));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_messages(socket,
      "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_7.cpp
//
// composed_7.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/compose.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_compose function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations.
// It automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

template <typename T, typename CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_compose.
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // To manage the cycle between the multiple underlying asychronous
  // operations, our implementation is a state machine.
  enum { starting, waiting, writing };

  // The asio::async_compose function takes:
  //
  // - our asynchronous operation implementation,
  // - the completion token,
  // - the completion handler signature, and
  // - any I/O objects (or executors) used by the operation
  //
  // It then wraps our implementation, which is implemented here as a state
  // machine in a lambda, in an intermediate completion handler that meets the
  // requirements of a conforming asynchronous operation. This includes
  // tracking outstanding work against the I/O executors associated with the
  // operation (in this example, this is the socket's executor).
  //
  // The first argument to our lambda is a reference to the enclosing
  // intermediate completion handler. This intermediate completion handler is
  // provided for us by the asio::async_compose function, and takes care
  // of all the details required to implement a conforming asynchronous
  // operation. When calling an underlying asynchronous operation, we pass it
  // this enclosing intermediate completion handler as the completion token.
  //
  // All arguments to our lambda after the first must be defaulted to allow the
  // state machine to be started, as well as to allow the completion handler to
  // match the completion signature of both the async_write and
  // steady_timer::async_wait operations.
  return asio::async_compose<
    CompletionToken, void(std::error_code)>(
      [
        // The implementation holds a reference to the socket as it is used for
        // multiple async_write operations.
        &socket,

        // The allocated buffer for the encoded message. The std::unique_ptr
        // smart pointer is move-only, and as a consequence our lambda
        // implementation is also move-only.
        encoded_message = std::move(encoded_message),

        // The repeat count remaining.
        repeat_count,

        // A steady timer used for introducing a delay.
        delay_timer = std::move(delay_timer),

        // To manage the cycle between the multiple underlying asychronous
        // operations, our implementation is a state machine.
        state = starting
      ]
      (
        auto& self,
        const std::error_code& error = {},
        std::size_t = 0
      ) mutable
      {
        if (!error)
        {
          switch (state)
          {
          case starting:
          case writing:
            if (repeat_count > 0)
            {
              --repeat_count;
              state = waiting;
              delay_timer->expires_after(std::chrono::seconds(1));
              delay_timer->async_wait(std::move(self));
              return; // Composed operation not yet complete.
            }
            break; // Composed operation complete, continue below.
          case waiting:
            state = writing;
            asio::async_write(socket,
                asio::buffer(*encoded_message), std::move(self));
            return; // Composed operation not yet complete.
          }
        }

        // This point is reached only on completion of the entire composed
        // operation.

        // Deallocate the encoded message and delay timer before calling the
        // user-supplied completion handler.
        encoded_message.reset();
        delay_timer.reset();

        // Call the user-supplied handler with the result of the operation.
        self.complete(error);
      },
      token, socket);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_messages(socket,
      "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\operations\composed_8.cpp
//
// composed_8.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/compose.hpp>
#include <asio/coroutine.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_compose function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations,
// using asio's stackless coroutines support to express the flow of control. It
// automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

#include <asio/yield.hpp>

template <typename T, typename CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++14 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_compose.
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_compose function takes:
  //
  // - our asynchronous operation implementation,
  // - the completion token,
  // - the completion handler signature, and
  // - any I/O objects (or executors) used by the operation
  //
  // It then wraps our implementation, which is implemented here as a stackless
  // coroutine in a lambda, in an intermediate completion handler that meets the
  // requirements of a conforming asynchronous operation. This includes
  // tracking outstanding work against the I/O executors associated with the
  // operation (in this example, this is the socket's executor).
  //
  // The first argument to our lambda is a reference to the enclosing
  // intermediate completion handler. This intermediate completion handler is
  // provided for us by the asio::async_compose function, and takes care
  // of all the details required to implement a conforming asynchronous
  // operation. When calling an underlying asynchronous operation, we pass it
  // this enclosing intermediate completion handler as the completion token.
  //
  // All arguments to our lambda after the first must be defaulted to allow the
  // state machine to be started, as well as to allow the completion handler to
  // match the completion signature of both the async_write and
  // steady_timer::async_wait operations.
  return asio::async_compose<
    CompletionToken, void(std::error_code)>(
      [
        // The implementation holds a reference to the socket as it is used for
        // multiple async_write operations.
        &socket,

        // The allocated buffer for the encoded message. The std::unique_ptr
        // smart pointer is move-only, and as a consequence our lambda
        // implementation is also move-only.
        encoded_message = std::move(encoded_message),

        // The repeat count remaining.
        repeat_count,

        // A steady timer used for introducing a delay.
        delay_timer = std::move(delay_timer),

        // The coroutine state.
        coro = asio::coroutine()
      ]
      (
        auto& self,
        const std::error_code& error = {},
        std::size_t = 0
      ) mutable
      {
        reenter (coro)
        {
          while (repeat_count > 0)
          {
            --repeat_count;

            delay_timer->expires_after(std::chrono::seconds(1));
            yield delay_timer->async_wait(std::move(self));
            if (error)
              break;

            yield asio::async_write(socket,
                asio::buffer(*encoded_message), std::move(self));
            if (error)
              break;
          }

          // Deallocate the encoded message and delay timer before calling the
          // user-supplied completion handler.
          encoded_message.reset();
          delay_timer.reset();

          // Call the user-supplied handler with the result of the operation.
          self.complete(error);
        }
      },
      token, socket);
}

#include <asio/unyield.hpp>

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_write_messages(socket,
      "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\parallel_group\parallel_sort.cpp
//
// parallel_sort.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <algorithm>
#include <chrono>
#include <functional>
#include <iostream>
#include <random>

template <
    typename Executor,
    typename RandomAccessIterator,
    ASIO_COMPLETION_TOKEN_FOR(void()) CompletionToken>
auto parallel_sort(
    Executor executor,
    RandomAccessIterator begin,
    RandomAccessIterator end,
    CompletionToken&& token);

template <
    typename Executor,
    typename RandomAccessIterator>
void parallel_sort_impl(
    Executor executor,
    RandomAccessIterator begin,
    RandomAccessIterator end,
    std::function<void()> continuation)
{
    std::size_t n = end - begin;
    if (n <= 16384)
    {
      asio::post(executor,
          [=]
          {
            std::sort(begin, end);
            continuation();
          }
        );
    }
    else
    {
      asio::experimental::make_parallel_group(
          [=](auto token)
          {
            return parallel_sort(executor, begin, begin + n / 2, token);
          },
          [=](auto token)
          {
            return parallel_sort(executor, begin + n / 2, end, token);
          }
        ).async_wait(
          asio::experimental::wait_for_all(),
          [=](std::array<std::size_t, 2>)
          {
            std::inplace_merge(begin, begin + n / 2, end);
            continuation();
          }
        );
    }
}

template <
    typename Executor,
    typename RandomAccessIterator,
    ASIO_COMPLETION_TOKEN_FOR(void()) CompletionToken>
auto parallel_sort(
    Executor executor,
    RandomAccessIterator begin,
    RandomAccessIterator end,
    CompletionToken&& token)
{
  return asio::async_compose<CompletionToken, void()>(
      [=](auto& self, auto... args)
      {
        if (sizeof...(args) == 0)
        {
          using self_type = std::decay_t<decltype(self)>;
          parallel_sort_impl(executor, begin, end,
              [self = std::make_shared<self_type>(std::move(self))]
              {
                asio::dispatch(
                    asio::append(
                      std::move(*self), 0));
              }
            );
        }
        else
        {
          self.complete();
        }
      },
      token
    );
}

int main()
{
  asio::thread_pool pool(4);

  std::vector<int> values(100'000'000);

  std::random_device random_device;
  std::mt19937 rng(random_device());
  std::uniform_int_distribution<int> dist(1, 1'000'000);
  std::generate(values.begin(), values.end(), [&]{ return dist(rng); });

  std::cout << "starting sort\n";

  auto begin = std::chrono::high_resolution_clock::now();

  parallel_sort(
      pool.get_executor(),
      values.begin(),
      values.end(),
      asio::use_future
    ).get();
  
  auto end = std::chrono::high_resolution_clock::now();

  auto duration = end - begin;
  std::cout << "sort took "
    << std::chrono::duration_cast<std::chrono::microseconds>(duration).count()
    << " microseconds\n";
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\parallel_group\ranged_wait_for_all.cpp
//
// ranged_wait_for_all.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>
#include <vector>

#ifdef ASIO_HAS_POSIX_STREAM_DESCRIPTOR

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor out(ctx, ::dup(STDOUT_FILENO));
  asio::posix::stream_descriptor err(ctx, ::dup(STDERR_FILENO));

  using op_type = decltype(
      out.async_write_some(
        asio::buffer("", 0),
        asio::deferred
      )
    );

  std::vector<op_type> ops;

  ops.push_back(
      out.async_write_some(
        asio::buffer("first\r\n", 7),
        asio::deferred
      )
    );

  ops.push_back(
      err.async_write_some(
        asio::buffer("second\r\n", 8),
        asio::deferred
      )
    );

  asio::experimental::make_parallel_group(ops).async_wait(
      asio::experimental::wait_for_all(),
      [](
          std::vector<std::size_t> completion_order,
          std::vector<std::error_code> ec,
          std::vector<std::size_t> n
      )
      {
        for (std::size_t i = 0; i < completion_order.size(); ++i)
        {
          std::size_t idx = completion_order[i];
          std::cout << "operation " << idx << " finished: ";
          std::cout << ec[idx] << ", " << n[idx] << "\n";
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\parallel_group\wait_for_all.cpp
//
// wait_for_all.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#ifdef ASIO_HAS_POSIX_STREAM_DESCRIPTOR

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      [&](auto token)
      {
        return in.async_read_some(asio::buffer(data), token);
      },
      [&](auto token)
      {
        return timer.async_wait(token);
      }
    ).async_wait(
      asio::experimental::wait_for_all(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\parallel_group\wait_for_one_error.cpp
//
// wait_for_one_error.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      [&](auto token)
      {
        return in.async_read_some(asio::buffer(data), token);
      },
      [&](auto token)
      {
        return timer.async_wait(token);
      }
    ).async_wait(
      asio::experimental::wait_for_one_error(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\parallel_group\wait_for_one_success.cpp
//
// wait_for_one_error.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      [&](auto token)
      {
        return in.async_read_some(asio::buffer(data), token);
      },
      [&](auto token)
      {
        return timer.async_wait(token);
      }
    ).async_wait(
      asio::experimental::wait_for_one_success(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp14\parallel_group\wait_for_one.cpp
//
// wait_for_one.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/parallel_group.hpp>
#include <iostream>

#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

int main()
{
  asio::io_context ctx;

  asio::posix::stream_descriptor in(ctx, ::dup(STDIN_FILENO));
  asio::steady_timer timer(ctx, std::chrono::seconds(5));

  char data[1024];

  asio::experimental::make_parallel_group(
      [&](auto token)
      {
        return in.async_read_some(asio::buffer(data), token);
      },
      [&](auto token)
      {
        return timer.async_wait(token);
      }
    ).async_wait(
      asio::experimental::wait_for_one(),
      [](
          std::array<std::size_t, 2> completion_order,
          std::error_code ec1, std::size_t n1,
          std::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );

  ctx.run();
}

#else // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
int main() {}
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\chat_server.cpp
//
// chat_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <deque>
#include <iostream>
#include <list>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <asio/awaitable.hpp>
#include <asio/detached.hpp>
#include <asio/co_spawn.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/read_until.hpp>
#include <asio/redirect_error.hpp>
#include <asio/signal_set.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_awaitable.hpp>
#include <asio/write.hpp>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::redirect_error;
using asio::use_awaitable;

//----------------------------------------------------------------------

class chat_participant
{
public:
  virtual ~chat_participant() {}
  virtual void deliver(const std::string& msg) = 0;
};

typedef std::shared_ptr<chat_participant> chat_participant_ptr;

//----------------------------------------------------------------------

class chat_room
{
public:
  void join(chat_participant_ptr participant)
  {
    participants_.insert(participant);
    for (auto msg: recent_msgs_)
      participant->deliver(msg);
  }

  void leave(chat_participant_ptr participant)
  {
    participants_.erase(participant);
  }

  void deliver(const std::string& msg)
  {
    recent_msgs_.push_back(msg);
    while (recent_msgs_.size() > max_recent_msgs)
      recent_msgs_.pop_front();

    for (auto participant: participants_)
      participant->deliver(msg);
  }

private:
  std::set<chat_participant_ptr> participants_;
  enum { max_recent_msgs = 100 };
  std::deque<std::string> recent_msgs_;
};

//----------------------------------------------------------------------

class chat_session
  : public chat_participant,
    public std::enable_shared_from_this<chat_session>
{
public:
  chat_session(tcp::socket socket, chat_room& room)
    : socket_(std::move(socket)),
      timer_(socket_.get_executor()),
      room_(room)
  {
    timer_.expires_at(std::chrono::steady_clock::time_point::max());
  }

  void start()
  {
    room_.join(shared_from_this());

    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->reader(); },
        detached);

    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->writer(); },
        detached);
  }

  void deliver(const std::string& msg)
  {
    write_msgs_.push_back(msg);
    timer_.cancel_one();
  }

private:
  awaitable<void> reader()
  {
    try
    {
      for (std::string read_msg;;)
      {
        std::size_t n = co_await asio::async_read_until(socket_,
            asio::dynamic_buffer(read_msg, 1024), "\n", use_awaitable);

        room_.deliver(read_msg.substr(0, n));
        read_msg.erase(0, n);
      }
    }
    catch (std::exception&)
    {
      stop();
    }
  }

  awaitable<void> writer()
  {
    try
    {
      while (socket_.is_open())
      {
        if (write_msgs_.empty())
        {
          asio::error_code ec;
          co_await timer_.async_wait(redirect_error(use_awaitable, ec));
        }
        else
        {
          co_await asio::async_write(socket_,
              asio::buffer(write_msgs_.front()), use_awaitable);
          write_msgs_.pop_front();
        }
      }
    }
    catch (std::exception&)
    {
      stop();
    }
  }

  void stop()
  {
    room_.leave(shared_from_this());
    socket_.close();
    timer_.cancel();
  }

  tcp::socket socket_;
  asio::steady_timer timer_;
  chat_room& room_;
  std::deque<std::string> write_msgs_;
};

//----------------------------------------------------------------------

awaitable<void> listener(tcp::acceptor acceptor)
{
  chat_room room;

  for (;;)
  {
    std::make_shared<chat_session>(
        co_await acceptor.async_accept(use_awaitable),
        room
      )->start();
  }
}

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    if (argc < 2)
    {
      std::cerr << "Usage: chat_server <port> [<port> ...]\n";
      return 1;
    }

    asio::io_context io_context(1);

    for (int i = 1; i < argc; ++i)
    {
      unsigned short port = std::atoi(argv[i]);
      co_spawn(io_context,
          listener(tcp::acceptor(io_context, {tcp::v4(), port})),
          detached);
    }

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\echo_server_with_as_single_default.cpp
//
// echo_server_with_as_single_default.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/experimental/as_single.hpp>
#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::experimental::as_single_t;
using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable_t;
using default_token = as_single_t<use_awaitable_t<>>;
using tcp_acceptor = default_token::as_default_on_t<tcp::acceptor>;
using tcp_socket = default_token::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  char data[1024];
  for (;;)
  {
    auto [e1, nread] = co_await socket.async_read_some(asio::buffer(data));
    if (nread == 0) break;
    auto [e2, nwritten] = co_await async_write(socket, asio::buffer(data, nread));
    if (nwritten != nread) break;
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    if (auto [e, socket] = co_await acceptor.async_accept(); socket.is_open())
      co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\echo_server_with_as_tuple_default.cpp
//
// echo_server_with_as_tuple_default.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/as_tuple.hpp>
#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::as_tuple_t;
using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable_t;
using default_token = as_tuple_t<use_awaitable_t<>>;
using tcp_acceptor = default_token::as_default_on_t<tcp::acceptor>;
using tcp_socket = default_token::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  char data[1024];
  for (;;)
  {
    auto [e1, nread] = co_await socket.async_read_some(asio::buffer(data));
    if (nread == 0) break;
    auto [e2, nwritten] = co_await async_write(socket, asio::buffer(data, nread));
    if (nwritten != nread) break;
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    if (auto [e, socket] = co_await acceptor.async_accept(); socket.is_open())
      co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\echo_server_with_default.cpp
//
// echo_server_with_default.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable_t;
using tcp_acceptor = use_awaitable_t<>::as_default_on_t<tcp::acceptor>;
using tcp_socket = use_awaitable_t<>::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data));
      co_await async_write(socket, asio::buffer(data, n));
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    auto socket = co_await acceptor.async_accept();
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\echo_server.cpp
//
// echo_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;
namespace this_coro = asio::this_coro;

#if defined(ASIO_ENABLE_HANDLER_TRACKING)
# define use_awaitable \
  asio::use_awaitable_t(__FILE__, __LINE__, __PRETTY_FUNCTION__)
#endif

awaitable<void> echo(tcp::socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data), use_awaitable);
      co_await async_write(socket, asio::buffer(data, n), use_awaitable);
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept(use_awaitable);
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\range_based_for.cpp
//
// range_based_for.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;

class connection_iter
{
  friend class connections;
  tcp::acceptor* acceptor_ = nullptr;
  tcp::socket socket_;

  connection_iter(tcp::acceptor& a, tcp::socket s)
    : acceptor_(&a), socket_(std::move(s)) {}

public:
  tcp::socket operator*()
  {
    return std::move(socket_);
  }

  awaitable<void> operator++()
  {
    socket_ = co_await acceptor_->async_accept(use_awaitable);
  }

  bool operator==(const connection_iter&) const noexcept
  {
    return false;
  }

  bool operator!=(const connection_iter&) const noexcept
  {
    return true;
  }
};

class connections
{
  tcp::acceptor& acceptor_;

public:
  explicit connections(tcp::acceptor& a) : acceptor_(a) {}

  awaitable<connection_iter> begin()
  {
    tcp::socket s = co_await acceptor_.async_accept(use_awaitable);
    co_return connection_iter(acceptor_, std::move(s));
  }

  connection_iter end()
  {
    return connection_iter(acceptor_,
        tcp::socket(acceptor_.get_executor()));
  }
};

awaitable<void> listener(tcp::acceptor acceptor)
{
  for co_await (tcp::socket s : connections(acceptor))
  {
    co_await asio::async_write(s, asio::buffer("hello\r\n", 7), use_awaitable);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
    co_spawn(io_context, listener(std::move(acceptor)), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp17\coroutines_ts\refactored_echo_server.cpp
//
// refactored_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;
namespace this_coro = asio::this_coro;

awaitable<void> echo_once(tcp::socket& socket)
{
  char data[128];
  std::size_t n = co_await socket.async_read_some(asio::buffer(data), use_awaitable);
  co_await async_write(socket, asio::buffer(data, n), use_awaitable);
}

awaitable<void> echo(tcp::socket socket)
{
  try
  {
    for (;;)
    {
      // The asynchronous operations to echo a single chunk of data have been
      // refactored into a separate function. When this function is called, the
      // operations are still performed in the context of the current
      // coroutine, and the behaviour is functionally equivalent.
      co_await echo_once(socket);
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept(use_awaitable);
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\channels\mutual_exclusion_1.cpp
//
// mutual_exclusion_1.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/channel.hpp>
#include <iostream>
#include <memory>

using asio::as_tuple;
using asio::awaitable;
using asio::dynamic_buffer;
using asio::co_spawn;
using asio::deferred;
using asio::detached;
using asio::experimental::channel;
using asio::io_context;
using asio::ip::tcp;
using asio::steady_timer;
using namespace asio::buffer_literals;
using namespace std::literals::chrono_literals;

// This class implements a simple line-based protocol:
//
// * For event line that is received from the client, the session sends a
//   message header followed by the content of the line as the message body.
//
// * The session generates heartbeat messages once a second.
//
// This protocol is implemented using two actors, handle_messages() and
// send_heartbeats(), each written as a coroutine.
class line_based_echo_session :
  public std::enable_shared_from_this<line_based_echo_session>
{
  // The socket used to read from and write to the client. This socket is a
  // data member as it is shared between the two actors.
  tcp::socket socket_;

  // As both of the actors will write to the socket, we need a lock to prevent
  // these writes from overlapping. To achieve this, we use a channel with a
  // buffer size of one. The lock is claimed by sending a message to the
  // channel, and then released by receiving this message back again. If the
  // lock is not held then the channel's buffer is empty, and the send will
  // complete without delay. Otherwise, if the lock is held by the other actor,
  // then the send operation will not complete until the lock is released.
  channel<void()> write_lock_{socket_.get_executor(), 1};

public:
  line_based_echo_session(tcp::socket socket)
    : socket_{std::move(socket)}
  {
    socket_.set_option(tcp::no_delay(true));
  }

  void start()
  {
    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->handle_messages(); },
        detached);

    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->send_heartbeats(); },
        detached);
  }

private:
  void stop()
  {
    socket_.close();
    write_lock_.cancel();
  }

  awaitable<void> handle_messages()
  {
    try
    {
      constexpr std::size_t max_line_length = 1024;
      std::string data;
      for (;;)
      {
        // Read an entire line from the client.
        std::size_t length = co_await async_read_until(socket_,
            dynamic_buffer(data, max_line_length), '\n', deferred);

        // Claim the write lock by sending a message to the channel. Since the
        // channel signature is void(), there are no arguments to send in the
        // message itself.
        co_await write_lock_.async_send(deferred);

        // Respond to the client with a message, echoing the line they sent.
        co_await async_write(socket_, "<line>"_buf, deferred);
        co_await async_write(socket_, dynamic_buffer(data, length), deferred);

        // Release the lock by receiving the message back again.
        write_lock_.try_receive([](auto...){});
      }
    }
    catch (const std::exception&)
    {
      stop();
    }
  }
 
  awaitable<void> send_heartbeats()
  {
    steady_timer timer{socket_.get_executor()};
    try
    {
      for (;;)
      {
        // Wait one second before trying to send the next heartbeat.
        timer.expires_after(1s);
        co_await timer.async_wait(deferred);

        // Claim the write lock by sending a message to the channel. Since the
        // channel signature is void(), there are no arguments to send in the
        // message itself.
        co_await write_lock_.async_send(deferred);

        // Send a heartbeat to the client. As the content of the heartbeat
        // message never varies, a buffer literal can be used to specify the
        // bytes of the message. The memory associated with a buffer literal is
        // valid for the lifetime of the program, which mean that the buffer
        // can be safely passed as-is to the asynchronous operation.
        co_await async_write(socket_, "<heartbeat>\n"_buf, deferred);

        // Release the lock by receiving the message back again.
        write_lock_.try_receive([](auto...){});
      }
    }
    catch (const std::exception&)
    {
      stop();
    }
  }

};

awaitable<void> listen(tcp::acceptor& acceptor)
{
  for (;;)
  {
    auto [e, socket] = co_await acceptor.async_accept(as_tuple(deferred));
    if (!e)
    {
      std::make_shared<line_based_echo_session>(std::move(socket))->start();
    }
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: mutual_exclusion_1";
      std::cerr << " <listen_address> <listen_port>\n";
      return 1;
    }

    io_context ctx;

    auto listen_endpoint =
      *tcp::resolver(ctx).resolve(argv[1], argv[2],
          tcp::resolver::passive).begin();

    tcp::acceptor acceptor(ctx, listen_endpoint);
    co_spawn(ctx, listen(acceptor), detached);
    ctx.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\channels\mutual_exclusion_2.cpp
//
// mutual_exclusion_2.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/channel.hpp>
#include <iostream>
#include <memory>

using asio::as_tuple;
using asio::awaitable;
using asio::dynamic_buffer;
using asio::co_spawn;
using asio::deferred;
using asio::detached;
using asio::experimental::channel;
using asio::io_context;
using asio::ip::tcp;
using asio::steady_timer;
using namespace asio::buffer_literals;
using namespace std::literals::chrono_literals;

// This class implements a simple line-based protocol:
//
// * For event line that is received from the client, the session sends a
//   message header followed by the content of the line as the message body.
//
// * The session generates heartbeat messages once a second.
//
// This protocol is implemented using two actors, handle_messages() and
// send_heartbeats(), each written as a coroutine.
class line_based_echo_session :
  public std::enable_shared_from_this<line_based_echo_session>
{
  // The socket used to read from and write to the client. This socket is a
  // data member as it is shared between the two actors.
  tcp::socket socket_;

  // As both of the actors will write to the socket, we need a lock to prevent
  // these writes from overlapping. To achieve this, we use a channel with a
  // buffer size of one. The lock is claimed by sending a message to the
  // channel, and then released by receiving this message back again. If the
  // lock is not held then the channel's buffer is empty, and the send will
  // complete without delay. Otherwise, if the lock is held by the other actor,
  // then the send operation will not complete until the lock is released.
  channel<void()> write_lock_{socket_.get_executor(), 1};

public:
  line_based_echo_session(tcp::socket socket)
    : socket_{std::move(socket)}
  {
    socket_.set_option(tcp::no_delay(true));
  }

  void start()
  {
    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->handle_messages(); },
        detached);

    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->send_heartbeats(); },
        detached);
  }

private:
  void stop()
  {
    socket_.close();
    write_lock_.cancel();
  }

  awaitable<void> handle_messages()
  {
    try
    {
      constexpr std::size_t max_line_length = 1024;
      std::string data;
      for (;;)
      {
        // Read an entire line from the client.
        std::size_t length = co_await async_read_until(socket_,
            dynamic_buffer(data, max_line_length), '\n', deferred);

        // Claim the write lock by sending a message to the channel. Since the
        // channel signature is void(), there are no arguments to send in the
        // message itself. In this example we optimise for the common case,
        // where the lock is not held by the other actor, by first trying a
        // non-blocking send.
        if (!write_lock_.try_send())
        {
          co_await write_lock_.async_send(deferred);
        }

        // Respond to the client with a message, echoing the line they sent.
        co_await async_write(socket_, "<line>"_buf, deferred);
        co_await async_write(socket_, dynamic_buffer(data, length), deferred);

        // Release the lock by receiving the message back again.
        write_lock_.try_receive([](auto...){});
      }
    }
    catch (const std::exception&)
    {
      stop();
    }
  }
 
  awaitable<void> send_heartbeats()
  {
    steady_timer timer{socket_.get_executor()};
    try
    {
      for (;;)
      {
        // Wait one second before trying to send the next heartbeat.
        timer.expires_after(1s);
        co_await timer.async_wait(deferred);

        // Claim the write lock by sending a message to the channel. Since the
        // channel signature is void(), there are no arguments to send in the
        // message itself. In this example we optimise for the common case,
        // where the lock is not held by the other actor, by first trying a
        // non-blocking send.
        if (!write_lock_.try_send())
        {
          co_await write_lock_.async_send(deferred);
        }

        // Send a heartbeat to the client. As the content of the heartbeat
        // message never varies, a buffer literal can be used to specify the
        // bytes of the message. The memory associated with a buffer literal is
        // valid for the lifetime of the program, which mean that the buffer
        // can be safely passed as-is to the asynchronous operation.
        co_await async_write(socket_, "<heartbeat>\n"_buf, deferred);

        // Release the lock by receiving the message back again.
        write_lock_.try_receive([](auto...){});
      }
    }
    catch (const std::exception&)
    {
      stop();
    }
  }

};

awaitable<void> listen(tcp::acceptor& acceptor)
{
  for (;;)
  {
    auto [e, socket] = co_await acceptor.async_accept(as_tuple(deferred));
    if (!e)
    {
      std::make_shared<line_based_echo_session>(std::move(socket))->start();
    }
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 3)
    {
      std::cerr << "Usage: mutual_exclusion_1";
      std::cerr << " <listen_address> <listen_port>\n";
      return 1;
    }

    io_context ctx;

    auto listen_endpoint =
      *tcp::resolver(ctx).resolve(argv[1], argv[2],
          tcp::resolver::passive).begin();

    tcp::acceptor acceptor(ctx, listen_endpoint);
    co_spawn(ctx, listen(acceptor), detached);
    ctx.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\channels\throttling_proxy.cpp
//
// throttling_proxy.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/awaitable_operators.hpp>
#include <asio/experimental/channel.hpp>
#include <iostream>

using asio::as_tuple;
using asio::awaitable;
using asio::buffer;
using asio::co_spawn;
using asio::detached;
using asio::experimental::channel;
using asio::io_context;
using asio::ip::tcp;
using asio::steady_timer;
using asio::use_awaitable;
namespace this_coro = asio::this_coro;
using namespace asio::experimental::awaitable_operators;
using namespace std::literals::chrono_literals;

using token_channel = channel<void(asio::error_code, std::size_t)>;

awaitable<void> produce_tokens(std::size_t bytes_per_token,
    steady_timer::duration token_interval, token_channel& tokens)
{
  steady_timer timer(co_await this_coro::executor);
  for (;;)
  {
    co_await tokens.async_send(
        asio::error_code{}, bytes_per_token,
        use_awaitable);

    timer.expires_after(token_interval);
    co_await timer.async_wait(use_awaitable);
  }
}

awaitable<void> transfer(tcp::socket& from,
    tcp::socket& to, token_channel& tokens)
{
  std::array<unsigned char, 4096> data;
  for (;;)
  {
    std::size_t bytes_available = co_await tokens.async_receive(use_awaitable);
    while (bytes_available > 0)
    {
      std::size_t n = co_await from.async_read_some(
          buffer(data, bytes_available), use_awaitable);

      co_await async_write(to, buffer(data, n), use_awaitable);

      bytes_available -= n;
    }
  }
}

awaitable<void> proxy(tcp::socket client, tcp::endpoint target)
{
  constexpr std::size_t number_of_tokens = 100;
  constexpr size_t bytes_per_token = 20 * 1024;
  constexpr steady_timer::duration token_interval = 100ms;

  auto ex = client.get_executor();
  tcp::socket server(ex);
  token_channel client_tokens(ex, number_of_tokens);
  token_channel server_tokens(ex, number_of_tokens);

  co_await server.async_connect(target, use_awaitable);
  co_await (
      produce_tokens(bytes_per_token, token_interval, client_tokens) &&
      transfer(client, server, client_tokens) &&
      produce_tokens(bytes_per_token, token_interval, server_tokens) &&
      transfer(server, client, server_tokens)
    );
}

awaitable<void> listen(tcp::acceptor& acceptor, tcp::endpoint target)
{
  for (;;)
  {
    auto [e, client] = co_await acceptor.async_accept(as_tuple(use_awaitable));
    if (!e)
    {
      auto ex = client.get_executor();
      co_spawn(ex, proxy(std::move(client), target), detached);
    }
    else
    {
      std::cerr << "Accept failed: " << e.message() << "\n";
      steady_timer timer(co_await this_coro::executor);
      timer.expires_after(100ms);
      co_await timer.async_wait(use_awaitable);
    }
  }
}

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 5)
    {
      std::cerr << "Usage: throttling_proxy";
      std::cerr << " <listen_address> <listen_port>";
      std::cerr << " <target_address> <target_port>\n";
      return 1;
    }

    io_context ctx;

    auto listen_endpoint =
      *tcp::resolver(ctx).resolve(argv[1], argv[2],
          tcp::resolver::passive).begin();

    auto target_endpoint =
      *tcp::resolver(ctx).resolve(argv[3], argv[4]).begin();

    tcp::acceptor acceptor(ctx, listen_endpoint);
    co_spawn(ctx, listen(acceptor, target_endpoint), detached);
    ctx.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\chat_server.cpp
//
// chat_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <cstdlib>
#include <deque>
#include <iostream>
#include <list>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <asio/awaitable.hpp>
#include <asio/detached.hpp>
#include <asio/co_spawn.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/read_until.hpp>
#include <asio/redirect_error.hpp>
#include <asio/signal_set.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_awaitable.hpp>
#include <asio/write.hpp>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::redirect_error;
using asio::use_awaitable;

//----------------------------------------------------------------------

class chat_participant
{
public:
  virtual ~chat_participant() {}
  virtual void deliver(const std::string& msg) = 0;
};

typedef std::shared_ptr<chat_participant> chat_participant_ptr;

//----------------------------------------------------------------------

class chat_room
{
public:
  void join(chat_participant_ptr participant)
  {
    participants_.insert(participant);
    for (auto msg: recent_msgs_)
      participant->deliver(msg);
  }

  void leave(chat_participant_ptr participant)
  {
    participants_.erase(participant);
  }

  void deliver(const std::string& msg)
  {
    recent_msgs_.push_back(msg);
    while (recent_msgs_.size() > max_recent_msgs)
      recent_msgs_.pop_front();

    for (auto participant: participants_)
      participant->deliver(msg);
  }

private:
  std::set<chat_participant_ptr> participants_;
  enum { max_recent_msgs = 100 };
  std::deque<std::string> recent_msgs_;
};

//----------------------------------------------------------------------

class chat_session
  : public chat_participant,
    public std::enable_shared_from_this<chat_session>
{
public:
  chat_session(tcp::socket socket, chat_room& room)
    : socket_(std::move(socket)),
      timer_(socket_.get_executor()),
      room_(room)
  {
    timer_.expires_at(std::chrono::steady_clock::time_point::max());
  }

  void start()
  {
    room_.join(shared_from_this());

    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->reader(); },
        detached);

    co_spawn(socket_.get_executor(),
        [self = shared_from_this()]{ return self->writer(); },
        detached);
  }

  void deliver(const std::string& msg)
  {
    write_msgs_.push_back(msg);
    timer_.cancel_one();
  }

private:
  awaitable<void> reader()
  {
    try
    {
      for (std::string read_msg;;)
      {
        std::size_t n = co_await asio::async_read_until(socket_,
            asio::dynamic_buffer(read_msg, 1024), "\n", use_awaitable);

        room_.deliver(read_msg.substr(0, n));
        read_msg.erase(0, n);
      }
    }
    catch (std::exception&)
    {
      stop();
    }
  }

  awaitable<void> writer()
  {
    try
    {
      while (socket_.is_open())
      {
        if (write_msgs_.empty())
        {
          asio::error_code ec;
          co_await timer_.async_wait(redirect_error(use_awaitable, ec));
        }
        else
        {
          co_await asio::async_write(socket_,
              asio::buffer(write_msgs_.front()), use_awaitable);
          write_msgs_.pop_front();
        }
      }
    }
    catch (std::exception&)
    {
      stop();
    }
  }

  void stop()
  {
    room_.leave(shared_from_this());
    socket_.close();
    timer_.cancel();
  }

  tcp::socket socket_;
  asio::steady_timer timer_;
  chat_room& room_;
  std::deque<std::string> write_msgs_;
};

//----------------------------------------------------------------------

awaitable<void> listener(tcp::acceptor acceptor)
{
  chat_room room;

  for (;;)
  {
    std::make_shared<chat_session>(
        co_await acceptor.async_accept(use_awaitable),
        room
      )->start();
  }
}

//----------------------------------------------------------------------

int main(int argc, char* argv[])
{
  try
  {
    if (argc < 2)
    {
      std::cerr << "Usage: chat_server <port> [<port> ...]\n";
      return 1;
    }

    asio::io_context io_context(1);

    for (int i = 1; i < argc; ++i)
    {
      unsigned short port = std::atoi(argv[i]);
      co_spawn(io_context,
          listener(tcp::acceptor(io_context, {tcp::v4(), port})),
          detached);
    }

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\echo_server_with_as_single_default.cpp
//
// echo_server_with_as_single_default.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/experimental/as_single.hpp>
#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::experimental::as_single_t;
using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable_t;
using default_token = as_single_t<use_awaitable_t<>>;
using tcp_acceptor = default_token::as_default_on_t<tcp::acceptor>;
using tcp_socket = default_token::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  char data[1024];
  for (;;)
  {
    auto [e1, nread] = co_await socket.async_read_some(asio::buffer(data));
    if (nread == 0) break;
    auto [e2, nwritten] = co_await async_write(socket, asio::buffer(data, nread));
    if (nwritten != nread) break;
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    if (auto [e, socket] = co_await acceptor.async_accept(); socket.is_open())
      co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\echo_server_with_as_tuple_default.cpp
//
// echo_server_with_as_tuple_default.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/as_tuple.hpp>
#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::as_tuple_t;
using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable_t;
using default_token = as_tuple_t<use_awaitable_t<>>;
using tcp_acceptor = default_token::as_default_on_t<tcp::acceptor>;
using tcp_socket = default_token::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  char data[1024];
  for (;;)
  {
    auto [e1, nread] = co_await socket.async_read_some(asio::buffer(data));
    if (nread == 0) break;
    auto [e2, nwritten] = co_await async_write(socket, asio::buffer(data, nread));
    if (nwritten != nread) break;
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    if (auto [e, socket] = co_await acceptor.async_accept(); socket.is_open())
      co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\echo_server_with_default.cpp
//
// echo_server_with_default.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable_t;
using tcp_acceptor = use_awaitable_t<>::as_default_on_t<tcp::acceptor>;
using tcp_socket = use_awaitable_t<>::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data));
      co_await async_write(socket, asio::buffer(data, n));
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    auto socket = co_await acceptor.async_accept();
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\echo_server_with_deferred_default.cpp
//
// echo_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/deferred.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using default_token = asio::deferred_t;
using tcp_acceptor = default_token::as_default_on_t<tcp::acceptor>;
using tcp_socket = default_token::as_default_on_t<tcp::socket>;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp_socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data));
      co_await async_write(socket, asio::buffer(data, n));
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp_acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept();
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\echo_server_with_deferred.cpp
//
// echo_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/deferred.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::deferred;
using asio::detached;
namespace this_coro = asio::this_coro;

awaitable<void> echo(tcp::socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data), deferred);
      co_await async_write(socket, asio::buffer(data, n), deferred);
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept(deferred);
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\echo_server.cpp
//
// echo_server.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;
namespace this_coro = asio::this_coro;

#if defined(ASIO_ENABLE_HANDLER_TRACKING)
# define use_awaitable \
  asio::use_awaitable_t(__FILE__, __LINE__, __PRETTY_FUNCTION__)
#endif

awaitable<void> echo(tcp::socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data), use_awaitable);
      co_await async_write(socket, asio::buffer(data, n), use_awaitable);
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept(use_awaitable);
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\refactored_echo_server.cpp
//
// refactored_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/signal_set.hpp>
#include <asio/write.hpp>
#include <cstdio>

using asio::ip::tcp;
using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;
namespace this_coro = asio::this_coro;

awaitable<void> echo_once(tcp::socket& socket)
{
  char data[128];
  std::size_t n = co_await socket.async_read_some(asio::buffer(data), use_awaitable);
  co_await async_write(socket, asio::buffer(data, n), use_awaitable);
}

awaitable<void> echo(tcp::socket socket)
{
  try
  {
    for (;;)
    {
      // The asynchronous operations to echo a single chunk of data have been
      // refactored into a separate function. When this function is called, the
      // operations are still performed in the context of the current
      // coroutine, and the behaviour is functionally equivalent.
      co_await echo_once(socket);
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept(use_awaitable);
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int main()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\coroutines\timeout.cpp
//
// timeout.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <asio/experimental/awaitable_operators.hpp>

using namespace asio;
using namespace asio::experimental::awaitable_operators;
using time_point = std::chrono::steady_clock::time_point;
using ip::tcp;

awaitable<void> echo(tcp::socket& sock, time_point& deadline)
{
  char data[4196];
  for (;;)
  {
    deadline = std::chrono::steady_clock::now() + std::chrono::seconds(10);
    auto n = co_await sock.async_read_some(buffer(data), use_awaitable);
    co_await async_write(sock, buffer(data, n), use_awaitable);
  }
}

awaitable<void> watchdog(time_point& deadline)
{
  steady_timer timer(co_await this_coro::executor);
  auto now = std::chrono::steady_clock::now();
  while (deadline > now)
  {
    timer.expires_at(deadline);
    co_await timer.async_wait(use_awaitable);
    now = std::chrono::steady_clock::now();
  }
  throw std::system_error(std::make_error_code(std::errc::timed_out));
}

awaitable<void> handle_connection(tcp::socket sock)
{
  time_point deadline{};
  co_await (echo(sock, deadline) && watchdog(deadline));
}

awaitable<void> listen(tcp::acceptor& acceptor)
{
  for (;;)
  {
    co_spawn(
        acceptor.get_executor(),
        handle_connection(co_await acceptor.async_accept(use_awaitable)),
        detached);
  }
}

int main()
{
  io_context ctx;
  tcp::acceptor acceptor(ctx, {tcp::v4(), 54321});
  co_spawn(ctx, listen(acceptor), detached);
  ctx.run();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\invocation\completion_executor.cpp
//
// completion_executor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio.hpp"
#include <concepts>
#include <iostream>

using asio::ip::tcp;

//----------------------------------------------------------------------

// The logging_executor class implements a minimal executor that satisfies the
// requirements for use as a completion executor. This means it may be bound to
// a handler using bind_executor.
class logging_executor
{
public:
  // All executors must be no-throw equality comparable.
  bool operator==(const logging_executor&) const noexcept = default;

  // All executors must provide a const member function execute().
  void execute(std::invocable auto handler) const
  {
    try
    {
      std::cout << "handler invocation starting\n";
      std::move(handler)();
      std::cout << "handler invocation complete\n";
    }
    catch (...)
    {
      std::cout << "handler invocation completed with exception\n";
      throw;
    }
  }
};

// Confirm that a logging_executor satisfies the executor requirements.
static_assert(asio::execution::executor<logging_executor>);

// Confirm that a logging_executor can be used as a completion executor.
static_assert(std::convertible_to<
    logging_executor, asio::any_completion_executor>);

//----------------------------------------------------------------------

int main()
{
  asio::io_context io_context(1);

  // Post a completion handler to be run immediately.
  asio::post(io_context,
      asio::bind_executor(logging_executor{},
        []{ std::cout << "post complete\n"; }));

  // Start an asynchronous accept that will complete immediately.
  tcp::endpoint endpoint(asio::ip::address_v4::loopback(), 0);
  tcp::acceptor acceptor(io_context, endpoint);
  tcp::socket server_socket(io_context);
  acceptor.async_accept(
      asio::bind_executor(logging_executor{},
        [](auto...){ std::cout << "async_accept complete\n"; }));
  tcp::socket client_socket(io_context);
  client_socket.connect(acceptor.local_endpoint());

  // Set a timer to expire immediately.
  asio::steady_timer timer(io_context);
  timer.expires_at(asio::steady_timer::clock_type::time_point::min());
  timer.async_wait(
      asio::bind_executor(logging_executor{},
        [](auto){ std::cout << "async_wait complete\n"; }));

  io_context.run();

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\c_callback_wrapper.cpp
//
// c_callback_wrapper.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>
#include <memory>
#include <new>

//------------------------------------------------------------------------------

// This is a mock implementation of a C-based API that uses the function pointer
// plus void* context idiom for exposing a callback.

void read_input(const char* prompt, void (*cb)(void*, const char*), void* arg)
{
  std::thread(
      [prompt = std::string(prompt), cb, arg]
      {
        std::cout << prompt << ": ";
        std::cout.flush();
        std::string line;
        std::getline(std::cin, line);
        cb(arg, line.c_str());
      }).detach();
}

//------------------------------------------------------------------------------

// This is an asynchronous operation that wraps the C-based API.

// To map our completion handler into a function pointer / void* callback, we
// need to allocate some state that will live for the duration of the
// operation. A pointer to this state will be passed to the C-based API.
template <asio::completion_handler_for<void(std::string)> Handler>
class read_input_state
{
public:
  read_input_state(Handler&& handler)
    : handler_(std::move(handler)),
      work_(asio::make_work_guard(handler_))
  {
  }

  // Create the state using the handler's associated allocator.
  static read_input_state* create(Handler&& handler)
  {
    // A unique_ptr deleter that is used to destroy uninitialised objects.
    struct deleter
    {
      // Get the handler's associated allocator type. If the handler does not
      // specify an associated allocator, we will use a recycling allocator as
      // the default. As the associated allocator is a proto-allocator, we must
      // rebind it to the correct type before we can use it to allocate objects.
      typename std::allocator_traits<
        asio::associated_allocator_t<Handler,
          asio::recycling_allocator<void>>>::template
            rebind_alloc<read_input_state> alloc;

      void operator()(read_input_state* ptr)
      {
        std::allocator_traits<decltype(alloc)>::deallocate(alloc, ptr, 1);
      }
    } d{asio::get_associated_allocator(handler,
          asio::recycling_allocator<void>())};

    // Allocate memory for the state.
    std::unique_ptr<read_input_state, deleter> uninit_ptr(
        std::allocator_traits<decltype(d.alloc)>::allocate(d.alloc, 1), d);

    // Construct the state into the newly allocated memory. This might throw.
    read_input_state* ptr =
      new (uninit_ptr.get()) read_input_state(std::move(handler));

    // Release ownership of the memory and return the newly allocated state.
    uninit_ptr.release();
    return ptr;
  }

  static void callback(void* arg, const char* result)
  {
    read_input_state* self = static_cast<read_input_state*>(arg);

    // A unique_ptr deleter that is used to destroy initialised objects.
    struct deleter
    {
      // Get the handler's associated allocator type. If the handler does not
      // specify an associated allocator, we will use a recycling allocator as
      // the default. As the associated allocator is a proto-allocator, we must
      // rebind it to the correct type before we can use it to allocate objects.
      typename std::allocator_traits<
        asio::associated_allocator_t<Handler,
          asio::recycling_allocator<void>>>::template
            rebind_alloc<read_input_state> alloc;

      void operator()(read_input_state* ptr)
      {
        std::allocator_traits<decltype(alloc)>::destroy(alloc, ptr);
        std::allocator_traits<decltype(alloc)>::deallocate(alloc, ptr, 1);
      }
    } d{asio::get_associated_allocator(self->handler_,
          asio::recycling_allocator<void>())};

    // To conform to the rules regarding asynchronous operations and memory
    // allocation, we must make a copy of the state and deallocate the memory
    // before dispatching the completion handler.
    std::unique_ptr<read_input_state, deleter> state_ptr(self, d);
    read_input_state state(std::move(*self));
    state_ptr.reset();

    // Dispatch the completion handler through the handler's associated
    // executor, using the handler's associated allocator.
    asio::dispatch(state.work_.get_executor(),
        asio::bind_allocator(d.alloc,
          [
            handler = std::move(state.handler_),
            result = std::string(result)
          ]() mutable
          {
            std::move(handler)(result);
          }));
  }

private:
  Handler handler_;

  // According to the rules for asynchronous operations, we need to track
  // outstanding work against the handler's associated executor until the
  // asynchronous operation is complete.
  asio::executor_work_guard<
    asio::associated_executor_t<Handler>> work_;
};

// The initiating function for the asynchronous operation.
template <asio::completion_token_for<void(std::string)> CompletionToken>
auto async_read_input(const std::string& prompt, CompletionToken&& token)
{
  // Define a function object that contains the code to launch the asynchronous
  // operation. This is passed the concrete completion handler, followed by any
  // additional arguments that were passed through the call to async_initiate.
  auto init = [](
      asio::completion_handler_for<void(std::string)> auto handler,
      const std::string& prompt)
  {
    // The body of the initiation function object creates the long-lived state
    // and passes it to the C-based API, along with the function pointer.
    using state_type = read_input_state<decltype(handler)>;
    read_input(prompt.c_str(), &state_type::callback,
        state_type::create(std::move(handler)));
  };

  // The async_initiate function is used to transform the supplied completion
  // token to the completion handler. When calling this function we explicitly
  // specify the completion signature of the operation. We must also return the
  // result of the call since the completion token may produce a return value,
  // such as a future.
  return asio::async_initiate<CompletionToken, void(std::string)>(
      init, // First, pass the function object that launches the operation,
      token, // then the completion token that will be transformed to a handler,
      prompt); // and, finally, any additional arguments to the function object.
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  // Test our asynchronous operation using a lambda as a callback. We will use
  // an io_context to obtain an associated executor.
  async_read_input("Enter your name",
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_read_input("Enter your name", asio::deferred);

  // Launch our asynchronous operation using a lambda as a callback. We will use
  // an io_context to obtain an associated executor.
  std::move(op)(
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::string> f =
    async_read_input("Enter your name", asio::use_future);

  std::string result = f.get();
  std::cout << "Hello " << result << "\n";
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\callback_wrapper.cpp
//
// callback_wrapper.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio.hpp>
#include <iostream>

//------------------------------------------------------------------------------

// This is a mock implementation of an API that uses a move-only function object
// for exposing a callback. The callback has the signature void(std::string).

template <typename Callback>
void read_input(const std::string& prompt, Callback cb)
{
  std::thread(
      [prompt, cb = std::move(cb)]() mutable
      {
        std::cout << prompt << ": ";
        std::cout.flush();
        std::string line;
        std::getline(std::cin, line);
        std::move(cb)(std::move(line));
      }).detach();
}

//------------------------------------------------------------------------------

// This is an asynchronous operation that wraps the callback-based API.

// The initiating function for the asynchronous operation.
template <asio::completion_token_for<void(std::string)> CompletionToken>
auto async_read_input(const std::string& prompt, CompletionToken&& token)
{
  // Define a function object that contains the code to launch the asynchronous
  // operation. This is passed the concrete completion handler, followed by any
  // additional arguments that were passed through the call to async_initiate.
  auto init = [](
      asio::completion_handler_for<void(std::string)> auto handler,
      const std::string& prompt)
  {
    // According to the rules for asynchronous operations, we need to track
    // outstanding work against the handler's associated executor until the
    // asynchronous operation is complete.
    auto work = asio::make_work_guard(handler);

    // Launch the operation with a callback that will receive the result and
    // pass it through to the asynchronous operation's completion handler.
    read_input(prompt,
        [
          handler = std::move(handler),
          work = std::move(work)
        ](std::string result) mutable
        {
          // Get the handler's associated allocator. If the handler does not
          // specify an allocator, use the recycling allocator as the default.
          auto alloc = asio::get_associated_allocator(
              handler, asio::recycling_allocator<void>());

          // Dispatch the completion handler through the handler's associated
          // executor, using the handler's associated allocator.
          asio::dispatch(work.get_executor(),
              asio::bind_allocator(alloc,
                [
                  handler = std::move(handler),
                  result = std::string(result)
                ]() mutable
                {
                  std::move(handler)(result);
                }));
        });
  };

  // The async_initiate function is used to transform the supplied completion
  // token to the completion handler. When calling this function we explicitly
  // specify the completion signature of the operation. We must also return the
  // result of the call since the completion token may produce a return value,
  // such as a future.
  return asio::async_initiate<CompletionToken, void(std::string)>(
      init, // First, pass the function object that launches the operation,
      token, // then the completion token that will be transformed to a handler,
      prompt); // and, finally, any additional arguments to the function object.
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  // Test our asynchronous operation using a lambda as a callback. We will use
  // an io_context to specify an associated executor.
  async_read_input("Enter your name",
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  auto op = async_read_input("Enter your name", asio::deferred);

  // Launch our asynchronous operation using a lambda as a callback. We will use
  // an io_context to obtain an associated executor.
  std::move(op)(
      asio::bind_executor(io_context,
        [](const std::string& result)
        {
          std::cout << "Hello " << result << "\n";
        }));

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::string> f =
    async_read_input("Enter your name", asio::use_future);

  std::string result = f.get();
  std::cout << "Hello " << result << "\n";
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_1.cpp
//
// composed_1.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

//------------------------------------------------------------------------------

// This is the simplest example of a composed asynchronous operation, where we
// simply repackage an existing operation. The asynchronous operation
// requirements are met by delegating responsibility to the underlying
// operation.

template <
  asio::completion_token_for<void(std::error_code, std::size_t)>
    CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is void.
  // However, when the completion token is asio::yield_context (used for
  // stackful coroutines) the return type would be std::size_t, and when the
  // completion token is asio::use_future it would be std::future<std::size_t>.
  // When the completion token is asio::deferred, the return type differs for
  // each asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of our underlying asynchronous operation.
{
  // When delegating to the underlying operation we must take care to perfectly
  // forward the completion token. This ensures that our operation works
  // correctly with move-only function objects as callbacks, as well as other
  // completion token types.
  return asio::async_write(socket,
      asio::buffer(message, std::strlen(message)),
      std::forward<CompletionToken>(token));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n",
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_message(
      socket, "Testing deferred\r\n", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::size_t> f = async_write_message(
      socket, "Testing future\r\n", asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    std::size_t n = f.get();
    std::cout << n << " bytes transferred\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_2.cpp
//
// composed_2.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This next simplest example of a composed asynchronous operation involves
// repackaging multiple operations but choosing to invoke just one of them. All
// of these underlying operations have the same completion signature. The
// asynchronous operation requirements are met by delegating responsibility to
// the underlying operations.

template <
  asio::completion_token_for<void(std::error_code, std::size_t)>
    CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, bool allow_partial_write,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is void.
  // However, when the completion token is asio::yield_context (used for
  // stackful coroutines) the return type would be std::size_t, and when the
  // completion token is asio::use_future it would be std::future<std::size_t>.
  // When the completion token is asio::deferred, the return type differs for
  // each asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error, std::size_t)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](
      asio::completion_handler_for<void(std::error_code, std::size_t)>
        auto&& completion_handler,
      tcp::socket& socket,
      const char* message,
      bool allow_partial_write)
  {
    if (allow_partial_write)
    {
      // When delegating to an underlying operation we must take care to
      // perfectly forward the completion handler. This ensures that our
      // operation works correctly with move-only function objects as
      // callbacks.
      return socket.async_write_some(
          asio::buffer(message, std::strlen(message)),
          std::forward<decltype(completion_handler)>(completion_handler));
    }
    else
    {
      // As above, we must perfectly forward the completion handler when calling
      // the alternate underlying operation.
      return asio::async_write(socket,
          asio::buffer(message, std::strlen(message)),
          std::forward<decltype(completion_handler)>(completion_handler));
    }
  };

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code, std::size_t)>(
      initiation, token, std::ref(socket), message, allow_partial_write);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n", false,
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_message(
      socket, "Testing deferred\r\n", false, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error, std::size_t n)
      {
        if (!error)
        {
          std::cout << n << " bytes transferred\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<std::size_t> f = async_write_message(
      socket, "Testing future\r\n", false, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    std::size_t n = f.get();
    std::cout << n << " bytes transferred\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_3.cpp
//
// composed_3.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/bind_executor.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// In this composed operation we repackage an existing operation, but with a
// different completion handler signature. The asynchronous operation
// requirements are met by delegating responsibility to the underlying
// operation.

template <
  asio::completion_token_for<void(std::error_code)> CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](
      asio::completion_handler_for<void(std::error_code)>
        auto&& completion_handler,
      tcp::socket& socket,
      const char* message)
  {
    // The async_write operation has a completion handler signature of:
    //
    //   void(std::error_code error, std::size n)
    //
    // This differs from our operation's signature in that it is also passed
    // the number of bytes transferred as an argument of type std::size_t. We
    // will adapt our completion handler to async_write's completion handler
    // signature by using std::bind, which drops the additional argument.
    //
    // However, it is essential to the correctness of our composed operation
    // that we preserve the executor of the user-supplied completion handler.
    // The std::bind function will not do this for us, so we must do this by
    // first obtaining the completion handler's associated executor (defaulting
    // to the I/O executor - in this case the executor of the socket - if the
    // completion handler does not have its own) ...
    auto executor = asio::get_associated_executor(
        completion_handler, socket.get_executor());

    // ... and then binding this executor to our adapted completion handler
    // using the asio::bind_executor function.
    asio::async_write(socket,
        asio::buffer(message, std::strlen(message)),
        asio::bind_executor(executor,
          std::bind(std::forward<decltype(completion_handler)>(
              completion_handler), std::placeholders::_1)));
  };

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket), message);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "Testing callback\r\n",
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_message(
      socket, "Testing deferred\r\n", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, "Testing future\r\n", asio::use_future);

  io_context.run();

  // Get the result of the operation.
  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_4.cpp
//
// composed_4.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/bind_executor.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <cstring>
#include <functional>
#include <iostream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// In this composed operation we repackage an existing operation, but with a
// different completion handler signature. We will also intercept an empty
// message as an invalid argument, and propagate the corresponding error to the
// user. The asynchronous operation requirements are met by delegating
// responsibility to the underlying operation.

template <
  asio::completion_token_for<void(std::error_code)> CompletionToken>
auto async_write_message(tcp::socket& socket,
    const char* message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](
      asio::completion_handler_for<void(std::error_code)>
        auto&& completion_handler,
      tcp::socket& socket,
      const char* message)
  {
    // The post operation has a completion handler signature of:
    //
    //   void()
    //
    // and the async_write operation has a completion handler signature of:
    //
    //   void(std::error_code error, std::size n)
    //
    // Both of these operations' completion handler signatures differ from our
    // operation's completion handler signature. We will adapt our completion
    // handler to these signatures by using std::bind, which drops the
    // additional arguments.
    //
    // However, it is essential to the correctness of our composed operation
    // that we preserve the executor of the user-supplied completion handler.
    // The std::bind function will not do this for us, so we must do this by
    // first obtaining the completion handler's associated executor (defaulting
    // to the I/O executor - in this case the executor of the socket - if the
    // completion handler does not have its own) ...
    auto executor = asio::get_associated_executor(
        completion_handler, socket.get_executor());

    // ... and then binding this executor to our adapted completion handler
    // using the asio::bind_executor function.
    std::size_t length = std::strlen(message);
    if (length == 0)
    {
      asio::post(
          asio::bind_executor(executor,
            std::bind(std::forward<decltype(completion_handler)>(
                completion_handler), asio::error::invalid_argument)));
    }
    else
    {
      asio::async_write(socket,
          asio::buffer(message, length),
          asio::bind_executor(executor,
            std::bind(std::forward<decltype(completion_handler)>(
                completion_handler), std::placeholders::_1)));
    }
  };

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket), message);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, "",
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op =
    async_write_message(socket, "", asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, "", asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_5.cpp
//
// composed_5.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation automatically serialises a message, using its I/O
// streams insertion operator, before sending it on the socket. To do this, it
// must allocate a buffer for the encoded message and ensure this buffer's
// validity until the underlying async_write operation completes.

template <typename T,
  asio::completion_token_for<void(std::error_code)> CompletionToken>
auto async_write_message(tcp::socket& socket,
    const T& message, CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](
      asio::completion_handler_for<void(std::error_code)>
        auto&& completion_handler,
      tcp::socket& socket,
      std::unique_ptr<std::string> encoded_message)
  {
    // In this example, the composed operation's intermediate completion
    // handler is implemented as a hand-crafted function object, rather than
    // using a lambda or std::bind.
    struct intermediate_completion_handler
    {
      // The intermediate completion handler holds a reference to the socket so
      // that it can obtain the I/O executor (see get_executor below).
      tcp::socket& socket_;

      // The allocated buffer for the encoded message. The std::unique_ptr
      // smart pointer is move-only, and as a consequence our intermediate
      // completion handler is also move-only.
      std::unique_ptr<std::string> encoded_message_;

      // The user-supplied completion handler.
      typename std::decay<decltype(completion_handler)>::type handler_;

      // The function call operator matches the completion signature of the
      // async_write operation.
      void operator()(const std::error_code& error, std::size_t /*n*/)
      {
        // Deallocate the encoded message before calling the user-supplied
        // completion handler.
        encoded_message_.reset();

        // Call the user-supplied handler with the result of the operation.
        // The arguments must match the completion signature of our composed
        // operation.
        handler_(error);
      }

      // It is essential to the correctness of our composed operation that we
      // preserve the executor of the user-supplied completion handler. With a
      // hand-crafted function object we can do this by defining a nested type
      // executor_type and member function get_executor. These obtain the
      // completion handler's associated executor, and default to the I/O
      // executor - in this case the executor of the socket - if the completion
      // handler does not have its own.
      using executor_type = asio::associated_executor_t<
          typename std::decay<decltype(completion_handler)>::type,
          tcp::socket::executor_type>;

      executor_type get_executor() const noexcept
      {
        return asio::get_associated_executor(
            handler_, socket_.get_executor());
      }

      // Although not necessary for correctness, we may also preserve the
      // allocator of the user-supplied completion handler. This is achieved by
      // defining a nested type allocator_type and member function
      // get_allocator. These obtain the completion handler's associated
      // allocator, and default to std::allocator<void> if the completion
      // handler does not have its own.
      using allocator_type = asio::associated_allocator_t<
          typename std::decay<decltype(completion_handler)>::type,
          std::allocator<void>>;

      allocator_type get_allocator() const noexcept
      {
        return asio::get_associated_allocator(
            handler_, std::allocator<void>{});
      }
    };

    // Initiate the underlying async_write operation using our intermediate
    // completion handler.
    auto encoded_message_buffer = asio::buffer(*encoded_message);
    asio::async_write(socket, encoded_message_buffer,
        intermediate_completion_handler{socket, std::move(encoded_message),
          std::forward<decltype(completion_handler)>(completion_handler)});
  };

  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket),
      std::move(encoded_message));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_message(socket, 123456,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_message(
      socket, std::string("abcdef"), asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Message sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_message(
      socket, 654.321, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Message sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Exception: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_6.cpp
//
// composed_6.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/deferred.hpp>
#include <asio/executor_work_guard.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_initiate function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations.
// It automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

template <typename T,
  asio::completion_token_for<void(std::error_code)> CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_initiate.
{
  // In addition to determining the mechanism by which an asynchronous
  // operation delivers its result, a completion token also determines the time
  // when the operation commences. For example, when the completion token is a
  // simple callback the operation commences before the initiating function
  // returns. However, if the completion token's delivery mechanism uses a
  // future, we might instead want to defer initiation of the operation until
  // the returned future object is waited upon.
  //
  // To enable this, when implementing an asynchronous operation we must
  // package the initiation step as a function object. The initiation function
  // object's call operator is passed the concrete completion handler produced
  // by the completion token. This completion handler matches the asynchronous
  // operation's completion handler signature, which in this example is:
  //
  //   void(std::error_code error)
  //
  // The initiation function object also receives any additional arguments
  // required to start the operation. (Note: We could have instead passed these
  // arguments in the lambda capture set. However, we should prefer to
  // propagate them as function call arguments as this allows the completion
  // token to optimise how they are passed. For example, a lazy future which
  // defers initiation would need to make a decay-copy of the arguments, but
  // when using a simple callback the arguments can be trivially forwarded
  // straight through.)
  auto initiation = [](
      asio::completion_handler_for<void(std::error_code)>
        auto&& completion_handler,
      tcp::socket& socket,
      std::unique_ptr<std::string> encoded_message,
      std::size_t repeat_count,
      std::unique_ptr<asio::steady_timer> delay_timer)
  {
    // In this example, the composed operation's intermediate completion
    // handler is implemented as a hand-crafted function object.
    struct intermediate_completion_handler
    {
      // The intermediate completion handler holds a reference to the socket as
      // it is used for multiple async_write operations, as well as for
      // obtaining the I/O executor (see get_executor below).
      tcp::socket& socket_;

      // The allocated buffer for the encoded message. The std::unique_ptr
      // smart pointer is move-only, and as a consequence our intermediate
      // completion handler is also move-only.
      std::unique_ptr<std::string> encoded_message_;

      // The repeat count remaining.
      std::size_t repeat_count_;

      // A steady timer used for introducing a delay.
      std::unique_ptr<asio::steady_timer> delay_timer_;

      // To manage the cycle between the multiple underlying asychronous
      // operations, our intermediate completion handler is implemented as a
      // state machine.
      enum { starting, waiting, writing } state_;

      // As our composed operation performs multiple underlying I/O operations,
      // we should maintain a work object against the I/O executor. This tells
      // the I/O executor that there is still more work to come in the future.
      asio::executor_work_guard<tcp::socket::executor_type> io_work_;

      // The user-supplied completion handler, called once only on completion
      // of the entire composed operation.
      typename std::decay<decltype(completion_handler)>::type handler_;

      // By having a default value for the second argument, this function call
      // operator matches the completion signature of both the async_write and
      // steady_timer::async_wait operations.
      void operator()(const std::error_code& error, std::size_t = 0)
      {
        if (!error)
        {
          switch (state_)
          {
          case starting:
          case writing:
            if (repeat_count_ > 0)
            {
              --repeat_count_;
              state_ = waiting;
              delay_timer_->expires_after(std::chrono::seconds(1));
              delay_timer_->async_wait(std::move(*this));
              return; // Composed operation not yet complete.
            }
            break; // Composed operation complete, continue below.
          case waiting:
            state_ = writing;
            asio::async_write(socket_,
                asio::buffer(*encoded_message_), std::move(*this));
            return; // Composed operation not yet complete.
          }
        }

        // This point is reached only on completion of the entire composed
        // operation.

        // We no longer have any future work coming for the I/O executor.
        io_work_.reset();

        // Deallocate the encoded message before calling the user-supplied
        // completion handler.
        encoded_message_.reset();

        // Call the user-supplied handler with the result of the operation.
        handler_(error);
      }

      // It is essential to the correctness of our composed operation that we
      // preserve the executor of the user-supplied completion handler. With a
      // hand-crafted function object we can do this by defining a nested type
      // executor_type and member function get_executor. These obtain the
      // completion handler's associated executor, and default to the I/O
      // executor - in this case the executor of the socket - if the completion
      // handler does not have its own.
      using executor_type = asio::associated_executor_t<
          typename std::decay<decltype(completion_handler)>::type,
          tcp::socket::executor_type>;

      executor_type get_executor() const noexcept
      {
        return asio::get_associated_executor(
            handler_, socket_.get_executor());
      }

      // Although not necessary for correctness, we may also preserve the
      // allocator of the user-supplied completion handler. This is achieved by
      // defining a nested type allocator_type and member function
      // get_allocator. These obtain the completion handler's associated
      // allocator, and default to std::allocator<void> if the completion
      // handler does not have its own.
      using allocator_type = asio::associated_allocator_t<
          typename std::decay<decltype(completion_handler)>::type,
          std::allocator<void>>;

      allocator_type get_allocator() const noexcept
      {
        return asio::get_associated_allocator(
            handler_, std::allocator<void>{});
      }
    };

    // Initiate the underlying async_write operation using our intermediate
    // completion handler.
    auto encoded_message_buffer = asio::buffer(*encoded_message);
    asio::async_write(socket, encoded_message_buffer,
        intermediate_completion_handler{
          socket, std::move(encoded_message),
          repeat_count, std::move(delay_timer),
          intermediate_completion_handler::starting,
          asio::make_work_guard(socket.get_executor()),
          std::forward<decltype(completion_handler)>(completion_handler)});
  };

  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_initiate function takes:
  //
  // - our initiation function object,
  // - the completion token,
  // - the completion handler signature, and
  // - any additional arguments we need to initiate the operation.
  //
  // It then asks the completion token to create a completion handler (i.e. a
  // callback) with the specified signature, and invoke the initiation function
  // object with this completion handler as well as the additional arguments.
  // The return value of async_initiate is the result of our operation's
  // initiating function.
  //
  // Note that we wrap non-const reference arguments in std::reference_wrapper
  // to prevent incorrect decay-copies of these objects.
  return asio::async_initiate<
    CompletionToken, void(std::error_code)>(
      initiation, token, std::ref(socket),
      std::move(encoded_message), repeat_count,
      std::move(delay_timer));
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_messages(
      socket, "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_7.cpp
//
// composed_7.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/compose.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_compose function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations.
// It automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

template <typename T,
  asio::completion_token_for<void(std::error_code)> CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_compose.
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // To manage the cycle between the multiple underlying asychronous
  // operations, our implementation is a state machine.
  enum { starting, waiting, writing };

  // The asio::async_compose function takes:
  //
  // - our asynchronous operation implementation,
  // - the completion token,
  // - the completion handler signature, and
  // - any I/O objects (or executors) used by the operation
  //
  // It then wraps our implementation, which is implemented here as a state
  // machine in a lambda, in an intermediate completion handler that meets the
  // requirements of a conforming asynchronous operation. This includes
  // tracking outstanding work against the I/O executors associated with the
  // operation (in this example, this is the socket's executor).
  //
  // The first argument to our lambda is a reference to the enclosing
  // intermediate completion handler. This intermediate completion handler is
  // provided for us by the asio::async_compose function, and takes care
  // of all the details required to implement a conforming asynchronous
  // operation. When calling an underlying asynchronous operation, we pass it
  // this enclosing intermediate completion handler as the completion token.
  //
  // All arguments to our lambda after the first must be defaulted to allow the
  // state machine to be started, as well as to allow the completion handler to
  // match the completion signature of both the async_write and
  // steady_timer::async_wait operations.
  return asio::async_compose<
    CompletionToken, void(std::error_code)>(
      [
        // The implementation holds a reference to the socket as it is used for
        // multiple async_write operations.
        &socket,

        // The allocated buffer for the encoded message. The std::unique_ptr
        // smart pointer is move-only, and as a consequence our lambda
        // implementation is also move-only.
        encoded_message = std::move(encoded_message),

        // The repeat count remaining.
        repeat_count,

        // A steady timer used for introducing a delay.
        delay_timer = std::move(delay_timer),

        // To manage the cycle between the multiple underlying asychronous
        // operations, our implementation is a state machine.
        state = starting
      ]
      (
        auto& self,
        const std::error_code& error = {},
        std::size_t = 0
      ) mutable
      {
        if (!error)
        {
          switch (state)
          {
          case starting:
          case writing:
            if (repeat_count > 0)
            {
              --repeat_count;
              state = waiting;
              delay_timer->expires_after(std::chrono::seconds(1));
              delay_timer->async_wait(std::move(self));
              return; // Composed operation not yet complete.
            }
            break; // Composed operation complete, continue below.
          case waiting:
            state = writing;
            asio::async_write(socket,
                asio::buffer(*encoded_message), std::move(self));
            return; // Composed operation not yet complete.
          }
        }

        // This point is reached only on completion of the entire composed
        // operation.

        // Deallocate the encoded message and delay timer before calling the
        // user-supplied completion handler.
        encoded_message.reset();
        delay_timer.reset();

        // Call the user-supplied handler with the result of the operation.
        self.complete(error);
      },
      token, socket);
}

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_messages(
      socket, "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\operations\composed_8.cpp
//
// composed_8.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/compose.hpp>
#include <asio/coroutine.hpp>
#include <asio/deferred.hpp>
#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/steady_timer.hpp>
#include <asio/use_future.hpp>
#include <asio/write.hpp>
#include <functional>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <type_traits>
#include <utility>

using asio::ip::tcp;

// NOTE: This example requires the new asio::async_compose function. For
// an example that works with the Networking TS style of completion tokens,
// please see an older version of asio.

//------------------------------------------------------------------------------

// This composed operation shows composition of multiple underlying operations,
// using asio's stackless coroutines support to express the flow of control. It
// automatically serialises a message, using its I/O streams insertion
// operator, before sending it N times on the socket. To do this, it must
// allocate a buffer for the encoded message and ensure this buffer's validity
// until all underlying async_write operation complete. A one second delay is
// inserted prior to each write operation, using a steady_timer.

#include <asio/yield.hpp>

template <typename T,
  asio::completion_token_for<void(std::error_code)> CompletionToken>
auto async_write_messages(tcp::socket& socket,
    const T& message, std::size_t repeat_count,
    CompletionToken&& token)
  // The return type of the initiating function is deduced from the combination
  // of:
  //
  // - the CompletionToken type,
  // - the completion handler signature, and
  // - the asynchronous operation's initiation function object.
  //
  // When the completion token is a simple callback, the return type is always
  // void. In this example, when the completion token is asio::yield_context
  // (used for stackful coroutines) the return type would also be void, as
  // there is no non-error argument to the completion handler. When the
  // completion token is asio::use_future it would be std::future<void>. When
  // the completion token is asio::deferred, the return type differs for each
  // asynchronous operation.
  //
  // In C++20 we can omit the return type as it is automatically deduced from
  // the return type of asio::async_compose.
{
  // Encode the message and copy it into an allocated buffer. The buffer will
  // be maintained for the lifetime of the composed asynchronous operation.
  std::ostringstream os;
  os << message;
  std::unique_ptr<std::string> encoded_message(new std::string(os.str()));

  // Create a steady_timer to be used for the delay between messages.
  std::unique_ptr<asio::steady_timer> delay_timer(
      new asio::steady_timer(socket.get_executor()));

  // The asio::async_compose function takes:
  //
  // - our asynchronous operation implementation,
  // - the completion token,
  // - the completion handler signature, and
  // - any I/O objects (or executors) used by the operation
  //
  // It then wraps our implementation, which is implemented here as a stackless
  // coroutine in a lambda, in an intermediate completion handler that meets the
  // requirements of a conforming asynchronous operation. This includes
  // tracking outstanding work against the I/O executors associated with the
  // operation (in this example, this is the socket's executor).
  //
  // The first argument to our lambda is a reference to the enclosing
  // intermediate completion handler. This intermediate completion handler is
  // provided for us by the asio::async_compose function, and takes care
  // of all the details required to implement a conforming asynchronous
  // operation. When calling an underlying asynchronous operation, we pass it
  // this enclosing intermediate completion handler as the completion token.
  //
  // All arguments to our lambda after the first must be defaulted to allow the
  // state machine to be started, as well as to allow the completion handler to
  // match the completion signature of both the async_write and
  // steady_timer::async_wait operations.
  return asio::async_compose<
    CompletionToken, void(std::error_code)>(
      [
        // The implementation holds a reference to the socket as it is used for
        // multiple async_write operations.
        &socket,

        // The allocated buffer for the encoded message. The std::unique_ptr
        // smart pointer is move-only, and as a consequence our lambda
        // implementation is also move-only.
        encoded_message = std::move(encoded_message),

        // The repeat count remaining.
        repeat_count,

        // A steady timer used for introducing a delay.
        delay_timer = std::move(delay_timer),

        // The coroutine state.
        coro = asio::coroutine()
      ]
      (
        auto& self,
        const std::error_code& error = {},
        std::size_t = 0
      ) mutable
      {
        reenter (coro)
        {
          while (repeat_count > 0)
          {
            --repeat_count;

            delay_timer->expires_after(std::chrono::seconds(1));
            yield delay_timer->async_wait(std::move(self));
            if (error)
              break;

            yield asio::async_write(socket,
                asio::buffer(*encoded_message), std::move(self));
            if (error)
              break;
          }

          // Deallocate the encoded message and delay timer before calling the
          // user-supplied completion handler.
          encoded_message.reset();
          delay_timer.reset();

          // Call the user-supplied handler with the result of the operation.
          self.complete(error);
        }
      },
      token, socket);
}

#include <asio/unyield.hpp>

//------------------------------------------------------------------------------

void test_callback()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using a lambda as a callback.
  async_write_messages(socket, "Testing callback\r\n", 5,
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_deferred()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the deferred completion token. This
  // token causes the operation's initiating function to package up the
  // operation with its arguments to return a function object, which may then be
  // used to launch the asynchronous operation.
  asio::async_operation auto op = async_write_messages(
      socket, "Testing deferred\r\n", 5, asio::deferred);

  // Launch the operation using a lambda as a callback.
  std::move(op)(
      [](const std::error_code& error)
      {
        if (!error)
        {
          std::cout << "Messages sent\n";
        }
        else
        {
          std::cout << "Error: " << error.message() << "\n";
        }
      });

  io_context.run();
}

//------------------------------------------------------------------------------

void test_future()
{
  asio::io_context io_context;

  tcp::acceptor acceptor(io_context, {tcp::v4(), 55555});
  tcp::socket socket = acceptor.accept();

  // Test our asynchronous operation using the use_future completion token.
  // This token causes the operation's initiating function to return a future,
  // which may be used to synchronously wait for the result of the operation.
  std::future<void> f = async_write_messages(
      socket, "Testing future\r\n", 5, asio::use_future);

  io_context.run();

  try
  {
    // Get the result of the operation.
    f.get();
    std::cout << "Messages sent\n";
  }
  catch (const std::exception& e)
  {
    std::cout << "Error: " << e.what() << "\n";
  }
}

//------------------------------------------------------------------------------

int main()
{
  test_callback();
  test_deferred();
  test_future();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\type_erasure\main.cpp
//
// main.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "line_reader.hpp"
#include "sleep.hpp"
#include "stdin_line_reader.hpp"
#include <asio/co_spawn.hpp>
#include <asio/detached.hpp>
#include <asio/io_context.hpp>
#include <asio/use_awaitable.hpp>
#include <iostream>

asio::awaitable<void> do_read(line_reader& reader)
{
  for (int i = 0; i < 10; ++i)
  {
    std::cout << co_await reader.async_read_line("Enter something: ", asio::use_awaitable);
    co_await async_sleep(co_await asio::this_coro::executor, std::chrono::seconds(1), asio::use_awaitable);
  }
}

int main()
{
  asio::io_context ctx{1};
  stdin_line_reader reader{ctx.get_executor()};
  co_spawn(ctx, do_read(reader), asio::detached);
  ctx.run();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\type_erasure\sleep.cpp
//
// sleep.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "sleep.hpp"
#include <asio/consign.hpp>
#include <asio/steady_timer.hpp>
#include <memory>

void async_sleep_impl(
    asio::any_completion_handler<void(std::error_code)> handler,
    asio::any_io_executor ex, std::chrono::nanoseconds duration)
{
  auto timer = std::make_shared<asio::steady_timer>(ex, duration);
  timer->async_wait(asio::consign(std::move(handler), timer));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\examples\cpp20\type_erasure\stdin_line_reader.cpp
//
// stdin_line_reader.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "stdin_line_reader.hpp"
#include <asio/deferred.hpp>
#include <asio/read_until.hpp>
#include <iostream>

stdin_line_reader::stdin_line_reader(asio::any_io_executor ex)
  : stdin_(ex, ::dup(STDIN_FILENO))
{
}

void stdin_line_reader::async_read_line_impl(std::string prompt,
    asio::any_completion_handler<void(asio::error_code, std::string)> handler)
{
  std::cout << prompt;
  std::cout.flush();

  asio::async_read_until(stdin_, asio::dynamic_buffer(buffer_), '\n',
      asio::deferred(
        [this](asio::error_code ec, std::size_t n)
        {
          if (!ec)
          {
            std::string result = buffer_.substr(0, n);
            buffer_.erase(0, n);
            return asio::deferred.values(ec, std::move(result));
          }
          else
          {
            return asio::deferred.values(ec, std::string{});
          }
        }
      )
    )(std::move(handler));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\latency\tcp_client.cpp
//
// tcp_client.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/ip/tcp.hpp>
#include <asio/read.hpp>
#include <asio/write.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>
#include <boost/shared_ptr.hpp>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include "high_res_clock.hpp"

using asio::ip::tcp;
using boost::posix_time::ptime;
using boost::posix_time::microsec_clock;

const int num_samples = 100000;

struct transfer_all
{
  typedef std::size_t result_type;
  std::size_t operator()(const asio::error_code& ec, std::size_t)
  {
    return (ec && ec != asio::error::would_block) ? 0 : ~0;
  }
};

int main(int argc, char* argv[])
{
  if (argc != 6)
  {
    std::fprintf(stderr,
        "Usage: tcp_client <ip> <port> "
        "<nconns> <bufsize> {spin|block}\n");
    return 1;
  }

  const char* ip = argv[1];
  unsigned short port = static_cast<unsigned short>(std::atoi(argv[2]));
  int num_connections = std::atoi(argv[3]);
  std::size_t buf_size = static_cast<std::size_t>(std::atoi(argv[4]));
  bool spin = (std::strcmp(argv[5], "spin") == 0);

  asio::io_context io_context;
  std::vector<boost::shared_ptr<tcp::socket> > sockets;

  for (int i = 0; i < num_connections; ++i)
  {
    boost::shared_ptr<tcp::socket> s(new tcp::socket(io_context));

    tcp::endpoint target(asio::ip::make_address(ip), port);
    s->connect(target);

    s->set_option(tcp::no_delay(true));

    if (spin)
    {
      s->non_blocking(true);
    }

    sockets.push_back(s);
  }

  std::vector<unsigned char> write_buf(buf_size);
  std::vector<unsigned char> read_buf(buf_size);

  ptime start = microsec_clock::universal_time();
  boost::uint64_t start_hr = high_res_clock();

  boost::uint64_t samples[num_samples];
  for (int i = 0; i < num_samples; ++i)
  {
    tcp::socket& socket = *sockets[i % num_connections];

    boost::uint64_t t = high_res_clock();

    asio::error_code ec;
    asio::write(socket,
        asio::buffer(write_buf),
        transfer_all(), ec);

    asio::read(socket,
        asio::buffer(read_buf),
        transfer_all(), ec);

    samples[i] = high_res_clock() - t;
  }

  ptime stop = microsec_clock::universal_time();
  boost::uint64_t stop_hr = high_res_clock();
  boost::uint64_t elapsed_usec = (stop - start).total_microseconds();
  boost::uint64_t elapsed_hr = stop_hr - start_hr;
  double scale = 1.0 * elapsed_usec / elapsed_hr;

  std::sort(samples, samples + num_samples);
  std::printf("  0.0%%\t%f\n", samples[0] * scale);
  std::printf("  0.1%%\t%f\n", samples[num_samples / 1000 - 1] * scale);
  std::printf("  1.0%%\t%f\n", samples[num_samples / 100 - 1] * scale);
  std::printf(" 10.0%%\t%f\n", samples[num_samples / 10 - 1] * scale);
  std::printf(" 20.0%%\t%f\n", samples[num_samples * 2 / 10 - 1] * scale);
  std::printf(" 30.0%%\t%f\n", samples[num_samples * 3 / 10 - 1] * scale);
  std::printf(" 40.0%%\t%f\n", samples[num_samples * 4 / 10 - 1] * scale);
  std::printf(" 50.0%%\t%f\n", samples[num_samples * 5 / 10 - 1] * scale);
  std::printf(" 60.0%%\t%f\n", samples[num_samples * 6 / 10 - 1] * scale);
  std::printf(" 70.0%%\t%f\n", samples[num_samples * 7 / 10 - 1] * scale);
  std::printf(" 80.0%%\t%f\n", samples[num_samples * 8 / 10 - 1] * scale);
  std::printf(" 90.0%%\t%f\n", samples[num_samples * 9 / 10 - 1] * scale);
  std::printf(" 99.0%%\t%f\n", samples[num_samples * 99 / 100 - 1] * scale);
  std::printf(" 99.9%%\t%f\n", samples[num_samples * 999 / 1000 - 1] * scale);
  std::printf("100.0%%\t%f\n", samples[num_samples - 1] * scale);

  double total = 0.0;
  for (int i = 0; i < num_samples; ++i) total += samples[i] * scale;
  std::printf("  mean\t%f\n", total / num_samples);
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\latency\tcp_server.cpp
//
// tcp_server.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/io_context.hpp>
#include <asio/ip/tcp.hpp>
#include <asio/read.hpp>
#include <asio/write.hpp>
#include <boost/shared_ptr.hpp>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>

using asio::ip::tcp;

#include <asio/yield.hpp>

class tcp_server : asio::coroutine
{
public:
  tcp_server(tcp::acceptor& acceptor, std::size_t buf_size) :
    acceptor_(acceptor),
    socket_(acceptor_.get_executor()),
    buffer_(buf_size)
  {
  }

  void operator()(asio::error_code ec, std::size_t n = 0)
  {
    reenter (this) for (;;)
    {
      yield acceptor_.async_accept(socket_, ref(this));

      while (!ec)
      {
        yield asio::async_read(socket_,
            asio::buffer(buffer_), ref(this));

        if (!ec)
        {
          for (std::size_t i = 0; i < n; ++i) buffer_[i] = ~buffer_[i];

          yield asio::async_write(socket_,
              asio::buffer(buffer_), ref(this));
        }
      }

      socket_.close();
    }
  }

  struct ref
  {
    explicit ref(tcp_server* p)
      : p_(p)
    {
    }

    void operator()(asio::error_code ec, std::size_t n = 0)
    {
      (*p_)(ec, n);
    }

  private:
    tcp_server* p_;
  };

private:
  tcp::acceptor& acceptor_;
  tcp::socket socket_;
  std::vector<unsigned char> buffer_;
  tcp::endpoint sender_;
};

#include <asio/unyield.hpp>

int main(int argc, char* argv[])
{
  if (argc != 5)
  {
    std::fprintf(stderr,
        "Usage: tcp_server <port> <nconns> "
        "<bufsize> {spin|block}\n");
    return 1;
  }

  unsigned short port = static_cast<unsigned short>(std::atoi(argv[1]));
  int max_connections = std::atoi(argv[2]);
  std::size_t buf_size = std::atoi(argv[3]);
  bool spin = (std::strcmp(argv[4], "spin") == 0);

  asio::io_context io_context(1);
  tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), port));
  std::vector<boost::shared_ptr<tcp_server> > servers;

  for (int i = 0; i < max_connections; ++i)
  {
    boost::shared_ptr<tcp_server> s(new tcp_server(acceptor, buf_size));
    servers.push_back(s);
    (*s)(asio::error_code());
  }

  if (spin)
    for (;;) io_context.poll();
  else
    io_context.run();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\latency\udp_client.cpp
//
// udp_client.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/ip/udp.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include "high_res_clock.hpp"

using asio::ip::udp;
using boost::posix_time::ptime;
using boost::posix_time::microsec_clock;

const int num_samples = 100000;

int main(int argc, char* argv[])
{
  if (argc != 6)
  {
    std::fprintf(stderr,
        "Usage: udp_client <ip> <port1> "
        "<nports> <bufsize> {spin|block}\n");
    return 1;
  }

  const char* ip = argv[1];
  unsigned short first_port = static_cast<unsigned short>(std::atoi(argv[2]));
  unsigned short num_ports = static_cast<unsigned short>(std::atoi(argv[3]));
  std::size_t buf_size = static_cast<std::size_t>(std::atoi(argv[4]));
  bool spin = (std::strcmp(argv[5], "spin") == 0);

  asio::io_context io_context;

  udp::socket socket(io_context, udp::endpoint(udp::v4(), 0));

  if (spin)
  {
    socket.non_blocking(true);
  }

  udp::endpoint target(asio::ip::make_address(ip), first_port);
  unsigned short last_port = first_port + num_ports - 1;
  std::vector<unsigned char> write_buf(buf_size);
  std::vector<unsigned char> read_buf(buf_size);

  ptime start = microsec_clock::universal_time();
  boost::uint64_t start_hr = high_res_clock();

  boost::uint64_t samples[num_samples];
  for (int i = 0; i < num_samples; ++i)
  {
    boost::uint64_t t = high_res_clock();

    asio::error_code ec;
    socket.send_to(asio::buffer(write_buf), target, 0, ec);
    
    do socket.receive(asio::buffer(read_buf), 0, ec);
    while (ec == asio::error::would_block);

    samples[i] = high_res_clock() - t;

    if (target.port() == last_port)
      target.port(first_port);
    else
      target.port(target.port() + 1);
  }

  ptime stop = microsec_clock::universal_time();
  boost::uint64_t stop_hr = high_res_clock();
  boost::uint64_t elapsed_usec = (stop - start).total_microseconds();
  boost::uint64_t elapsed_hr = stop_hr - start_hr;
  double scale = 1.0 * elapsed_usec / elapsed_hr;

  std::sort(samples, samples + num_samples);
  std::printf("  0.0%%\t%f\n", samples[0] * scale);
  std::printf("  0.1%%\t%f\n", samples[num_samples / 1000 - 1] * scale);
  std::printf("  1.0%%\t%f\n", samples[num_samples / 100 - 1] * scale);
  std::printf(" 10.0%%\t%f\n", samples[num_samples / 10 - 1] * scale);
  std::printf(" 20.0%%\t%f\n", samples[num_samples * 2 / 10 - 1] * scale);
  std::printf(" 30.0%%\t%f\n", samples[num_samples * 3 / 10 - 1] * scale);
  std::printf(" 40.0%%\t%f\n", samples[num_samples * 4 / 10 - 1] * scale);
  std::printf(" 50.0%%\t%f\n", samples[num_samples * 5 / 10 - 1] * scale);
  std::printf(" 60.0%%\t%f\n", samples[num_samples * 6 / 10 - 1] * scale);
  std::printf(" 70.0%%\t%f\n", samples[num_samples * 7 / 10 - 1] * scale);
  std::printf(" 80.0%%\t%f\n", samples[num_samples * 8 / 10 - 1] * scale);
  std::printf(" 90.0%%\t%f\n", samples[num_samples * 9 / 10 - 1] * scale);
  std::printf(" 99.0%%\t%f\n", samples[num_samples * 99 / 100 - 1] * scale);
  std::printf(" 99.9%%\t%f\n", samples[num_samples * 999 / 1000 - 1] * scale);
  std::printf("100.0%%\t%f\n", samples[num_samples - 1] * scale);

  double total = 0.0;
  for (int i = 0; i < num_samples; ++i) total += samples[i] * scale;
  std::printf("  mean\t%f\n", total / num_samples);
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\latency\udp_server.cpp
//
// udp_server.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include <asio/io_context.hpp>
#include <asio/ip/udp.hpp>
#include <boost/shared_ptr.hpp>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include "allocator.hpp"

using asio::ip::udp;

#include <asio/yield.hpp>

class udp_server : asio::coroutine
{
public:
  udp_server(asio::io_context& io_context,
      unsigned short port, std::size_t buf_size) :
    socket_(io_context, udp::endpoint(udp::v4(), port)),
    buffer_(buf_size)
  {
  }

  void operator()(asio::error_code ec, std::size_t n = 0)
  {
    reenter (this) for (;;)
    {
      yield socket_.async_receive_from(
          asio::buffer(buffer_),
          sender_, ref(this));

      if (!ec)
      {
        for (std::size_t i = 0; i < n; ++i) buffer_[i] = ~buffer_[i];
        socket_.send_to(asio::buffer(buffer_, n), sender_, 0, ec);
      }
    }
  }

  friend void* asio_handler_allocate(std::size_t n, udp_server* s)
  {
    return s->allocator_.allocate(n);
  }

  friend void asio_handler_deallocate(void* p, std::size_t, udp_server* s)
  {
    s->allocator_.deallocate(p);
  }

  struct ref
  {
    explicit ref(udp_server* p)
      : p_(p)
    {
    }

    void operator()(asio::error_code ec, std::size_t n = 0)
    {
      (*p_)(ec, n);
    }

  private:
    udp_server* p_;

    friend void* asio_handler_allocate(std::size_t n, ref* r)
    {
      return asio_handler_allocate(n, r->p_);
    }

    friend void asio_handler_deallocate(void* p, std::size_t n, ref* r)
    {
      asio_handler_deallocate(p, n, r->p_);
    }
  };

private:
  udp::socket socket_;
  std::vector<unsigned char> buffer_;
  udp::endpoint sender_;
  allocator allocator_;
};

#include <asio/unyield.hpp>

int main(int argc, char* argv[])
{
  if (argc != 5)
  {
    std::fprintf(stderr,
        "Usage: udp_server <port1> <nports> "
        "<bufsize> {spin|block}\n");
    return 1;
  }

  unsigned short first_port = static_cast<unsigned short>(std::atoi(argv[1]));
  unsigned short num_ports = static_cast<unsigned short>(std::atoi(argv[2]));
  std::size_t buf_size = std::atoi(argv[3]);
  bool spin = (std::strcmp(argv[4], "spin") == 0);

  asio::io_context io_context(1);
  std::vector<boost::shared_ptr<udp_server> > servers;

  for (unsigned short i = 0; i < num_ports; ++i)
  {
    unsigned short port = first_port + i;
    boost::shared_ptr<udp_server> s(new udp_server(io_context, port, buf_size));
    servers.push_back(s);
    (*s)(asio::error_code());
  }

  if (spin)
    for (;;) io_context.poll();
  else
    io_context.run();
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\performance\client.cpp
//
// client.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio.hpp"
#include <algorithm>
#include <boost/bind/bind.hpp>
#include <boost/mem_fn.hpp>
#include <iostream>
#include <list>
#include <string>
#include "handler_allocator.hpp"

class stats
{
public:
  stats()
    : mutex_(),
      total_bytes_written_(0),
      total_bytes_read_(0)
  {
  }

  void add(size_t bytes_written, size_t bytes_read)
  {
    asio::detail::mutex::scoped_lock lock(mutex_);
    total_bytes_written_ += bytes_written;
    total_bytes_read_ += bytes_read;
  }

  void print()
  {
    asio::detail::mutex::scoped_lock lock(mutex_);
    std::cout << total_bytes_written_ << " total bytes written\n";
    std::cout << total_bytes_read_ << " total bytes read\n";
  }

private:
  asio::detail::mutex mutex_;
  size_t total_bytes_written_;
  size_t total_bytes_read_;
};

class session
{
public:
  session(asio::io_context& ioc, size_t block_size, stats& s)
    : strand_(ioc.get_executor()),
      socket_(ioc),
      block_size_(block_size),
      read_data_(new char[block_size]),
      read_data_length_(0),
      write_data_(new char[block_size]),
      unwritten_count_(0),
      bytes_written_(0),
      bytes_read_(0),
      stats_(s)
  {
    for (size_t i = 0; i < block_size_; ++i)
      write_data_[i] = static_cast<char>(i % 128);
  }

  ~session()
  {
    stats_.add(bytes_written_, bytes_read_);

    delete[] read_data_;
    delete[] write_data_;
  }

  void start(asio::ip::tcp::resolver::results_type endpoints)
  {
    asio::async_connect(socket_, endpoints,
        asio::bind_executor(strand_,
          boost::bind(&session::handle_connect, this,
            asio::placeholders::error)));
  }

  void stop()
  {
    asio::post(strand_, boost::bind(&session::close_socket, this));
  }

private:
  void handle_connect(const asio::error_code& err)
  {
    if (!err)
    {
      asio::error_code set_option_err;
      asio::ip::tcp::no_delay no_delay(true);
      socket_.set_option(no_delay, set_option_err);
      if (!set_option_err)
      {
        ++unwritten_count_;
        async_write(socket_, asio::buffer(write_data_, block_size_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(write_allocator_,
                boost::bind(&session::handle_write, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
        socket_.async_read_some(asio::buffer(read_data_, block_size_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(read_allocator_,
                boost::bind(&session::handle_read, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
      }
    }
  }

  void handle_read(const asio::error_code& err, size_t length)
  {
    if (!err)
    {
      bytes_read_ += length;

      read_data_length_ = length;
      ++unwritten_count_;
      if (unwritten_count_ == 1)
      {
        std::swap(read_data_, write_data_);
        async_write(socket_, asio::buffer(write_data_, read_data_length_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(write_allocator_,
                boost::bind(&session::handle_write, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
        socket_.async_read_some(asio::buffer(read_data_, block_size_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(read_allocator_,
                boost::bind(&session::handle_read, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
      }
    }
  }

  void handle_write(const asio::error_code& err, size_t length)
  {
    if (!err && length > 0)
    {
      bytes_written_ += length;

      --unwritten_count_;
      if (unwritten_count_ == 1)
      {
        std::swap(read_data_, write_data_);
        async_write(socket_, asio::buffer(write_data_, read_data_length_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(write_allocator_,
                boost::bind(&session::handle_write, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
        socket_.async_read_some(asio::buffer(read_data_, block_size_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(read_allocator_,
                boost::bind(&session::handle_read, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
      }
    }
  }

  void close_socket()
  {
    socket_.close();
  }

private:
  asio::strand<asio::io_context::executor_type> strand_;
  asio::ip::tcp::socket socket_;
  size_t block_size_;
  char* read_data_;
  size_t read_data_length_;
  char* write_data_;
  int unwritten_count_;
  size_t bytes_written_;
  size_t bytes_read_;
  stats& stats_;
  handler_allocator read_allocator_;
  handler_allocator write_allocator_;
};

class client
{
public:
  client(asio::io_context& ioc,
      const asio::ip::tcp::resolver::results_type endpoints,
      size_t block_size, size_t session_count, int timeout)
    : io_context_(ioc),
      stop_timer_(ioc),
      sessions_(),
      stats_()
  {
    stop_timer_.expires_after(asio::chrono::seconds(timeout));
    stop_timer_.async_wait(boost::bind(&client::handle_timeout, this));

    for (size_t i = 0; i < session_count; ++i)
    {
      session* new_session = new session(io_context_, block_size, stats_);
      new_session->start(endpoints);
      sessions_.push_back(new_session);
    }
  }

  ~client()
  {
    while (!sessions_.empty())
    {
      delete sessions_.front();
      sessions_.pop_front();
    }

    stats_.print();
  }

  void handle_timeout()
  {
    std::for_each(sessions_.begin(), sessions_.end(),
        boost::mem_fn(&session::stop));
  }

private:
  asio::io_context& io_context_;
  asio::steady_timer stop_timer_;
  std::list<session*> sessions_;
  stats stats_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 7)
    {
      std::cerr << "Usage: client <host> <port> <threads> <blocksize> ";
      std::cerr << "<sessions> <time>\n";
      return 1;
    }

    using namespace std; // For atoi.
    const char* host = argv[1];
    const char* port = argv[2];
    int thread_count = atoi(argv[3]);
    size_t block_size = atoi(argv[4]);
    size_t session_count = atoi(argv[5]);
    int timeout = atoi(argv[6]);

    asio::io_context ioc;

    asio::ip::tcp::resolver r(ioc);
    asio::ip::tcp::resolver::results_type endpoints =
      r.resolve(host, port);

    client c(ioc, endpoints, block_size, session_count, timeout);

    std::list<asio::thread*> threads;
    while (--thread_count > 0)
    {
      asio::thread* new_thread = new asio::thread(
          boost::bind(&asio::io_context::run, &ioc));
      threads.push_back(new_thread);
    }

    ioc.run();

    while (!threads.empty())
    {
      threads.front()->join();
      delete threads.front();
      threads.pop_front();
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\performance\server.cpp
//
// server.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio.hpp"
#include <algorithm>
#include <boost/bind/bind.hpp>
#include <iostream>
#include <list>
#include "handler_allocator.hpp"

class session
{
public:
  session(asio::io_context& ioc, size_t block_size)
    : io_context_(ioc),
      strand_(ioc.get_executor()),
      socket_(ioc),
      block_size_(block_size),
      read_data_(new char[block_size]),
      read_data_length_(0),
      write_data_(new char[block_size]),
      unsent_count_(0),
      op_count_(0)
  {
  }

  ~session()
  {
    delete[] read_data_;
    delete[] write_data_;
  }

  asio::ip::tcp::socket& socket()
  {
    return socket_;
  }

  void start()
  {
    asio::error_code set_option_err;
    asio::ip::tcp::no_delay no_delay(true);
    socket_.set_option(no_delay, set_option_err);
    if (!set_option_err)
    {
      ++op_count_;
      socket_.async_read_some(asio::buffer(read_data_, block_size_),
          asio::bind_executor(strand_,
            make_custom_alloc_handler(read_allocator_,
              boost::bind(&session::handle_read, this,
                asio::placeholders::error,
                asio::placeholders::bytes_transferred))));
    }
    else
    {
      asio::post(io_context_, boost::bind(&session::destroy, this));
    }
  }

  void handle_read(const asio::error_code& err, size_t length)
  {
    --op_count_;

    if (!err)
    {
      read_data_length_ = length;
      ++unsent_count_;
      if (unsent_count_ == 1)
      {
        op_count_ += 2;
        std::swap(read_data_, write_data_);
        async_write(socket_, asio::buffer(write_data_, read_data_length_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(write_allocator_,
                boost::bind(&session::handle_write, this,
                  asio::placeholders::error))));
        socket_.async_read_some(asio::buffer(read_data_, block_size_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(read_allocator_,
                boost::bind(&session::handle_read, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
      }
    }

    if (op_count_ == 0)
      asio::post(io_context_, boost::bind(&session::destroy, this));
  }

  void handle_write(const asio::error_code& err)
  {
    --op_count_;

    if (!err)
    {
      --unsent_count_;
      if (unsent_count_ == 1)
      {
        op_count_ += 2;
        std::swap(read_data_, write_data_);
        async_write(socket_, asio::buffer(write_data_, read_data_length_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(write_allocator_,
                boost::bind(&session::handle_write, this,
                  asio::placeholders::error))));
        socket_.async_read_some(asio::buffer(read_data_, block_size_),
            asio::bind_executor(strand_,
              make_custom_alloc_handler(read_allocator_,
                boost::bind(&session::handle_read, this,
                  asio::placeholders::error,
                  asio::placeholders::bytes_transferred))));
      }
    }

    if (op_count_ == 0)
      asio::post(io_context_, boost::bind(&session::destroy, this));
  }

  static void destroy(session* s)
  {
    delete s;
  }

private:
  asio::io_context& io_context_;
  asio::strand<asio::io_context::executor_type> strand_;
  asio::ip::tcp::socket socket_;
  size_t block_size_;
  char* read_data_;
  size_t read_data_length_;
  char* write_data_;
  int unsent_count_;
  int op_count_;
  handler_allocator read_allocator_;
  handler_allocator write_allocator_;
};

class server
{
public:
  server(asio::io_context& ioc, const asio::ip::tcp::endpoint& endpoint,
      size_t block_size)
    : io_context_(ioc),
      acceptor_(ioc),
      block_size_(block_size)
  {
    acceptor_.open(endpoint.protocol());
    acceptor_.set_option(asio::ip::tcp::acceptor::reuse_address(1));
    acceptor_.bind(endpoint);
    acceptor_.listen();

    start_accept();
  }

  void start_accept()
  {
    session* new_session = new session(io_context_, block_size_);
    acceptor_.async_accept(new_session->socket(),
        boost::bind(&server::handle_accept, this, new_session,
          asio::placeholders::error));
  }

  void handle_accept(session* new_session, const asio::error_code& err)
  {
    if (!err)
    {
      new_session->start();
    }
    else
    {
      delete new_session;
    }

    start_accept();
  }

private:
  asio::io_context& io_context_;
  asio::ip::tcp::acceptor acceptor_;
  size_t block_size_;
};

int main(int argc, char* argv[])
{
  try
  {
    if (argc != 5)
    {
      std::cerr << "Usage: server <address> <port> <threads> <blocksize>\n";
      return 1;
    }

    using namespace std; // For atoi.
    asio::ip::address address = asio::ip::make_address(argv[1]);
    short port = atoi(argv[2]);
    int thread_count = atoi(argv[3]);
    size_t block_size = atoi(argv[4]);

    asio::io_context ioc;

    server s(ioc, asio::ip::tcp::endpoint(address, port), block_size);

    // Threads not currently supported in this test.
    std::list<asio::thread*> threads;
    while (--thread_count > 0)
    {
      asio::thread* new_thread = new asio::thread(
          boost::bind(&asio::io_context::run, &ioc));
      threads.push_back(new_thread);
    }

    ioc.run();

    while (!threads.empty())
    {
      threads.front()->join();
      delete threads.front();
      threads.pop_front();
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Exception: " << e.what() << "\n";
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_free_prefer.cpp
//
// cpp03/can_prefer_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct prefer_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_prefer<object<1>, prop<2> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_prefer<const object<1>, prop<2> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_free_require.cpp
//
// cpp03/can_prefer_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_prefer<object<1>, prop<2> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_prefer<const object<1>, prop<2> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_member_prefer.cpp
//
// cpp03/can_prefer_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct prefer_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_prefer<object<1>, prop<2> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_prefer<const object<1>, prop<2> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_member_require.cpp
//
// cpp03/can_prefer_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_prefer<object<1>, prop<2> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_prefer<const object<1>, prop<2> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_applicable_free_prefer.cpp
//
// cpp03/can_prefer_not_applicable_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct prefer_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_applicable_free_require.cpp
//
// cpp03/can_prefer_not_applicable_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_applicable_member_prefer.cpp
//
// cpp03/can_prefer_not_applicable_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct prefer_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_applicable_member_require.cpp
//
// cpp03/can_prefer_not_applicable_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_applicable_static.cpp
//
// cpp03/can_prefer_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {
namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<1> >::value));
  assert((!asio::can_prefer<object<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_prefer<object<1>, prop<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_prefer<const object<1>, prop<1> >::value));
  assert((!asio::can_prefer<const object<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_prefer<const object<1>, prop<1>, prop<1>, prop<1> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_applicable_unsupported.cpp
//
// cpp03/can_prefer_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
};

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_preferable_free_prefer.cpp
//
// cpp03/can_prefer_not_preferable_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  friend object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct prefer_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_preferable_free_require.cpp
//
// cpp03/can_prefer_not_preferable_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_preferable_member_prefer.cpp
//
// cpp03/can_prefer_not_preferable_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct prefer_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_preferable_member_require.cpp
//
// cpp03/can_prefer_not_preferable_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_preferable_static.cpp
//
// cpp03/can_prefer_not_preferable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = false;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<1> >::value));
  assert((!asio::can_prefer<object<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_prefer<object<1>, prop<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_prefer<const object<1>, prop<1> >::value));
  assert((!asio::can_prefer<const object<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_prefer<const object<1>, prop<1>, prop<1>, prop<1> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_not_preferable_unsupported.cpp
//
// cpp03/can_prefer_not_preferable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = false;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

} // namespace asio

int main()
{
  assert((!asio::can_prefer<object<1>, prop<2> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_static.cpp
//
// cpp03/can_prefer_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_prefer<object<1>, prop<1> >::value));
  assert((asio::can_prefer<object<1>, prop<1>, prop<1> >::value));
  assert((asio::can_prefer<object<1>, prop<1>, prop<1>, prop<1> >::value));
  assert((asio::can_prefer<const object<1>, prop<1> >::value));
  assert((asio::can_prefer<const object<1>, prop<1>, prop<1> >::value));
  assert((asio::can_prefer<const object<1>, prop<1>, prop<1>, prop<1> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_prefer_unsupported.cpp
//
// cpp03/can_prefer_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

} // namespace asio

int main()
{
  assert((asio::can_prefer<object<1>, prop<2> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_prefer<const object<1>, prop<2> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_free.cpp
//
// cpp03/can_query_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend int query(const object&, prop) { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

namespace traits {

template<>
struct query_free<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_query<object, prop>::value));
  assert((asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_member.cpp
//
// cpp03/can_query_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  int query(prop) const { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

namespace traits {

template<>
struct query_member<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_query<object, prop>::value));
  assert((asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_not_applicable_free.cpp
//
// cpp03/can_query_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend int query(const object&, prop) { return 123; }
};

namespace asio {
namespace traits {

template<>
struct query_free<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_query<object, prop>::value));
  assert((!asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_not_applicable_member.cpp
//
// cpp03/can_query_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  int query(prop) const { return 123; }
};

namespace asio {
namespace traits {

template<>
struct query_member<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_query<object, prop>::value));
  assert((!asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_not_applicable_static.cpp
//
// cpp03/can_query_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {
namespace traits {

template<>
struct static_query<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
  static int value() { return 123; }
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_query<object, prop>::value));
  assert((!asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_not_applicable_unsupported.cpp
//
// cpp03/can_query_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

int main()
{
  assert((!asio::can_query<object, prop>::value));
  assert((!asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_static.cpp
//
// cpp03/can_query_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

namespace traits {

template<>
struct static_query<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
  static int value() { return 123; }
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_query<object, prop>::value));
  assert((asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_query_unsupported.cpp
//
// cpp03/can_query_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {

template <>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

} // namespace asio

int main()
{
  assert((!asio::can_query<object, prop>::value));
  assert((!asio::can_query<const object, prop>::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_free.cpp
//
// cpp03/can_require_concept_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_concept_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_require_concept<object<1>, prop<2> >::value));
  assert((asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_member.cpp
//
// cpp03/can_require_concept_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_concept_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_require_concept<object<1>, prop<2> >::value));
  assert((asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_not_applicable_free.cpp
//
// cpp03/can_require_concept_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct require_concept_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_require_concept<object<1>, prop<2> >::value));
  assert((!asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_not_applicable_member.cpp
//
// cpp03/can_require_concept_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct require_concept_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_require_concept<object<1>, prop<2> >::value));
  assert((!asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_not_applicable_static.cpp
//
// cpp03/can_require_concept_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
};

namespace asio {
namespace traits {

template<int N>
struct static_require_concept<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_require_concept<object<1>, prop<2> >::value));
  assert((!asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_not_applicable_unsupported.cpp
//
// cpp03/can_require_concept_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  assert((!asio::can_require_concept<object<1>, prop<2> >::value));
  assert((!asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_static.cpp
//
// cpp03/can_require_concept_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require_concept<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_require_concept<object<1>, prop<1> >::value));
  assert((asio::can_require_concept<const object<1>, prop<1> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_concept_unsupported.cpp
//
// cpp03/can_require_concept_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

} // namespace asio

int main()
{
  assert((!asio::can_require_concept<object<1>, prop<2> >::value));
  assert((!asio::can_require_concept<const object<1>, prop<2> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_free.cpp
//
// cpp03/can_require_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_require<object<1>, prop<2> >::value));
  assert((asio::can_require<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_require<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_require<const object<1>, prop<2> >::value));
  assert((asio::can_require<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_require<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_member.cpp
//
// cpp03/can_require_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_require<object<1>, prop<2> >::value));
  assert((asio::can_require<object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_require<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((asio::can_require<const object<1>, prop<2> >::value));
  assert((asio::can_require<const object<1>, prop<2>, prop<3> >::value));
  assert((asio::can_require<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_not_applicable_free.cpp
//
// cpp03/can_require_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_require<object<1>, prop<2> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_require<const object<1>, prop<2> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_not_applicable_member.cpp
//
// cpp03/can_require_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {
namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_require<object<1>, prop<2> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_require<const object<1>, prop<2> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_not_applicable_static.cpp
//
// cpp03/can_require_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
};

namespace asio {
namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((!asio::can_require<object<1>, prop<1> >::value));
  assert((!asio::can_require<object<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_require<object<1>, prop<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_require<const object<1>, prop<1> >::value));
  assert((!asio::can_require<const object<1>, prop<1>, prop<1> >::value));
  assert((!asio::can_require<const object<1>, prop<1>, prop<1>, prop<1> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_not_applicable_unsupported.cpp
//
// cpp03/can_require_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  assert((!asio::can_require<object<1>, prop<2> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_require<const object<1>, prop<2> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_static.cpp
//
// cpp03/can_require_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  assert((asio::can_require<object<1>, prop<1> >::value));
  assert((asio::can_require<object<1>, prop<1>, prop<1> >::value));
  assert((asio::can_require<object<1>, prop<1>, prop<1>, prop<1> >::value));
  assert((asio::can_require<const object<1>, prop<1> >::value));
  assert((asio::can_require<const object<1>, prop<1>, prop<1> >::value));
  assert((asio::can_require<const object<1>, prop<1>, prop<1>, prop<1> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\can_require_unsupported.cpp
//
// cpp03/can_require_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

} // namespace asio

int main()
{
  assert((!asio::can_require<object<1>, prop<2> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<object<1>, prop<2>, prop<3>, prop<4> >::value));
  assert((!asio::can_require<const object<1>, prop<2> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3> >::value));
  assert((!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4> >::value));
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\prefer_free_prefer.cpp
//
// cpp03/prefer_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct prefer_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\prefer_free_require.cpp
//
// cpp03/prefer_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\prefer_member_prefer.cpp
//
// cpp03/prefer_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct prefer_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\prefer_member_require.cpp
//
// cpp03/prefer_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\prefer_static.cpp
//
// cpp03/prefer_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::prefer(o1, prop<1>());
  object<1> o3 = asio::prefer(o1, prop<1>(), prop<1>());
  object<1> o4 = asio::prefer(o1, prop<1>(), prop<1>(), prop<1>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::prefer(o5, prop<1>());
  object<1> o7 = asio::prefer(o5, prop<1>(), prop<1>());
  object<1> o8 = asio::prefer(o5, prop<1>(), prop<1>(), prop<1>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\prefer_unsupported.cpp
//
// cpp03/prefer_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  const object<1>& o2 = asio::prefer(o1, prop<1>());
  assert(&o1 == &o2);
  (void)o2;

  const object<1> o3 = {};
  const object<1>& o4 = asio::prefer(o3, prop<1>());
  assert(&o3 == &o4);
  (void)o4;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\query_free.cpp
//
// cpp03/query_free.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend int query(const object&, prop) { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

namespace traits {

template<>
struct query_free<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\query_member.cpp
//
// cpp03/query_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  int query(prop) const { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

namespace traits {

template<>
struct query_member<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\query_static.cpp
//
// cpp03/query_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static const bool value = true;
};

namespace traits {

template<>
struct static_query<object, prop>
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef int result_type;
  static int value() { return 123; }
};

} // namespace traits
} // namespace asio

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\require_concept_free.cpp
//
// cpp03/require_concept_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_concept_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require_concept(o1, prop<2>());
  (void)o2;

  const object<1> o3 = {};
  object<2> o4 = asio::require_concept(o3, prop<2>());
  (void)o4;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\require_concept_member.cpp
//
// cpp03/require_concept_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_concept_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require_concept(o1, prop<2>());
  (void)o2;

  const object<1> o3 = {};
  object<2> o4 = asio::require_concept(o3, prop<2>());
  (void)o4;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\require_concept_static.cpp
//
// cpp03/require_concept_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable_concept = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require_concept<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  const object<1>& o2 = asio::require_concept(o1, prop<1>());
  assert(&o1 == &o2);
  (void)o2;

  const object<1> o3 = {};
  const object<1>& o4 = asio::require_concept(o3, prop<1>());
  assert(&o3 == &o4);
  (void)o4;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\require_free.cpp
//
// cpp03/require_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_free<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require(o1, prop<2>());
  object<3> o3 = asio::require(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::require(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::require(o5, prop<2>());
  object<3> o7 = asio::require(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::require(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\require_member.cpp
//
// cpp03/require_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N, int M>
struct require_member<object<N>, prop<M> >
{
  static const bool is_valid = true;
  static const bool is_noexcept = true;
  typedef object<M> result_type;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require(o1, prop<2>());
  object<3> o3 = asio::require(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::require(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::require(o5, prop<2>());
  object<3> o7 = asio::require(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::require(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp03\require_static.cpp
//
// cpp03/require_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static const bool is_requirable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static const bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static const bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::require(o1, prop<1>());
  object<1> o3 = asio::require(o1, prop<1>(), prop<1>());
  object<1> o4 = asio::require(o1, prop<1>(), prop<1>(), prop<1>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::require(o5, prop<1>());
  object<1> o7 = asio::require(o5, prop<1>(), prop<1>());
  object<1> o8 = asio::require(o5, prop<1>(), prop<1>(), prop<1>());
  (void)o6;
  (void)o7;
  (void)o8;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_free_prefer.cpp
//
// cpp11/can_prefer_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_free_require.cpp
//
// cpp11/can_prefer_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_member_prefer.cpp
//
// cpp11/can_prefer_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_member_require.cpp
//
// cpp11/can_prefer_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_applicable_free_prefer.cpp
//
// cpp11/can_prefer_not_applicable_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_applicable_free_require.cpp
//
// cpp11/can_prefer_not_applicable_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_applicable_member_prefer.cpp
//
// cpp11/can_prefer_not_applicable_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_applicable_member_require.cpp
//
// cpp11/can_prefer_not_applicable_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_applicable_static.cpp
//
// cpp11/can_prefer_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {
namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<1>, prop<1>, prop<1>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_applicable_unsupported.cpp
//
// cpp11/can_prefer_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_preferable_free_prefer.cpp
//
// cpp11/can_prefer_not_preferable_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_preferable_free_require.cpp
//
// cpp11/can_prefer_not_preferable_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_preferable_member_prefer.cpp
//
// cpp11/can_prefer_not_preferable_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_preferable_member_require.cpp
//
// cpp11/can_prefer_not_preferable_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_preferable_static.cpp
//
// cpp11/can_prefer_not_preferable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<1>, prop<1>, prop<1>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_not_preferable_unsupported.cpp
//
// cpp11/can_prefer_not_preferable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_static.cpp
//
// cpp11/can_prefer_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(asio::can_prefer<object<1>, prop<1>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<1>, prop<1>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<1>, prop<1>, prop<1>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<1>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<1>, prop<1>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<1>, prop<1>, prop<1>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_prefer_unsupported.cpp
//
// cpp11/can_prefer_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_prefer<object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_prefer<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_free.cpp
//
// cpp11/can_query_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend constexpr int query(const object&, prop) { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_query<object, prop>::value, "");
  static_assert(asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_member.cpp
//
// cpp11/can_query_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  constexpr int query(prop) const { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_query<object, prop>::value, "");
  static_assert(asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_not_applicable_free.cpp
//
// cpp11/can_query_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend constexpr int query(const object&, prop) { return 123; }
};

int main()
{
  static_assert(!asio::can_query<object, prop>::value, "");
  static_assert(!asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_not_applicable_member.cpp
//
// cpp11/can_query_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  constexpr int query(prop) const { return 123; }
};

int main()
{
  static_assert(!asio::can_query<object, prop>::value, "");
  static_assert(!asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_not_applicable_static.cpp
//
// cpp11/can_query_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {
namespace traits {

template<>
struct static_query<object, prop>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef int result_type;
  static constexpr int value() { return 123; }
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(!asio::can_query<object, prop>::value, "");
  static_assert(!asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_not_applicable_unsupported.cpp
//
// cpp11/can_query_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

int main()
{
  static_assert(!asio::can_query<object, prop>::value, "");
  static_assert(!asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_static.cpp
//
// cpp11/can_query_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

namespace traits {

template<>
struct static_query<object, prop>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef int result_type;
  static constexpr int value() { return 123; }
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(asio::can_query<object, prop>::value, "");
  static_assert(asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_query_unsupported.cpp
//
// cpp11/can_query_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_query<object, prop>::value, "");
  static_assert(!asio::can_query<const object, prop>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_free.cpp
//
// cpp11/can_require_concept_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_member.cpp
//
// cpp11/can_require_concept_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_not_applicable_free.cpp
//
// cpp11/can_require_concept_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_not_applicable_member.cpp
//
// cpp11/can_require_concept_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_not_applicable_static.cpp
//
// cpp11/can_require_concept_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
};

namespace asio {
namespace traits {

template<int N>
struct static_require_concept<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(!asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_not_applicable_unsupported.cpp
//
// cpp11/can_require_concept_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_static.cpp
//
// cpp11/can_require_concept_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

namespace traits {

template<int N>
struct static_require_concept<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(asio::can_require_concept<object<1>, prop<1>>::value, "");
  static_assert(asio::can_require_concept<const object<1>, prop<1>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_concept_unsupported.cpp
//
// cpp11/can_require_concept_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_free.cpp
//
// cpp11/can_require_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_require<object<1>, prop<2>>::value, "");
  static_assert(asio::can_require<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_require<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_member.cpp
//
// cpp11/can_require_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(asio::can_require<object<1>, prop<2>>::value, "");
  static_assert(asio::can_require<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_require<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<2>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_not_applicable_free.cpp
//
// cpp11/can_require_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_not_applicable_member.cpp
//
// cpp11/can_require_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_not_applicable_static.cpp
//
// cpp11/can_require_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
};

namespace asio {
namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(!asio::can_require<object<1>, prop<1>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<1>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<1>, prop<1>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<1>, prop<1>, prop<1>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_not_applicable_unsupported.cpp
//
// cpp11/can_require_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_require<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_static.cpp
//
// cpp11/can_require_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  static_assert(asio::can_require<object<1>, prop<1>>::value, "");
  static_assert(asio::can_require<object<1>, prop<1>, prop<1>>::value, "");
  static_assert(asio::can_require<object<1>, prop<1>, prop<1>, prop<1>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<1>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<1>, prop<1>>::value, "");
  static_assert(asio::can_require<const object<1>, prop<1>, prop<1>, prop<1>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\can_require_unsupported.cpp
//
// cpp11/can_require_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_require<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<object<1>, prop<2>, prop<3>, prop<4>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>>::value, "");
  static_assert(!asio::can_require<const object<1>, prop<2>, prop<3>, prop<4>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\prefer_free_prefer.cpp
//
// cpp11/prefer_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\prefer_free_require.cpp
//
// cpp11/prefer_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\prefer_member_prefer.cpp
//
// cpp11/prefer_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\prefer_member_require.cpp
//
// cpp11/prefer_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\prefer_static.cpp
//
// cpp11/prefer_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::prefer(o1, prop<1>());
  object<1> o3 = asio::prefer(o1, prop<1>(), prop<1>());
  object<1> o4 = asio::prefer(o1, prop<1>(), prop<1>(), prop<1>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::prefer(o5, prop<1>());
  object<1> o7 = asio::prefer(o5, prop<1>(), prop<1>());
  object<1> o8 = asio::prefer(o5, prop<1>(), prop<1>(), prop<1>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<1> o9 = asio::prefer(object<1>(), prop<1>());
  constexpr object<1> o10 = asio::prefer(object<1>(), prop<1>(), prop<1>());
  constexpr object<1> o11 = asio::prefer(object<1>(), prop<1>(), prop<1>(), prop<1>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\prefer_unsupported.cpp
//
// cpp11/prefer_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::prefer(o1, prop<2>());
  object<1> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<1> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::prefer(o5, prop<2>());
  object<1> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<1> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<1> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<1> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<1> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\query_free.cpp
//
// cpp11/query_free.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend constexpr int query(const object&, prop) { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;

  constexpr object o3 = {};
  constexpr int result3 = asio::query(o3, prop());
  assert(result3 == 123);
  (void)result3;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\query_member.cpp
//
// cpp11/query_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  constexpr int query(prop) const { return 123; }
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;

  constexpr object o3 = {};
  constexpr int result3 = asio::query(o3, prop());
  assert(result3 == 123);
  (void)result3;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\query_static.cpp
//
// cpp11/query_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

namespace asio {

template<>
struct is_applicable_property<object, prop>
{
  static constexpr bool value = true;
};

namespace traits {

template<>
struct static_query<object, prop>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef int result_type;
  static constexpr int value() { return 123; }
};

} // namespace traits
} // namespace asio

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;

  constexpr object o3 = {};
  constexpr int result3 = asio::query(o3, prop());
  assert(result3 == 123);
  (void)result3;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\require_concept_free.cpp
//
// cpp11/require_concept_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require_concept(o1, prop<2>());
  (void)o2;

  const object<1> o3 = {};
  object<2> o4 = asio::require_concept(o3, prop<2>());
  (void)o4;

  constexpr object<2> o5 = asio::require_concept(object<1>(), prop<2>());
  (void)o5;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\require_concept_member.cpp
//
// cpp11/require_concept_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require_concept(o1, prop<2>());
  (void)o2;

  const object<1> o3 = {};
  object<2> o4 = asio::require_concept(o3, prop<2>());
  (void)o4;

  constexpr object<2> o5 = asio::require_concept(object<1>(), prop<2>());
  (void)o5;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\require_concept_static.cpp
//
// cpp11/require_concept_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

namespace traits {

template<int N>
struct static_require_concept<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  const object<1>& o2 = asio::require_concept(o1, prop<1>());
  assert(&o1 == &o2);
  (void)o2;

  const object<1> o3 = {};
  const object<1>& o4 = asio::require_concept(o3, prop<1>());
  assert(&o3 == &o4);
  (void)o4;

  constexpr object<1> o5 = asio::require_concept(object<1>(), prop<1>());
  (void)o5;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\require_free.cpp
//
// cpp11/require_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require(o1, prop<2>());
  object<3> o3 = asio::require(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::require(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::require(o5, prop<2>());
  object<3> o7 = asio::require(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::require(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::require(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::require(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::require(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\require_member.cpp
//
// cpp11/require_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require(o1, prop<2>());
  object<3> o3 = asio::require(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::require(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::require(o5, prop<2>());
  object<3> o7 = asio::require(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::require(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::require(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::require(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::require(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp11\require_static.cpp
//
// cpp11/require_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

namespace traits {

template<int N>
struct static_require<object<N>, prop<N> >
{
  static constexpr bool is_valid = true;
};

} // namespace traits
} // namespace asio

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::require(o1, prop<1>());
  object<1> o3 = asio::require(o1, prop<1>(), prop<1>());
  object<1> o4 = asio::require(o1, prop<1>(), prop<1>(), prop<1>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::require(o5, prop<1>());
  object<1> o7 = asio::require(o5, prop<1>(), prop<1>());
  object<1> o8 = asio::require(o5, prop<1>(), prop<1>(), prop<1>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<1> o9 = asio::require(object<1>(), prop<1>());
  constexpr object<1> o10 = asio::require(object<1>(), prop<1>(), prop<1>());
  constexpr object<1> o11 = asio::require(object<1>(), prop<1>(), prop<1>(), prop<1>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_free_prefer.cpp
//
// cpp14/can_prefer_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_free_require.cpp
//
// cpp14/can_prefer_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_member_prefer.cpp
//
// cpp14/can_prefer_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_member_require.cpp
//
// cpp14/can_prefer_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_applicable_free_prefer.cpp
//
// cpp14/can_prefer_not_applicable_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_applicable_free_require.cpp
//
// cpp14/can_prefer_not_applicable_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_applicable_member_prefer.cpp
//
// cpp14/can_prefer_not_applicable_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_applicable_member_require.cpp
//
// cpp14/can_prefer_not_applicable_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_applicable_static.cpp
//
// cpp14/can_prefer_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_preferable = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<1>, prop<1>, prop<1>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_applicable_unsupported.cpp
//
// cpp14/can_prefer_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_preferable_free_prefer.cpp
//
// cpp14/can_prefer_not_preferable_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_preferable_free_require.cpp
//
// cpp14/can_prefer_not_preferable_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_preferable_member_prefer.cpp
//
// cpp14/can_prefer_not_preferable_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_preferable_member_require.cpp
//
// cpp14/can_prefer_not_preferable_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_preferable_static.cpp
//
// cpp14/can_prefer_not_preferable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<1>, prop<1>, prop<1>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_not_preferable_unsupported.cpp
//
// cpp14/can_prefer_not_preferable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = false;
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_static.cpp
//
// cpp14/can_prefer_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  static_assert(asio::can_prefer_v<object<1>, prop<1>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<1>, prop<1>>, "");
  static_assert(asio::can_prefer_v<object<1>, prop<1>, prop<1>, prop<1>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<1>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<1>, prop<1>>, "");
  static_assert(asio::can_prefer_v<const object<1>, prop<1>, prop<1>, prop<1>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_prefer_unsupported.cpp
//
// cpp14/can_prefer_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_prefer_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_prefer_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_free.cpp
//
// cpp14/can_query_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
};

struct object
{
  friend constexpr int query(const object&, prop) { return 123; }
};

int main()
{
  static_assert(asio::can_query_v<object, prop>, "");
  static_assert(asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_member.cpp
//
// cpp14/can_query_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
};

struct object
{
  constexpr int query(prop) const { return 123; }
};

int main()
{
  static_assert(asio::can_query_v<object, prop>, "");
  static_assert(asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_not_applicable_free.cpp
//
// cpp14/can_query_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  friend constexpr int query(const object&, prop) { return 123; }
};

int main()
{
  static_assert(!asio::can_query_v<object, prop>, "");
  static_assert(!asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_not_applicable_member.cpp
//
// cpp14/can_query_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
  constexpr int query(prop) const { return 123; }
};

int main()
{
  static_assert(!asio::can_query_v<object, prop>, "");
  static_assert(!asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_not_applicable_static.cpp
//
// cpp14/can_query_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr int static_query_v = 123;
};

struct object
{
};

int main()
{
  static_assert(!asio::can_query_v<object, prop>, "");
  static_assert(!asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_not_applicable_unsupported.cpp
//
// cpp14/can_query_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
};

struct object
{
};

int main()
{
  static_assert(!asio::can_query_v<object, prop>, "");
  static_assert(!asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_static.cpp
//
// cpp14/can_query_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  template <typename> static constexpr int static_query_v = 123;
};

struct object
{
};

int main()
{
  static_assert(asio::can_query_v<object, prop>, "");
  static_assert(asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_query_unsupported.cpp
//
// cpp14/can_query_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
};

struct object
{
};

int main()
{
  static_assert(!asio::can_query_v<object, prop>, "");
  static_assert(!asio::can_query_v<const object, prop>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_free.cpp
//
// cpp14/can_require_concept_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_require_concept_v<object<1>, prop<2>>, "");
  static_assert(asio::can_require_concept_v<const object<1>, prop<2>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_member.cpp
//
// cpp14/can_require_concept_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_require_concept_v<object<1>, prop<2>>, "");
  static_assert(asio::can_require_concept_v<const object<1>, prop<2>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_not_applicable_free.cpp
//
// cpp14/can_require_concept_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require_concept_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_concept_v<const object<1>, prop<2>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_not_applicable_member.cpp
//
// cpp14/can_require_concept_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require_concept_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_concept_v<const object<1>, prop<2>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_not_applicable_static.cpp
//
// cpp14/can_require_concept_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable_concept = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_require_concept_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_concept_v<const object<1>, prop<2>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_not_applicable_unsupported.cpp
//
// cpp14/can_require_concept_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_require_concept_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_concept_v<const object<1>, prop<2>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_static.cpp
//
// cpp14/can_require_concept_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable_concept = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  static_assert(asio::can_require_concept_v<object<1>, prop<1>>, "");
  static_assert(asio::can_require_concept_v<const object<1>, prop<1>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_concept_unsupported.cpp
//
// cpp14/can_require_concept_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_require_concept<object<1>, prop<2>>::value, "");
  static_assert(!asio::can_require_concept<const object<1>, prop<2>>::value, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_free.cpp
//
// cpp14/can_require_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_require_v<object<1>, prop<2>>, "");
  static_assert(asio::can_require_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_require_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<2>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_member.cpp
//
// cpp14/can_require_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(asio::can_require_v<object<1>, prop<2>>, "");
  static_assert(asio::can_require_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_require_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<2>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_not_applicable_free.cpp
//
// cpp14/can_require_not_applicable_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_not_applicable_member.cpp
//
// cpp14/can_require_not_applicable_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  static_assert(!asio::can_require_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_not_applicable_static.cpp
//
// cpp14/can_require_not_applicable_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  static constexpr bool is_requirable = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_require_v<object<1>, prop<1>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<1>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<1>, prop<1>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<1>, prop<1>, prop<1>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_not_applicable_unsupported.cpp
//
// cpp14/can_require_not_applicable_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

int main()
{
  static_assert(!asio::can_require_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_static.cpp
//
// cpp14/can_require_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  static_assert(asio::can_require_v<object<1>, prop<1>>, "");
  static_assert(asio::can_require_v<object<1>, prop<1>, prop<1>>, "");
  static_assert(asio::can_require_v<object<1>, prop<1>, prop<1>, prop<1>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<1>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<1>, prop<1>>, "");
  static_assert(asio::can_require_v<const object<1>, prop<1>, prop<1>, prop<1>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\can_require_unsupported.cpp
//
// cpp14/can_require_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
};

template <int>
struct object
{
};

namespace asio {

template<int N, int M>
struct is_applicable_property<object<N>, prop<M> >
{
  static constexpr bool value = true;
};

} // namespace asio

int main()
{
  static_assert(!asio::can_require_v<object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<object<1>, prop<2>, prop<3>, prop<4>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>>, "");
  static_assert(!asio::can_require_v<const object<1>, prop<2>, prop<3>, prop<4>>, "");
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\prefer_free_prefer.cpp
//
// cpp14/prefer_free_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> prefer(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\prefer_free_require.cpp
//
// cpp14/prefer_free_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\prefer_member_prefer.cpp
//
// cpp14/prefer_member_prefer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> prefer(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\prefer_member_require.cpp
//
// cpp14/prefer_member_require.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::prefer(o1, prop<2>());
  object<3> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::prefer(o5, prop<2>());
  object<3> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\prefer_static.cpp
//
// cpp14/prefer_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::prefer(o1, prop<1>());
  object<1> o3 = asio::prefer(o1, prop<1>(), prop<1>());
  object<1> o4 = asio::prefer(o1, prop<1>(), prop<1>(), prop<1>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::prefer(o5, prop<1>());
  object<1> o7 = asio::prefer(o5, prop<1>(), prop<1>());
  object<1> o8 = asio::prefer(o5, prop<1>(), prop<1>(), prop<1>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<1> o9 = asio::prefer(object<1>(), prop<1>());
  constexpr object<1> o10 = asio::prefer(object<1>(), prop<1>(), prop<1>());
  constexpr object<1> o11 = asio::prefer(object<1>(), prop<1>(), prop<1>(), prop<1>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\prefer_unsupported.cpp
//
// cpp14/prefer_unsupported.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/prefer.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_preferable = true;
};

template <int>
struct object
{
};

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::prefer(o1, prop<2>());
  object<1> o3 = asio::prefer(o1, prop<2>(), prop<3>());
  object<1> o4 = asio::prefer(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::prefer(o5, prop<2>());
  object<1> o7 = asio::prefer(o5, prop<2>(), prop<3>());
  object<1> o8 = asio::prefer(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<1> o9 = asio::prefer(object<1>(), prop<2>());
  constexpr object<1> o10 = asio::prefer(object<1>(), prop<2>(), prop<3>());
  constexpr object<1> o11 = asio::prefer(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\query_free.cpp
//
// cpp14/query_free.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
};

struct object
{
  friend constexpr int query(const object&, prop) { return 123; }
};

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;

  constexpr object o3 = {};
  constexpr int result3 = asio::query(o3, prop());
  assert(result3 == 123);
  (void)result3;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\query_member.cpp
//
// cpp14/query_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
};

struct object
{
  constexpr int query(prop) const { return 123; }
};

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;

  constexpr object o3 = {};
  constexpr int result3 = asio::query(o3, prop());
  assert(result3 == 123);
  (void)result3;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\query_static.cpp
//
// cpp14/query_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/query.hpp"
#include <cassert>

struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  template <typename> static constexpr int static_query_v = 123;
};

struct object
{
};

int main()
{
  object o1 = {};
  int result1 = asio::query(o1, prop());
  assert(result1 == 123);
  (void)result1;

  const object o2 = {};
  int result2 = asio::query(o2, prop());
  assert(result2 == 123);
  (void)result2;

  constexpr object o3 = {};
  constexpr int result3 = asio::query(o3, prop());
  assert(result3 == 123);
  (void)result3;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\require_concept_free.cpp
//
// cpp14/require_concept_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require_concept(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require_concept(o1, prop<2>());
  (void)o2;

  const object<1> o3 = {};
  object<2> o4 = asio::require_concept(o3, prop<2>());
  (void)o4;

  constexpr object<2> o5 = asio::require_concept(object<1>(), prop<2>());
  (void)o5;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\require_concept_member.cpp
//
// cpp14/require_concept_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable_concept = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require_concept(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require_concept(o1, prop<2>());
  (void)o2;

  const object<1> o3 = {};
  object<2> o4 = asio::require_concept(o3, prop<2>());
  (void)o4;

  constexpr object<2> o5 = asio::require_concept(object<1>(), prop<2>());
  (void)o5;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\require_concept_static.cpp
//
// cpp14/require_concept_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require_concept.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable_concept = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  object<1> o1 = {};
  const object<1>& o2 = asio::require_concept(o1, prop<1>());
  assert(&o1 == &o2);
  (void)o2;

  const object<1> o3 = {};
  const object<1>& o4 = asio::require_concept(o3, prop<1>());
  assert(&o3 == &o4);
  (void)o4;

  constexpr object<1> o5 = asio::require_concept(object<1>(), prop<1>());
  (void)o5;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\require_free.cpp
//
// cpp14/require_free.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  friend constexpr object<N> require(const object&, prop<N>)
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require(o1, prop<2>());
  object<3> o3 = asio::require(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::require(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::require(o5, prop<2>());
  object<3> o7 = asio::require(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::require(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::require(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::require(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::require(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\require_member.cpp
//
// cpp14/require_member.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable = true;
};

template <int>
struct object
{
  template <int N>
  constexpr object<N> require(prop<N>) const
  {
    return object<N>();
  }
};

int main()
{
  object<1> o1 = {};
  object<2> o2 = asio::require(o1, prop<2>());
  object<3> o3 = asio::require(o1, prop<2>(), prop<3>());
  object<4> o4 = asio::require(o1, prop<2>(), prop<3>(), prop<4>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<2> o6 = asio::require(o5, prop<2>());
  object<3> o7 = asio::require(o5, prop<2>(), prop<3>());
  object<4> o8 = asio::require(o5, prop<2>(), prop<3>(), prop<4>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<2> o9 = asio::require(object<1>(), prop<2>());
  constexpr object<3> o10 = asio::require(object<1>(), prop<2>(), prop<3>());
  constexpr object<4> o11 = asio::require(object<1>(), prop<2>(), prop<3>(), prop<4>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\properties\cpp14\require_static.cpp
//
// cpp14/require_static.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/require.hpp"
#include <cassert>

template <int>
struct prop
{
  template <typename> static constexpr bool is_applicable_property_v = true;
  static constexpr bool is_requirable = true;
  template <typename> static constexpr bool static_query_v = true;
  static constexpr bool value() { return true; }
};

template <int>
struct object
{
};

int main()
{
  object<1> o1 = {};
  object<1> o2 = asio::require(o1, prop<1>());
  object<1> o3 = asio::require(o1, prop<1>(), prop<1>());
  object<1> o4 = asio::require(o1, prop<1>(), prop<1>(), prop<1>());
  (void)o2;
  (void)o3;
  (void)o4;

  const object<1> o5 = {};
  object<1> o6 = asio::require(o5, prop<1>());
  object<1> o7 = asio::require(o5, prop<1>(), prop<1>());
  object<1> o8 = asio::require(o5, prop<1>(), prop<1>(), prop<1>());
  (void)o6;
  (void)o7;
  (void)o8;

  constexpr object<1> o9 = asio::require(object<1>(), prop<1>());
  constexpr object<1> o10 = asio::require(object<1>(), prop<1>(), prop<1>());
  constexpr object<1> o11 = asio::require(object<1>(), prop<1>(), prop<1>(), prop<1>());
  (void)o9;
  (void)o10;
  (void)o11;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\any_executor.cpp
//
// any_executor.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/any_executor.hpp"

#include <cstring>
#include <functional>
#include "asio/thread_pool.hpp"
#include "../unit_test.hpp"

using namespace asio;
namespace bindns = std;

static bool next_nothrow_new_fails = false;

void* operator new(std::size_t n,
    const std::nothrow_t&) noexcept
{
  if (next_nothrow_new_fails)
  {
    next_nothrow_new_fails = false;
    return 0;
  }
  return ::operator new(n);
}

struct fat_executor
{
  fat_executor(int id)
    : id_(id)
  {
    std::memset(data_, 0, sizeof(data_));
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  std::size_t query(execution::occupancy_t) const
  {
    return 1;
  }

  friend bool operator==(const fat_executor& a,
      const fat_executor& b) noexcept
  {
    return a.id_ == b.id_;
  }

  friend bool operator!=(const fat_executor& a,
      const fat_executor& b) noexcept
  {
    return a.id_ != b.id_;
  }

  int id_;
  unsigned char data_[1024];
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<fat_executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <>
struct query_member<fat_executor, execution::occupancy_t>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;
  typedef std::size_t result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<fat_executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

} // namespace traits
} // namespace asio

void increment(int* count)
{
  ++(*count);
}

void any_executor_construction_test()
{
  typedef execution::any_executor<> ex_no_props_t;

  typedef execution::any_executor<
      execution::blocking_t
    > ex_one_prop_t;

  typedef execution::any_executor<
      execution::blocking_t,
      execution::occupancy_t
    > ex_two_props_t;

  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  ex_two_props_t ex_two_props_1;

  ASIO_CHECK(ex_two_props_1.target<void>() == 0);
  ASIO_CHECK(ex_two_props_1 == null_ptr);

  ex_two_props_t ex_two_props_2(null_ptr);

  ASIO_CHECK(ex_two_props_2.target<void>() == 0);
  ASIO_CHECK(ex_two_props_2 == null_ptr);
  ASIO_CHECK(ex_two_props_2 == ex_two_props_1);

  ex_two_props_t ex_two_props_3(pool.executor());

  ASIO_CHECK(ex_two_props_3.target<void>() != 0);
  ASIO_CHECK(ex_two_props_3 != null_ptr);
  ASIO_CHECK(ex_two_props_3 != ex_two_props_1);

  ex_two_props_t ex_two_props_4(ex_two_props_1);

  ASIO_CHECK(ex_two_props_4.target<void>() == 0);
  ASIO_CHECK(ex_two_props_4 == null_ptr);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_1);

  ex_two_props_t ex_two_props_5(ex_two_props_3);

  ASIO_CHECK(ex_two_props_5.target<void>() != 0);
  ASIO_CHECK(ex_two_props_5 != null_ptr);
  ASIO_CHECK(ex_two_props_5 == ex_two_props_3);

  ex_two_props_t ex_two_props_6 = fat_executor(1);

  ASIO_CHECK(ex_two_props_6.target<void>() != 0);
  ASIO_CHECK(ex_two_props_6 != null_ptr);
  ASIO_CHECK(ex_two_props_6 != ex_two_props_1);

  ex_two_props_t ex_two_props_7 = fat_executor(1);

  ASIO_CHECK(ex_two_props_7.target<void>() != 0);
  ASIO_CHECK(ex_two_props_7 != null_ptr);
  ASIO_CHECK(ex_two_props_7 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_7 == ex_two_props_6);

  ex_two_props_t ex_two_props_8 = fat_executor(2);

  ASIO_CHECK(ex_two_props_8.target<void>() != 0);
  ASIO_CHECK(ex_two_props_8 != null_ptr);
  ASIO_CHECK(ex_two_props_8 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_8 != ex_two_props_6);
  ASIO_CHECK(ex_two_props_8 != ex_two_props_7);

  ex_two_props_t ex_two_props_9(ex_two_props_6);

  ASIO_CHECK(ex_two_props_9.target<void>() != 0);
  ASIO_CHECK(ex_two_props_9 != null_ptr);
  ASIO_CHECK(ex_two_props_9 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_9 == ex_two_props_6);
  ASIO_CHECK(ex_two_props_9 == ex_two_props_7);
  ASIO_CHECK(ex_two_props_9 != ex_two_props_8);

  ex_two_props_t ex_two_props_10(std::move(ex_two_props_1));

  ASIO_CHECK(ex_two_props_10.target<void>() == 0);
  ASIO_CHECK(ex_two_props_10 == null_ptr);
  ASIO_CHECK(ex_two_props_1.target<void>() == 0);
  ASIO_CHECK(ex_two_props_1 == null_ptr);

  ex_two_props_t ex_two_props_11(std::move(ex_two_props_3));

  ASIO_CHECK(ex_two_props_11.target<void>() != 0);
  ASIO_CHECK(ex_two_props_11 != null_ptr);
  ASIO_CHECK(ex_two_props_3.target<void>() == 0);
  ASIO_CHECK(ex_two_props_3 == null_ptr);
  ASIO_CHECK(ex_two_props_11 == ex_two_props_5);

  ex_two_props_t ex_two_props_12(std::move(ex_two_props_7));

  ASIO_CHECK(ex_two_props_12.target<void>() != 0);
  ASIO_CHECK(ex_two_props_12 != null_ptr);
  ASIO_CHECK(ex_two_props_7.target<void>() == 0);
  ASIO_CHECK(ex_two_props_7 == null_ptr);
  ASIO_CHECK(ex_two_props_12 == ex_two_props_6);
  ASIO_CHECK(ex_two_props_12 != ex_two_props_8);

  ex_one_prop_t ex_one_prop_1;

  ASIO_CHECK(ex_one_prop_1.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_1 == null_ptr);

  ex_one_prop_t ex_one_prop_2(null_ptr);

  ASIO_CHECK(ex_one_prop_2.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_2 == null_ptr);
  ASIO_CHECK(ex_one_prop_2 == ex_one_prop_1);

  ex_one_prop_t ex_one_prop_3(pool.executor());

  ASIO_CHECK(ex_one_prop_3.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_3 != null_ptr);
  ASIO_CHECK(ex_one_prop_3 != ex_one_prop_1);

  ex_one_prop_t ex_one_prop_4(ex_one_prop_1);

  ASIO_CHECK(ex_one_prop_4.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_4 == null_ptr);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_1);

  ex_one_prop_t ex_one_prop_5(ex_one_prop_3);

  ASIO_CHECK(ex_one_prop_5.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_5 != null_ptr);
  ASIO_CHECK(ex_one_prop_5 == ex_one_prop_3);

  ex_one_prop_t ex_one_prop_6 = fat_executor(1);

  ASIO_CHECK(ex_one_prop_6.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_6 != null_ptr);
  ASIO_CHECK(ex_one_prop_6 != ex_one_prop_1);

  ex_one_prop_t ex_one_prop_7 = fat_executor(1);

  ASIO_CHECK(ex_one_prop_7.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_7 != null_ptr);
  ASIO_CHECK(ex_one_prop_7 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_7 == ex_one_prop_6);

  ex_one_prop_t ex_one_prop_8 = fat_executor(2);

  ASIO_CHECK(ex_one_prop_8.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_8 != null_ptr);
  ASIO_CHECK(ex_one_prop_8 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_8 != ex_one_prop_6);
  ASIO_CHECK(ex_one_prop_8 != ex_one_prop_7);

  ex_one_prop_t ex_one_prop_9(ex_one_prop_6);

  ASIO_CHECK(ex_one_prop_9.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_9 != null_ptr);
  ASIO_CHECK(ex_one_prop_9 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_9 == ex_one_prop_6);
  ASIO_CHECK(ex_one_prop_9 == ex_one_prop_7);
  ASIO_CHECK(ex_one_prop_9 != ex_one_prop_8);

  ex_one_prop_t ex_one_prop_10(std::move(ex_one_prop_1));

  ASIO_CHECK(ex_one_prop_10.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_10 == null_ptr);
  ASIO_CHECK(ex_one_prop_1.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_1 == null_ptr);

  ex_one_prop_t ex_one_prop_11(std::move(ex_one_prop_3));

  ASIO_CHECK(ex_one_prop_11.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_11 != null_ptr);
  ASIO_CHECK(ex_one_prop_3.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_3 == null_ptr);
  ASIO_CHECK(ex_one_prop_11 == ex_one_prop_5);

  ex_one_prop_t ex_one_prop_12(std::move(ex_one_prop_7));

  ASIO_CHECK(ex_one_prop_12.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_12 != null_ptr);
  ASIO_CHECK(ex_one_prop_7.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_7 == null_ptr);
  ASIO_CHECK(ex_one_prop_12 == ex_one_prop_6);
  ASIO_CHECK(ex_one_prop_12 != ex_one_prop_8);

  ex_one_prop_t ex_one_prop_13(ex_two_props_1);

  ASIO_CHECK(ex_one_prop_13.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_13 == null_ptr);

  ex_one_prop_t ex_one_prop_14(ex_two_props_5);

  ASIO_CHECK(ex_one_prop_14.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_14 != null_ptr);

  ex_one_prop_t ex_one_prop_15(ex_two_props_9);

  ASIO_CHECK(ex_one_prop_15.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_15 != null_ptr);

  ex_no_props_t ex_no_props_1;

  ASIO_CHECK(ex_no_props_1.target<void>() == 0);
  ASIO_CHECK(ex_no_props_1 == null_ptr);

  ex_no_props_t ex_no_props_2(null_ptr);

  ASIO_CHECK(ex_no_props_2.target<void>() == 0);
  ASIO_CHECK(ex_no_props_2 == null_ptr);
  ASIO_CHECK(ex_no_props_2 == ex_no_props_1);

  ex_no_props_t ex_no_props_3(pool.executor());

  ASIO_CHECK(ex_no_props_3.target<void>() != 0);
  ASIO_CHECK(ex_no_props_3 != null_ptr);
  ASIO_CHECK(ex_no_props_3 != ex_no_props_1);

  ex_no_props_t ex_no_props_4(ex_no_props_1);

  ASIO_CHECK(ex_no_props_4.target<void>() == 0);
  ASIO_CHECK(ex_no_props_4 == null_ptr);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_1);

  ex_no_props_t ex_no_props_5(ex_no_props_3);

  ASIO_CHECK(ex_no_props_5.target<void>() != 0);
  ASIO_CHECK(ex_no_props_5 != null_ptr);
  ASIO_CHECK(ex_no_props_5 == ex_no_props_3);

  ex_no_props_t ex_no_props_6 = fat_executor(1);

  ASIO_CHECK(ex_no_props_6.target<void>() != 0);
  ASIO_CHECK(ex_no_props_6 != null_ptr);
  ASIO_CHECK(ex_no_props_6 != ex_no_props_1);

  ex_no_props_t ex_no_props_7 = fat_executor(1);

  ASIO_CHECK(ex_no_props_7.target<void>() != 0);
  ASIO_CHECK(ex_no_props_7 != null_ptr);
  ASIO_CHECK(ex_no_props_7 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_7 == ex_no_props_6);

  ex_no_props_t ex_no_props_8 = fat_executor(2);

  ASIO_CHECK(ex_no_props_8.target<void>() != 0);
  ASIO_CHECK(ex_no_props_8 != null_ptr);
  ASIO_CHECK(ex_no_props_8 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_8 != ex_no_props_6);
  ASIO_CHECK(ex_no_props_8 != ex_no_props_7);

  ex_no_props_t ex_no_props_9(ex_no_props_6);

  ASIO_CHECK(ex_no_props_9.target<void>() != 0);
  ASIO_CHECK(ex_no_props_9 != null_ptr);
  ASIO_CHECK(ex_no_props_9 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_9 == ex_no_props_6);
  ASIO_CHECK(ex_no_props_9 == ex_no_props_7);
  ASIO_CHECK(ex_no_props_9 != ex_no_props_8);

  ex_no_props_t ex_no_props_10(std::move(ex_no_props_1));

  ASIO_CHECK(ex_no_props_10.target<void>() == 0);
  ASIO_CHECK(ex_no_props_10 == null_ptr);
  ASIO_CHECK(ex_no_props_1.target<void>() == 0);
  ASIO_CHECK(ex_no_props_1 == null_ptr);

  ex_no_props_t ex_no_props_11(std::move(ex_no_props_3));

  ASIO_CHECK(ex_no_props_11.target<void>() != 0);
  ASIO_CHECK(ex_no_props_11 != null_ptr);
  ASIO_CHECK(ex_no_props_3.target<void>() == 0);
  ASIO_CHECK(ex_no_props_3 == null_ptr);
  ASIO_CHECK(ex_no_props_11 == ex_no_props_5);

  ex_no_props_t ex_no_props_12(std::move(ex_no_props_7));

  ASIO_CHECK(ex_no_props_12.target<void>() != 0);
  ASIO_CHECK(ex_no_props_12 != null_ptr);
  ASIO_CHECK(ex_no_props_7.target<void>() == 0);
  ASIO_CHECK(ex_no_props_7 == null_ptr);
  ASIO_CHECK(ex_no_props_12 == ex_no_props_6);
  ASIO_CHECK(ex_no_props_12 != ex_no_props_8);

  ex_no_props_t ex_no_props_13(ex_two_props_1);

  ASIO_CHECK(ex_no_props_13.target<void>() == 0);
  ASIO_CHECK(ex_no_props_13 == null_ptr);

  ex_no_props_t ex_no_props_14(ex_two_props_5);

  ASIO_CHECK(ex_no_props_14.target<void>() != 0);
  ASIO_CHECK(ex_no_props_14 != null_ptr);

  ex_no_props_t ex_no_props_15(ex_two_props_9);

  ASIO_CHECK(ex_no_props_15.target<void>() != 0);
  ASIO_CHECK(ex_no_props_15 != null_ptr);

  ex_no_props_t ex_no_props_16(ex_one_prop_1);

  ASIO_CHECK(ex_no_props_16.target<void>() == 0);
  ASIO_CHECK(ex_no_props_16 == null_ptr);

  ex_no_props_t ex_no_props_17(ex_one_prop_5);

  ASIO_CHECK(ex_no_props_17.target<void>() != 0);
  ASIO_CHECK(ex_no_props_17 != null_ptr);

  ex_no_props_t ex_no_props_18(ex_one_prop_9);

  ASIO_CHECK(ex_no_props_18.target<void>() != 0);
  ASIO_CHECK(ex_no_props_18 != null_ptr);
}

void any_executor_nothrow_construction_test()
{
  typedef execution::any_executor<> ex_no_props_t;

  typedef execution::any_executor<
      execution::blocking_t
    > ex_one_prop_t;

  typedef execution::any_executor<
      execution::blocking_t,
      execution::occupancy_t
    > ex_two_props_t;

  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  ex_two_props_t ex_two_props_1;

  ASIO_CHECK(ex_two_props_1.target<void>() == 0);
  ASIO_CHECK(ex_two_props_1 == null_ptr);

  ex_two_props_t ex_two_props_2(null_ptr);

  ASIO_CHECK(ex_two_props_2.target<void>() == 0);
  ASIO_CHECK(ex_two_props_2 == null_ptr);
  ASIO_CHECK(ex_two_props_2 == ex_two_props_1);

  ex_two_props_t ex_two_props_3(std::nothrow, pool.executor());

  ASIO_CHECK(ex_two_props_3.target<void>() != 0);
  ASIO_CHECK(ex_two_props_3 != null_ptr);
  ASIO_CHECK(ex_two_props_3 != ex_two_props_1);

  ex_two_props_t ex_two_props_4(std::nothrow, ex_two_props_1);

  ASIO_CHECK(ex_two_props_4.target<void>() == 0);
  ASIO_CHECK(ex_two_props_4 == null_ptr);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_1);

  ex_two_props_t ex_two_props_5(std::nothrow, ex_two_props_3);

  ASIO_CHECK(ex_two_props_5.target<void>() != 0);
  ASIO_CHECK(ex_two_props_5 != null_ptr);
  ASIO_CHECK(ex_two_props_5 == ex_two_props_3);

  ex_two_props_t ex_two_props_6(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex_two_props_6.target<void>() != 0);
  ASIO_CHECK(ex_two_props_6 != null_ptr);
  ASIO_CHECK(ex_two_props_6 != ex_two_props_1);

  ex_two_props_t ex_two_props_7(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex_two_props_7.target<void>() != 0);
  ASIO_CHECK(ex_two_props_7 != null_ptr);
  ASIO_CHECK(ex_two_props_7 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_7 == ex_two_props_6);

  ex_two_props_t ex_two_props_8(std::nothrow, fat_executor(2));

  ASIO_CHECK(ex_two_props_8.target<void>() != 0);
  ASIO_CHECK(ex_two_props_8 != null_ptr);
  ASIO_CHECK(ex_two_props_8 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_8 != ex_two_props_6);
  ASIO_CHECK(ex_two_props_8 != ex_two_props_7);

  ex_two_props_t ex_two_props_9(std::nothrow, ex_two_props_6);

  ASIO_CHECK(ex_two_props_9.target<void>() != 0);
  ASIO_CHECK(ex_two_props_9 != null_ptr);
  ASIO_CHECK(ex_two_props_9 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_9 == ex_two_props_6);
  ASIO_CHECK(ex_two_props_9 == ex_two_props_7);
  ASIO_CHECK(ex_two_props_9 != ex_two_props_8);

  ex_two_props_t ex_two_props_10(std::nothrow, std::move(ex_two_props_1));

  ASIO_CHECK(ex_two_props_10.target<void>() == 0);
  ASIO_CHECK(ex_two_props_10 == null_ptr);
  ASIO_CHECK(ex_two_props_1.target<void>() == 0);
  ASIO_CHECK(ex_two_props_1 == null_ptr);

  ex_two_props_t ex_two_props_11(std::nothrow, std::move(ex_two_props_3));

  ASIO_CHECK(ex_two_props_11.target<void>() != 0);
  ASIO_CHECK(ex_two_props_11 != null_ptr);
  ASIO_CHECK(ex_two_props_3.target<void>() == 0);
  ASIO_CHECK(ex_two_props_3 == null_ptr);
  ASIO_CHECK(ex_two_props_11 == ex_two_props_5);

  ex_two_props_t ex_two_props_12(std::nothrow, std::move(ex_two_props_7));

  ASIO_CHECK(ex_two_props_12.target<void>() != 0);
  ASIO_CHECK(ex_two_props_12 != null_ptr);
  ASIO_CHECK(ex_two_props_7.target<void>() == 0);
  ASIO_CHECK(ex_two_props_7 == null_ptr);
  ASIO_CHECK(ex_two_props_12 == ex_two_props_6);
  ASIO_CHECK(ex_two_props_12 != ex_two_props_8);

  next_nothrow_new_fails = true;
  ex_two_props_t ex_two_props_13(std::nothrow, fat_executor(3));

  ASIO_CHECK(ex_two_props_13.target<void>() == 0);
  ASIO_CHECK(ex_two_props_13 == null_ptr);
  ASIO_CHECK(ex_two_props_13 == ex_two_props_1);

  ex_one_prop_t ex_one_prop_1;

  ASIO_CHECK(ex_one_prop_1.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_1 == null_ptr);

  ex_one_prop_t ex_one_prop_2(null_ptr);

  ASIO_CHECK(ex_one_prop_2.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_2 == null_ptr);
  ASIO_CHECK(ex_one_prop_2 == ex_one_prop_1);

  ex_one_prop_t ex_one_prop_3(std::nothrow, pool.executor());

  ASIO_CHECK(ex_one_prop_3.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_3 != null_ptr);
  ASIO_CHECK(ex_one_prop_3 != ex_one_prop_1);

  ex_one_prop_t ex_one_prop_4(std::nothrow, ex_one_prop_1);

  ASIO_CHECK(ex_one_prop_4.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_4 == null_ptr);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_1);

  ex_one_prop_t ex_one_prop_5(std::nothrow, ex_one_prop_3);

  ASIO_CHECK(ex_one_prop_5.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_5 != null_ptr);
  ASIO_CHECK(ex_one_prop_5 == ex_one_prop_3);

  ex_one_prop_t ex_one_prop_6 = fat_executor(1);

  ASIO_CHECK(ex_one_prop_6.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_6 != null_ptr);
  ASIO_CHECK(ex_one_prop_6 != ex_one_prop_1);

  ex_one_prop_t ex_one_prop_7(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex_one_prop_7.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_7 != null_ptr);
  ASIO_CHECK(ex_one_prop_7 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_7 == ex_one_prop_6);

  ex_one_prop_t ex_one_prop_8(std::nothrow, fat_executor(2));

  ASIO_CHECK(ex_one_prop_8.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_8 != null_ptr);
  ASIO_CHECK(ex_one_prop_8 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_8 != ex_one_prop_6);
  ASIO_CHECK(ex_one_prop_8 != ex_one_prop_7);

  ex_one_prop_t ex_one_prop_9(std::nothrow, ex_one_prop_6);

  ASIO_CHECK(ex_one_prop_9.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_9 != null_ptr);
  ASIO_CHECK(ex_one_prop_9 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_9 == ex_one_prop_6);
  ASIO_CHECK(ex_one_prop_9 == ex_one_prop_7);
  ASIO_CHECK(ex_one_prop_9 != ex_one_prop_8);

  ex_one_prop_t ex_one_prop_10(std::nothrow, std::move(ex_one_prop_1));

  ASIO_CHECK(ex_one_prop_10.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_10 == null_ptr);
  ASIO_CHECK(ex_one_prop_1.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_1 == null_ptr);

  ex_one_prop_t ex_one_prop_11(std::nothrow, std::move(ex_one_prop_3));

  ASIO_CHECK(ex_one_prop_11.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_11 != null_ptr);
  ASIO_CHECK(ex_one_prop_3.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_3 == null_ptr);
  ASIO_CHECK(ex_one_prop_11 == ex_one_prop_5);

  ex_one_prop_t ex_one_prop_12(std::nothrow, std::move(ex_one_prop_7));

  ASIO_CHECK(ex_one_prop_12.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_12 != null_ptr);
  ASIO_CHECK(ex_one_prop_7.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_7 == null_ptr);
  ASIO_CHECK(ex_one_prop_12 == ex_one_prop_6);
  ASIO_CHECK(ex_one_prop_12 != ex_one_prop_8);

  ex_one_prop_t ex_one_prop_13(std::nothrow, ex_two_props_1);

  ASIO_CHECK(ex_one_prop_13.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_13 == null_ptr);

  ex_one_prop_t ex_one_prop_14(std::nothrow, ex_two_props_5);

  ASIO_CHECK(ex_one_prop_14.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_14 != null_ptr);

  ex_one_prop_t ex_one_prop_15(std::nothrow, ex_two_props_9);

  ASIO_CHECK(ex_one_prop_15.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_15 != null_ptr);

  next_nothrow_new_fails = true;
  ex_one_prop_t ex_one_prop_16(std::nothrow, fat_executor(3));

  ASIO_CHECK(ex_one_prop_16.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_16 == null_ptr);
  ASIO_CHECK(ex_one_prop_16 == ex_one_prop_1);

  ex_no_props_t ex_no_props_1;

  ASIO_CHECK(ex_no_props_1.target<void>() == 0);
  ASIO_CHECK(ex_no_props_1 == null_ptr);

  ex_no_props_t ex_no_props_2(null_ptr);

  ASIO_CHECK(ex_no_props_2.target<void>() == 0);
  ASIO_CHECK(ex_no_props_2 == null_ptr);
  ASIO_CHECK(ex_no_props_2 == ex_no_props_1);

  ex_no_props_t ex_no_props_3(std::nothrow, pool.executor());

  ASIO_CHECK(ex_no_props_3.target<void>() != 0);
  ASIO_CHECK(ex_no_props_3 != null_ptr);
  ASIO_CHECK(ex_no_props_3 != ex_no_props_1);

  ex_no_props_t ex_no_props_4(std::nothrow, ex_no_props_1);

  ASIO_CHECK(ex_no_props_4.target<void>() == 0);
  ASIO_CHECK(ex_no_props_4 == null_ptr);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_1);

  ex_no_props_t ex_no_props_5(std::nothrow, ex_no_props_3);

  ASIO_CHECK(ex_no_props_5.target<void>() != 0);
  ASIO_CHECK(ex_no_props_5 != null_ptr);
  ASIO_CHECK(ex_no_props_5 == ex_no_props_3);

  ex_no_props_t ex_no_props_6(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex_no_props_6.target<void>() != 0);
  ASIO_CHECK(ex_no_props_6 != null_ptr);
  ASIO_CHECK(ex_no_props_6 != ex_no_props_1);

  ex_no_props_t ex_no_props_7(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex_no_props_7.target<void>() != 0);
  ASIO_CHECK(ex_no_props_7 != null_ptr);
  ASIO_CHECK(ex_no_props_7 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_7 == ex_no_props_6);

  ex_no_props_t ex_no_props_8(std::nothrow, fat_executor(2));

  ASIO_CHECK(ex_no_props_8.target<void>() != 0);
  ASIO_CHECK(ex_no_props_8 != null_ptr);
  ASIO_CHECK(ex_no_props_8 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_8 != ex_no_props_6);
  ASIO_CHECK(ex_no_props_8 != ex_no_props_7);

  ex_no_props_t ex_no_props_9(std::nothrow, ex_no_props_6);

  ASIO_CHECK(ex_no_props_9.target<void>() != 0);
  ASIO_CHECK(ex_no_props_9 != null_ptr);
  ASIO_CHECK(ex_no_props_9 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_9 == ex_no_props_6);
  ASIO_CHECK(ex_no_props_9 == ex_no_props_7);
  ASIO_CHECK(ex_no_props_9 != ex_no_props_8);

  ex_no_props_t ex_no_props_10(std::nothrow, std::move(ex_no_props_1));

  ASIO_CHECK(ex_no_props_10.target<void>() == 0);
  ASIO_CHECK(ex_no_props_10 == null_ptr);
  ASIO_CHECK(ex_no_props_1.target<void>() == 0);
  ASIO_CHECK(ex_no_props_1 == null_ptr);

  ex_no_props_t ex_no_props_11(std::nothrow, std::move(ex_no_props_3));

  ASIO_CHECK(ex_no_props_11.target<void>() != 0);
  ASIO_CHECK(ex_no_props_11 != null_ptr);
  ASIO_CHECK(ex_no_props_3.target<void>() == 0);
  ASIO_CHECK(ex_no_props_3 == null_ptr);
  ASIO_CHECK(ex_no_props_11 == ex_no_props_5);

  ex_no_props_t ex_no_props_12(std::nothrow, std::move(ex_no_props_7));

  ASIO_CHECK(ex_no_props_12.target<void>() != 0);
  ASIO_CHECK(ex_no_props_12 != null_ptr);
  ASIO_CHECK(ex_no_props_7.target<void>() == 0);
  ASIO_CHECK(ex_no_props_7 == null_ptr);
  ASIO_CHECK(ex_no_props_12 == ex_no_props_6);
  ASIO_CHECK(ex_no_props_12 != ex_no_props_8);

  ex_no_props_t ex_no_props_13(std::nothrow, ex_two_props_1);

  ASIO_CHECK(ex_no_props_13.target<void>() == 0);
  ASIO_CHECK(ex_no_props_13 == null_ptr);

  ex_no_props_t ex_no_props_14(std::nothrow, ex_two_props_5);

  ASIO_CHECK(ex_no_props_14.target<void>() != 0);
  ASIO_CHECK(ex_no_props_14 != null_ptr);

  ex_no_props_t ex_no_props_15(std::nothrow, ex_two_props_9);

  ASIO_CHECK(ex_no_props_15.target<void>() != 0);
  ASIO_CHECK(ex_no_props_15 != null_ptr);

  ex_no_props_t ex_no_props_16(std::nothrow, ex_one_prop_1);

  ASIO_CHECK(ex_no_props_16.target<void>() == 0);
  ASIO_CHECK(ex_no_props_16 == null_ptr);

  ex_no_props_t ex_no_props_17(std::nothrow, ex_one_prop_5);

  ASIO_CHECK(ex_no_props_17.target<void>() != 0);
  ASIO_CHECK(ex_no_props_17 != null_ptr);

  ex_no_props_t ex_no_props_18(std::nothrow, ex_one_prop_9);

  ASIO_CHECK(ex_no_props_18.target<void>() != 0);
  ASIO_CHECK(ex_no_props_18 != null_ptr);

  next_nothrow_new_fails = true;
  ex_no_props_t ex_no_props_19(std::nothrow, fat_executor(3));

  ASIO_CHECK(ex_no_props_19.target<void>() == 0);
  ASIO_CHECK(ex_no_props_19 == null_ptr);
  ASIO_CHECK(ex_no_props_19 == ex_no_props_1);
}

void any_executor_assignment_test()
{
  typedef execution::any_executor<> ex_no_props_t;

  typedef execution::any_executor<
      execution::blocking_t
    > ex_one_prop_t;

  typedef execution::any_executor<
      execution::blocking_t,
      execution::occupancy_t
    > ex_two_props_t;

  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  ex_two_props_t ex_two_props_1;

  ex_two_props_t ex_two_props_2;
  ex_two_props_2 = null_ptr;

  ASIO_CHECK(ex_two_props_2.target<void>() == 0);

  ex_two_props_t ex_two_props_3;
  ex_two_props_3 = pool.executor();

  ASIO_CHECK(ex_two_props_3.target<void>() != 0);

  ex_two_props_t ex_two_props_4;
  ex_two_props_4 = ex_two_props_1;

  ASIO_CHECK(ex_two_props_4.target<void>() == 0);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_1);

  ex_two_props_4 = ex_two_props_3;

  ASIO_CHECK(ex_two_props_4.target<void>() != 0);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_3);

  ex_two_props_t ex_two_props_5;
  ex_two_props_5 = fat_executor(1);

  ASIO_CHECK(ex_two_props_5.target<void>() != 0);
  ASIO_CHECK(ex_two_props_5 != null_ptr);
  ASIO_CHECK(ex_two_props_5 != ex_two_props_1);

  ex_two_props_t ex_two_props_6;
  ex_two_props_6 = fat_executor(1);

  ASIO_CHECK(ex_two_props_6.target<void>() != 0);
  ASIO_CHECK(ex_two_props_6 != null_ptr);
  ASIO_CHECK(ex_two_props_6 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_6 == ex_two_props_5);

  ex_two_props_6 = fat_executor(2);

  ASIO_CHECK(ex_two_props_6.target<void>() != 0);
  ASIO_CHECK(ex_two_props_6 != null_ptr);
  ASIO_CHECK(ex_two_props_6 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_6 != ex_two_props_5);

  ex_two_props_t ex_two_props_7;
  ex_two_props_7 = ex_two_props_5;

  ASIO_CHECK(ex_two_props_7.target<void>() != 0);
  ASIO_CHECK(ex_two_props_7 != null_ptr);
  ASIO_CHECK(ex_two_props_7 != ex_two_props_1);
  ASIO_CHECK(ex_two_props_7 == ex_two_props_5);
  ASIO_CHECK(ex_two_props_7 != ex_two_props_6);

  ex_two_props_t ex_two_props_8;
  ex_two_props_8 = std::move(ex_two_props_1);

  ASIO_CHECK(ex_two_props_8.target<void>() == 0);
  ASIO_CHECK(ex_two_props_1.target<void>() == 0);

  ex_two_props_8 = std::move(ex_two_props_3);

  ASIO_CHECK(ex_two_props_8.target<void>() != 0);
  ASIO_CHECK(ex_two_props_3.target<void>() == 0);
  ASIO_CHECK(ex_two_props_8 == ex_two_props_4);

  ex_two_props_8 = std::move(ex_two_props_5);

  ASIO_CHECK(ex_two_props_8.target<void>() != 0);
  ASIO_CHECK(ex_two_props_5.target<void>() == 0);
  ASIO_CHECK(ex_two_props_8 == ex_two_props_7);

  ex_one_prop_t ex_one_prop_1;

  ex_one_prop_t ex_one_prop_2;
  ex_one_prop_2 = null_ptr;

  ASIO_CHECK(ex_one_prop_2.target<void>() == 0);

  ex_one_prop_t ex_one_prop_3;
  ex_one_prop_3 = pool.executor();

  ASIO_CHECK(ex_one_prop_3.target<void>() != 0);

  ex_one_prop_t ex_one_prop_4;
  ex_one_prop_4 = ex_one_prop_1;

  ASIO_CHECK(ex_one_prop_4.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_1);

  ex_one_prop_4 = ex_one_prop_3;

  ASIO_CHECK(ex_one_prop_4.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_3);

  ex_one_prop_t ex_one_prop_5;
  ex_one_prop_5 = fat_executor(1);

  ASIO_CHECK(ex_one_prop_5.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_5 != null_ptr);
  ASIO_CHECK(ex_one_prop_5 != ex_one_prop_1);

  ex_one_prop_t ex_one_prop_6;
  ex_one_prop_6 = fat_executor(1);

  ASIO_CHECK(ex_one_prop_6.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_6 != null_ptr);
  ASIO_CHECK(ex_one_prop_6 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_6 == ex_one_prop_5);

  ex_one_prop_6 = fat_executor(2);

  ASIO_CHECK(ex_one_prop_6.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_6 != null_ptr);
  ASIO_CHECK(ex_one_prop_6 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_6 != ex_one_prop_5);

  ex_one_prop_t ex_one_prop_7;
  ex_one_prop_7 = ex_one_prop_5;

  ASIO_CHECK(ex_one_prop_7.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_7 != null_ptr);
  ASIO_CHECK(ex_one_prop_7 != ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_7 == ex_one_prop_5);
  ASIO_CHECK(ex_one_prop_7 != ex_one_prop_6);

  ex_one_prop_t ex_one_prop_8;
  ex_one_prop_8 = std::move(ex_one_prop_1);

  ASIO_CHECK(ex_one_prop_8.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_1.target<void>() == 0);

  ex_one_prop_8 = std::move(ex_one_prop_3);

  ASIO_CHECK(ex_one_prop_8.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_3.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_8 == ex_one_prop_4);

  ex_one_prop_8 = std::move(ex_one_prop_5);

  ASIO_CHECK(ex_one_prop_8.target<void>() != 0);
  ASIO_CHECK(ex_one_prop_5.target<void>() == 0);
  ASIO_CHECK(ex_one_prop_8 == ex_one_prop_7);

  ex_one_prop_t ex_one_prop_9;
  ex_one_prop_9 = ex_two_props_1;

  ASIO_CHECK(ex_one_prop_9.target<void>() == 0);

  ex_one_prop_9 = ex_two_props_4;

  ASIO_CHECK(ex_one_prop_9.target<void>() != 0);

  ex_one_prop_9 = ex_two_props_7;

  ASIO_CHECK(ex_one_prop_9.target<void>() != 0);

  ex_no_props_t ex_no_props_1;

  ex_no_props_t ex_no_props_2;
  ex_no_props_2 = null_ptr;

  ASIO_CHECK(ex_no_props_2.target<void>() == 0);

  ex_no_props_t ex_no_props_3;
  ex_no_props_3 = pool.executor();

  ASIO_CHECK(ex_no_props_3.target<void>() != 0);

  ex_no_props_t ex_no_props_4;
  ex_no_props_4 = ex_no_props_1;

  ASIO_CHECK(ex_no_props_4.target<void>() == 0);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_1);

  ex_no_props_4 = ex_no_props_3;

  ASIO_CHECK(ex_no_props_4.target<void>() != 0);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_3);

  ex_no_props_t ex_no_props_5;
  ex_no_props_5 = fat_executor(1);

  ASIO_CHECK(ex_no_props_5.target<void>() != 0);
  ASIO_CHECK(ex_no_props_5 != null_ptr);
  ASIO_CHECK(ex_no_props_5 != ex_no_props_1);

  ex_no_props_t ex_no_props_6;
  ex_no_props_6 = fat_executor(1);

  ASIO_CHECK(ex_no_props_6.target<void>() != 0);
  ASIO_CHECK(ex_no_props_6 != null_ptr);
  ASIO_CHECK(ex_no_props_6 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_6 == ex_no_props_5);

  ex_no_props_6 = fat_executor(2);

  ASIO_CHECK(ex_no_props_6.target<void>() != 0);
  ASIO_CHECK(ex_no_props_6 != null_ptr);
  ASIO_CHECK(ex_no_props_6 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_6 != ex_no_props_5);

  ex_no_props_t ex_no_props_7;
  ex_no_props_7 = ex_no_props_5;

  ASIO_CHECK(ex_no_props_7.target<void>() != 0);
  ASIO_CHECK(ex_no_props_7 != null_ptr);
  ASIO_CHECK(ex_no_props_7 != ex_no_props_1);
  ASIO_CHECK(ex_no_props_7 == ex_no_props_5);
  ASIO_CHECK(ex_no_props_7 != ex_no_props_6);

  ex_no_props_t ex_no_props_8;
  ex_no_props_8 = std::move(ex_no_props_1);

  ASIO_CHECK(ex_no_props_8.target<void>() == 0);
  ASIO_CHECK(ex_no_props_1.target<void>() == 0);

  ex_no_props_8 = std::move(ex_no_props_3);

  ASIO_CHECK(ex_no_props_8.target<void>() != 0);
  ASIO_CHECK(ex_no_props_3.target<void>() == 0);
  ASIO_CHECK(ex_no_props_8 == ex_no_props_4);

  ex_no_props_8 = std::move(ex_no_props_5);

  ASIO_CHECK(ex_no_props_8.target<void>() != 0);
  ASIO_CHECK(ex_no_props_5.target<void>() == 0);
  ASIO_CHECK(ex_no_props_8 == ex_no_props_7);

  ex_no_props_t ex_no_props_9;
  ex_no_props_9 = ex_two_props_1;

  ASIO_CHECK(ex_no_props_9.target<void>() == 0);

  ex_no_props_9 = ex_two_props_4;

  ASIO_CHECK(ex_no_props_9.target<void>() != 0);

  ex_no_props_9 = ex_two_props_7;

  ASIO_CHECK(ex_no_props_9.target<void>() != 0);

  ex_no_props_9 = ex_one_prop_1;

  ASIO_CHECK(ex_no_props_9.target<void>() == 0);

  ex_no_props_9 = ex_one_prop_4;

  ASIO_CHECK(ex_no_props_9.target<void>() != 0);

  ex_no_props_9 = ex_one_prop_7;

  ASIO_CHECK(ex_no_props_9.target<void>() != 0);
}

void any_executor_swap_test()
{
  typedef execution::any_executor<> ex_no_props_t;

  typedef execution::any_executor<
      execution::blocking_t
    > ex_one_prop_t;

  typedef execution::any_executor<
      execution::blocking_t,
      execution::occupancy_t
    > ex_two_props_t;

  thread_pool pool1(1);
  thread_pool pool2(1);

  ex_no_props_t ex_no_props_1(pool1.executor());
  ex_no_props_t ex_no_props_2(pool2.executor());

  ex_no_props_t ex_no_props_3(ex_no_props_1);
  ex_no_props_t ex_no_props_4(ex_no_props_2);

  ASIO_CHECK(ex_no_props_3 == ex_no_props_1);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_2);

  ex_no_props_3.swap(ex_no_props_4);

  ASIO_CHECK(ex_no_props_3 == ex_no_props_2);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_1);

  execution::swap(ex_no_props_3, ex_no_props_4);

  ASIO_CHECK(ex_no_props_3 == ex_no_props_1);
  ASIO_CHECK(ex_no_props_4 == ex_no_props_2);

  ex_one_prop_t ex_one_prop_1(pool1.executor());
  ex_one_prop_t ex_one_prop_2(pool2.executor());

  ex_one_prop_t ex_one_prop_3(ex_one_prop_1);
  ex_one_prop_t ex_one_prop_4(ex_one_prop_2);

  ASIO_CHECK(ex_one_prop_3 == ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_2);

  ex_one_prop_3.swap(ex_one_prop_4);

  ASIO_CHECK(ex_one_prop_3 == ex_one_prop_2);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_1);

  execution::swap(ex_one_prop_3, ex_one_prop_4);

  ASIO_CHECK(ex_one_prop_3 == ex_one_prop_1);
  ASIO_CHECK(ex_one_prop_4 == ex_one_prop_2);

  ex_two_props_t ex_two_props_1(pool1.executor());
  ex_two_props_t ex_two_props_2(pool2.executor());

  ex_two_props_t ex_two_props_3(ex_two_props_1);
  ex_two_props_t ex_two_props_4(ex_two_props_2);

  ASIO_CHECK(ex_two_props_3 == ex_two_props_1);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_2);

  ex_two_props_3.swap(ex_two_props_4);

  ASIO_CHECK(ex_two_props_3 == ex_two_props_2);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_1);

  execution::swap(ex_two_props_3, ex_two_props_4);

  ASIO_CHECK(ex_two_props_3 == ex_two_props_1);
  ASIO_CHECK(ex_two_props_4 == ex_two_props_2);
}

void any_executor_query_test()
{
  thread_pool pool(1);
  execution::any_executor<
      execution::blocking_t,
      execution::outstanding_work_t,
      execution::relationship_t,
      execution::mapping_t::thread_t,
      execution::occupancy_t>
    ex(pool.executor());

  ASIO_CHECK(
      asio::query(ex, asio::execution::blocking)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex, asio::execution::blocking.possibly)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex, asio::execution::outstanding_work)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ex, asio::execution::outstanding_work.untracked)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ex, asio::execution::relationship)
        == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(ex, asio::execution::relationship.fork)
        == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(ex, asio::execution::mapping)
        == asio::execution::mapping.thread);

  ASIO_CHECK(
      asio::query(ex, asio::execution::occupancy)
        == 1);
}

void any_executor_execute_test()
{
  int count = 0;
  thread_pool pool(1);
  execution::any_executor<
      execution::blocking_t::possibly_t,
      execution::blocking_t::never_t,
      execution::outstanding_work_t::untracked_t,
      execution::outstanding_work_t::tracked_t,
      execution::relationship_t::continuation_t>
    ex(pool.executor());

  ex.execute(bindns::bind(increment, &count));

  asio::require(ex, asio::execution::blocking.possibly).execute(
      bindns::bind(increment, &count));

  asio::require(ex, asio::execution::blocking.never).execute(
      bindns::bind(increment, &count));

  asio::require(ex,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.tracked
    ).execute(bindns::bind(increment, &count));

  asio::require(ex,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked
    ).execute(bindns::bind(increment, &count));

  asio::require(ex,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.continuation
    ).execute(bindns::bind(increment, &count));

  pool.wait();

  ASIO_CHECK(count == 6);
}

ASIO_TEST_SUITE
(
  "any_executor",
  ASIO_TEST_CASE(any_executor_construction_test)
  ASIO_TEST_CASE(any_executor_nothrow_construction_test)
  ASIO_TEST_CASE(any_executor_assignment_test)
  ASIO_TEST_CASE(any_executor_swap_test)
  ASIO_TEST_CASE(any_executor_query_test)
  ASIO_TEST_CASE(any_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\blocking_adaptation.cpp
//
// blocking_adaptation.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/blocking_adaptation.hpp"

#include "asio/prefer.hpp"
#include "asio/query.hpp"
#include "asio/require.hpp"
#include "../unit_test.hpp"

namespace exec = asio::execution;

typedef exec::blocking_adaptation_t s;
typedef exec::blocking_adaptation_t::disallowed_t n1;
typedef exec::blocking_adaptation_t::allowed_t n2;

struct ex_nq_nr
{
  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<ex_nq_nr>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename Function>
struct execute_member<ex_nq_nr, Function>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_cq_nr
{
  static constexpr ResultType query(ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct equality_comparable<ex_cq_nr<ResultType, ParamType, Result> >
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
    typename Result, typename Function>
struct execute_member<ex_cq_nr<ResultType, ParamType, Result>, Function>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_static_constexpr_member<
  ex_cq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef Result result_type; // Must return raw result type.

  static constexpr result_type value()
  {
    return Result();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_mq_nr
{
  ResultType query(ParamType) const noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct equality_comparable<ex_mq_nr<ResultType, ParamType, Result> >
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
    typename Result, typename Function>
struct execute_member<ex_mq_nr<ResultType, ParamType, Result>, Function>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_member<
  ex_mq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_fq_nr
{
  friend ResultType query(const ex_fq_nr&, ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct equality_comparable<ex_fq_nr<ResultType, ParamType, Result> >
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
    typename Result, typename Function>
struct execute_member<ex_fq_nr<ResultType, ParamType, Result>, Function>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_free<
  ex_fq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_mq_mr
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  CurrentType query(OtherType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, OtherType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, OtherType>();
  }

  ex_mq_mr<OtherType, CurrentType> require(
      OtherType) const noexcept
  {
    return ex_mq_mr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_mq_mr<CurrentType, CurrentType>
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, CurrentType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <typename CurrentType, typename OtherType>
struct equality_comparable<ex_mq_mr<CurrentType, OtherType> >
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Function>
struct execute_member<ex_mq_mr<CurrentType, OtherType>, Function>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_fq_fr
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend CurrentType query(const ex_fq_fr&, OtherType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, OtherType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> require(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, OtherType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> prefer(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_fq_fr<CurrentType, CurrentType>
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, CurrentType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, CurrentType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <typename CurrentType, typename OtherType>
struct equality_comparable<ex_fq_fr<CurrentType, OtherType> >
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Function>
struct execute_member<ex_fq_fr<CurrentType, OtherType>, Function>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_query()
{
  constexpr bool b1 =
    asio::can_query<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_query<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_query<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_query<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_query()
{
  exec::blocking_adaptation_t result1 = asio::query(Executor(), Param());
  ASIO_CHECK(result1 == ExpectedResult());

  Executor ex1 = {};
  exec::blocking_adaptation_t result2 = asio::query(ex1, Param());
  ASIO_CHECK(result2 == ExpectedResult());

  const Executor ex2 = {};
  exec::blocking_adaptation_t result3 = asio::query(ex2, Param());
  ASIO_CHECK(result3 == ExpectedResult());
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_constexpr_query()
{
  constexpr Executor ex1 = {};
  constexpr exec::blocking_adaptation_t result1 = asio::query(ex1, Param());
  ASIO_CHECK(result1 == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_require()
{
  constexpr bool b1 =
    asio::can_require<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_require<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_require<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_require<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

void do_nothing()
{
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_require()
{
  ASIO_CHECK(
      asio::query(
        asio::require(Executor(), Param()),
        Param()) == ExpectedResult());

  Executor ex1 = {};

  ASIO_CHECK(
      asio::query(
        asio::require(ex1, Param()),
        Param()) == ExpectedResult());

  ASIO_CHECK((
      asio::execution::is_executor<
        typename asio::decay<
          typename asio::require_result<Executor&, Param>::type
        >::type
      >::value));

  const Executor ex2 = {};

  ASIO_CHECK(
      asio::query(
        asio::require(ex2, Param()),
        Param()) == ExpectedResult());

  ASIO_CHECK((
      asio::execution::is_executor<
        typename asio::decay<
          typename asio::require_result<const Executor&, Param>::type
        >::type
      >::value));
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_prefer()
{
  constexpr bool b1 =
    asio::can_prefer<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_prefer<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_prefer<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_prefer<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_prefer()
{
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(Executor(), Param()),
          s())) == s(ExpectedResult()));

  Executor ex1 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex1, Param()),
          s())) == s(ExpectedResult()));

  const Executor ex2 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex2, Param()),
          s())) == s(ExpectedResult()));
}

void test_vars()
{
  ASIO_CHECK(s() == exec::blocking_adaptation);
  ASIO_CHECK(s() != exec::blocking_adaptation.disallowed);
  ASIO_CHECK(s() != exec::blocking_adaptation.allowed);
  ASIO_CHECK(n1() == exec::blocking_adaptation.disallowed);
  ASIO_CHECK(n1() != exec::blocking_adaptation.allowed);
  ASIO_CHECK(n2() == exec::blocking_adaptation.allowed);
  ASIO_CHECK(n2() != exec::blocking_adaptation.disallowed);
}

ASIO_TEST_SUITE
(
  "blocking_adaptation",

  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, s, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n2, false>)

  ASIO_TEST_CASE3(test_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n2, true>)

  ASIO_TEST_CASE3(test_require<ex_nq_nr, n1, n1>)
  ASIO_TEST_CASE3(test_require<ex_nq_nr, n2, n2>)

  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n2, false>)

  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n2, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n1, s, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n1, n2>)

  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_require<ex_mq_nr<s, s, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<s, n1, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<s, n2, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<n1, s, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_mq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n1, n2>)

  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_require<ex_fq_nr<s, s, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<s, n1, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<s, n2, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<n1, s, n1>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_fq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n1, n2>)

  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n2, false>)

  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n1, n2>)

  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n2, false>)

  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n1, n2>)

  ASIO_TEST_CASE(test_vars)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\blocking.cpp
//
// blocking.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/blocking.hpp"

#include "asio/prefer.hpp"
#include "asio/query.hpp"
#include "asio/require.hpp"
#include "../unit_test.hpp"

namespace exec = asio::execution;

typedef exec::blocking_t s;
typedef exec::blocking_t::possibly_t n1;
typedef exec::blocking_t::always_t n2;
typedef exec::blocking_t::never_t n3;

struct ex_nq_nr
{
  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <>
struct is_executor<ex_nq_nr> : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct ex_cq_nr
{
  static constexpr ResultType query(ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_cq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_static_constexpr_member<
  ex_cq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef Result result_type; // Must return raw result type.

  static constexpr result_type value()
  {
    return Result();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_mq_nr
{
  ResultType query(ParamType) const noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_mq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_member<
  ex_mq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_fq_nr
{
  friend ResultType query(const ex_fq_nr&, ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_fq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_free<
  ex_fq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_mq_mr
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  CurrentType query(OtherType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, OtherType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, OtherType>();
  }

  ex_mq_mr<OtherType, CurrentType> require(
      OtherType) const noexcept
  {
    return ex_mq_mr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_mq_mr<CurrentType, CurrentType>
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, CurrentType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_mq_mr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_fq_fr
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend CurrentType query(const ex_fq_fr&, OtherType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, OtherType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> require(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, OtherType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> prefer(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_fq_fr<CurrentType, CurrentType>
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, CurrentType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, CurrentType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_fq_fr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_query()
{
  constexpr bool b1 =
    asio::can_query<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_query<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_query<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_query<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_query()
{
  exec::blocking_t result1 = asio::query(Executor(), Param());
  ASIO_CHECK(result1 == ExpectedResult());

  Executor ex1 = {};
  exec::blocking_t result2 = asio::query(ex1, Param());
  ASIO_CHECK(result2 == ExpectedResult());

  const Executor ex2 = {};
  exec::blocking_t result3 = asio::query(ex2, Param());
  ASIO_CHECK(result3 == ExpectedResult());
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_constexpr_query()
{
  constexpr Executor ex1 = {};
  constexpr exec::blocking_t result1 = asio::query(ex1, Param());
  ASIO_CHECK(result1 == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_require()
{
  constexpr bool b1 =
    asio::can_require<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_require<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_require<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_require<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_require()
{
  ASIO_CHECK(
      asio::query(
        asio::require(Executor(), Param()),
        Param()) == ExpectedResult());

  Executor ex1 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex1, Param()),
        Param()) == ExpectedResult());

  const Executor ex2 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex2, Param()),
        Param()) == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_prefer()
{
  constexpr bool b1 =
    asio::can_prefer<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_prefer<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_prefer<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_prefer<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_prefer()
{
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(Executor(), Param()),
          s())) == s(ExpectedResult()));

  Executor ex1 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex1, Param()),
          s())) == s(ExpectedResult()));

  const Executor ex2 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex2, Param()),
          s())) == s(ExpectedResult()));
}

void test_vars()
{
  ASIO_CHECK(s() == exec::blocking);
  ASIO_CHECK(s() != exec::blocking.possibly);
  ASIO_CHECK(s() != exec::blocking.always);
  ASIO_CHECK(s() != exec::blocking.never);
  ASIO_CHECK(n1() == exec::blocking.possibly);
  ASIO_CHECK(n1() != exec::blocking.always);
  ASIO_CHECK(n1() != exec::blocking.never);
  ASIO_CHECK(n2() == exec::blocking.always);
  ASIO_CHECK(n2() != exec::blocking.possibly);
  ASIO_CHECK(n2() != exec::blocking.never);
  ASIO_CHECK(n3() == exec::blocking.never);
  ASIO_CHECK(n3() != exec::blocking.possibly);
  ASIO_CHECK(n3() != exec::blocking.always);
}

ASIO_TEST_SUITE
(
  "blocking",

  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, s, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n2, false>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n3, false>)

  ASIO_TEST_CASE3(test_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n2, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n3, false>)

  ASIO_TEST_CASE3(test_require<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n2, false>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n3, true>)

  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n1, n1>)
  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n3, n1>)

  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, n3, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, n3, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n3>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n3>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n1>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n2>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n3>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n3>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n2>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n3>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n3>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n3>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n1>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n2>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n3>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n3>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n2>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n3>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE(test_vars)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\context_as.cpp
//
// context_as.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/context_as.hpp"

#include <functional>
#include "asio/execution/any_executor.hpp"
#include "asio/io_context.hpp"
#include "asio/static_thread_pool.hpp"
#include "../unit_test.hpp"

using namespace asio;
namespace bindns = std;

void context_as_executor_query_test()
{
  static_thread_pool pool(1);

  ASIO_CHECK(
      &asio::query(pool.executor(),
        execution::context_as_t<static_thread_pool&>())
        == &pool);

  execution::any_executor<
      execution::context_as_t<static_thread_pool&>
    > ex1 = pool.executor();

  ASIO_CHECK(
      &asio::query(ex1,
        execution::context_as_t<static_thread_pool&>())
        == &pool);

  ASIO_CHECK(
      &asio::query(ex1, execution::context)
        == &pool);

  ASIO_CHECK(
      &asio::query(pool.executor(),
        execution::context_as_t<const static_thread_pool&>())
        == &pool);

  execution::any_executor<
      execution::context_as_t<const static_thread_pool&>
    > ex2 = pool.executor();

  ASIO_CHECK(
      &asio::query(ex2,
        execution::context_as_t<const static_thread_pool&>())
        == &pool);

  ASIO_CHECK(
      &asio::query(ex2, execution::context)
        == &pool);

  io_context io_ctx;

  ASIO_CHECK(
      &asio::query(io_ctx.get_executor(),
        execution::context_as_t<io_context&>())
        == &io_ctx);

  execution::any_executor<
      execution::context_as_t<io_context&>
    > ex3 = io_ctx.get_executor();

  ASIO_CHECK(
      &asio::query(ex3,
        execution::context_as_t<io_context&>())
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(ex3, execution::context)
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(io_ctx.get_executor(),
        execution::context_as_t<const io_context&>())
        == &io_ctx);

  execution::any_executor<
      execution::context_as_t<const io_context&>
    > ex4 = io_ctx.get_executor();

  ASIO_CHECK(
      &asio::query(ex4,
        execution::context_as_t<const io_context&>())
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(ex4, execution::context)
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(io_ctx.get_executor(),
        execution::context_as_t<execution_context&>())
        == &io_ctx);

  execution::any_executor<
      execution::context_as_t<execution_context&>
    > ex5 = io_ctx.get_executor();

  ASIO_CHECK(
      &asio::query(ex5,
        execution::context_as_t<execution_context&>())
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(ex5, execution::context)
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(io_ctx.get_executor(),
        execution::context_as_t<const execution_context&>())
        == &io_ctx);

  execution::any_executor<
      execution::context_as_t<const execution_context&>
    > ex6 = io_ctx.get_executor();

  ASIO_CHECK(
      &asio::query(ex6,
        execution::context_as_t<const execution_context&>())
        == &io_ctx);

  ASIO_CHECK(
      &asio::query(ex6, execution::context)
        == &io_ctx);
}

ASIO_TEST_SUITE
(
  "context_as",
  ASIO_TEST_CASE(context_as_executor_query_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\executor.cpp
//
// executor.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/executor.hpp"

#include "../unit_test.hpp"

struct not_an_executor
{
};

struct executor
{
  executor()
  {
  }

  executor(const executor&) noexcept
  {
  }

  executor(executor&&) noexcept
  {
  }

  template <typename F>
  void execute(F&& f) const noexcept
  {
    (void)f;
  }

  bool operator==(const executor&) const noexcept
  {
    return true;
  }

  bool operator!=(const executor&) const noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_SET_ERROR_MEMBER_TRAIT)
#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

} // namespace traits
} // namespace asio

void is_executor_test()
{
  ASIO_CHECK((
      !asio::execution::is_executor<
        void
      >::value));

  ASIO_CHECK((
      !asio::execution::is_executor<
        not_an_executor
      >::value));

  ASIO_CHECK((
      asio::execution::is_executor<
        executor
      >::value));
}

ASIO_TEST_SUITE
(
  "executor",
  ASIO_TEST_CASE(is_executor_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\invocable_archetype.cpp
//
// invocable_archetype.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/invocable_archetype.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "invocable_archetype",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\mapping.cpp
//
// mapping.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/mapping.hpp"

#include "asio/prefer.hpp"
#include "asio/query.hpp"
#include "asio/require.hpp"
#include "../unit_test.hpp"

namespace exec = asio::execution;

typedef exec::mapping_t s;
typedef exec::mapping_t::thread_t n1;
typedef exec::mapping_t::new_thread_t n2;
typedef exec::mapping_t::other_t n3;

struct ex_nq_nr
{
  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <>
struct is_executor<ex_nq_nr> : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct ex_cq_nr
{
  static constexpr ResultType query(ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_cq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_static_constexpr_member<
  ex_cq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef Result result_type; // Must return raw result type.

  static constexpr result_type value()
  {
    return Result();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_mq_nr
{
  ResultType query(ParamType) const noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_mq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_member<
  ex_mq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_fq_nr
{
  friend ResultType query(const ex_fq_nr&, ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_fq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_free<
  ex_fq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_mq_mr
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  CurrentType query(OtherType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, OtherType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, OtherType>();
  }

  ex_mq_mr<OtherType, CurrentType> require(
      OtherType) const noexcept
  {
    return ex_mq_mr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_mq_mr<CurrentType, CurrentType>
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, CurrentType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_mq_mr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_fq_fr
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend CurrentType query(const ex_fq_fr&, OtherType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, OtherType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> require(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, OtherType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> prefer(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_fq_fr<CurrentType, CurrentType>
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, CurrentType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, CurrentType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_fq_fr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_query()
{
  constexpr bool b1 =
    asio::can_query<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_query<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_query<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_query<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_query()
{
  exec::mapping_t result1 = asio::query(Executor(), Param());
  ASIO_CHECK(result1 == ExpectedResult());

  Executor ex1 = {};
  exec::mapping_t result2 = asio::query(ex1, Param());
  ASIO_CHECK(result2 == ExpectedResult());

  const Executor ex2 = {};
  exec::mapping_t result3 = asio::query(ex2, Param());
  ASIO_CHECK(result3 == ExpectedResult());
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_constexpr_query()
{
  constexpr Executor ex1 = {};
  constexpr exec::mapping_t result1 = asio::query(ex1, Param());
  ASIO_CHECK(result1 == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_require()
{
  constexpr bool b1 =
    asio::can_require<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_require<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_require<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_require<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_require()
{
  ASIO_CHECK(
      asio::query(
        asio::require(Executor(), Param()),
        Param()) == ExpectedResult());

  Executor ex1 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex1, Param()),
        Param()) == ExpectedResult());

  const Executor ex2 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex2, Param()),
        Param()) == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_prefer()
{
  constexpr bool b1 =
    asio::can_prefer<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_prefer<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_prefer<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_prefer<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_prefer()
{
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(Executor(), Param()),
          s())) == s(ExpectedResult()));

  Executor ex1 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex1, Param()),
          s())) == s(ExpectedResult()));

  const Executor ex2 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex2, Param()),
          s())) == s(ExpectedResult()));
}

void test_vars()
{
  ASIO_CHECK(s() == exec::mapping);
  ASIO_CHECK(s() != exec::mapping.thread);
  ASIO_CHECK(s() != exec::mapping.new_thread);
  ASIO_CHECK(s() != exec::mapping.other);
  ASIO_CHECK(n1() == exec::mapping.thread);
  ASIO_CHECK(n1() != exec::mapping.new_thread);
  ASIO_CHECK(n1() != exec::mapping.other);
  ASIO_CHECK(n2() == exec::mapping.new_thread);
  ASIO_CHECK(n2() != exec::mapping.thread);
  ASIO_CHECK(n2() != exec::mapping.other);
  ASIO_CHECK(n3() == exec::mapping.other);
  ASIO_CHECK(n3() != exec::mapping.thread);
  ASIO_CHECK(n3() != exec::mapping.new_thread);
}

ASIO_TEST_SUITE
(
  "mapping",

  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, s, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n2, false>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n3, false>)

  ASIO_TEST_CASE3(test_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n2, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n3, false>)

  ASIO_TEST_CASE3(test_require<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n2, true>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n3, true>)

  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n1, n1>)
  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n2, n1>)
  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n3, n1>)

  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n3, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n3, s, n3>, n3, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, s, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n3, n3>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n3, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n3, s, n3>, n3, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n3, n3>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n3, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n3, s, n3>, n3, true>)

  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n3, n3>, n3, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n3, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n3, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n3, s, n3>, n1, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n3, s, n3>, n2, n3>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n3, s, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n3>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n3>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n1>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n2>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n3>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n3>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n3>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n1>, n2, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n2>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n3>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n3>, n2, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n3>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n3>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n1>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n2>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n3>, s, n3>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n3, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n3>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n1>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n2>, n3, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n3, n3>, n3, true>)

  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n3, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n3>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n3>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n3, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n3>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n3>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n3>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n1>, n2, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n1>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n2>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n2>, n3, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n3>, n1, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n3>, n2, n3>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n3, n3>, n3, n3>)

  ASIO_TEST_CASE(test_vars)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\outstanding_work.cpp
//
// outstanding_work.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/outstanding_work.hpp"

#include "asio/prefer.hpp"
#include "asio/query.hpp"
#include "asio/require.hpp"
#include "../unit_test.hpp"

namespace exec = asio::execution;

typedef exec::outstanding_work_t s;
typedef exec::outstanding_work_t::untracked_t n1;
typedef exec::outstanding_work_t::tracked_t n2;

struct ex_nq_nr
{
  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <>
struct is_executor<ex_nq_nr> : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct ex_cq_nr
{
  static constexpr ResultType query(ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_cq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_static_constexpr_member<
  ex_cq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef Result result_type; // Must return raw result type.

  static constexpr result_type value()
  {
    return Result();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_mq_nr
{
  ResultType query(ParamType) const noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_mq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_member<
  ex_mq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_fq_nr
{
  friend ResultType query(const ex_fq_nr&, ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_fq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_free<
  ex_fq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_mq_mr
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  CurrentType query(OtherType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, OtherType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, OtherType>();
  }

  ex_mq_mr<OtherType, CurrentType> require(
      OtherType) const noexcept
  {
    return ex_mq_mr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_mq_mr<CurrentType, CurrentType>
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, CurrentType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_mq_mr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_fq_fr
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend CurrentType query(const ex_fq_fr&, OtherType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, OtherType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> require(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, OtherType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> prefer(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_fq_fr<CurrentType, CurrentType>
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, CurrentType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, CurrentType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_fq_fr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_query()
{
  constexpr bool b1 =
    asio::can_query<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_query<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_query<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_query<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_query()
{
  exec::outstanding_work_t result1 = asio::query(Executor(), Param());
  ASIO_CHECK(result1 == ExpectedResult());

  Executor ex1 = {};
  exec::outstanding_work_t result2 = asio::query(ex1, Param());
  ASIO_CHECK(result2 == ExpectedResult());

  const Executor ex2 = {};
  exec::outstanding_work_t result3 = asio::query(ex2, Param());
  ASIO_CHECK(result3 == ExpectedResult());
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_constexpr_query()
{
  constexpr Executor ex1 = {};
  constexpr exec::outstanding_work_t result1 = asio::query(ex1, Param());
  ASIO_CHECK(result1 == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_require()
{
  constexpr bool b1 =
    asio::can_require<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_require<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_require<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_require<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_require()
{
  ASIO_CHECK(
      asio::query(
        asio::require(Executor(), Param()),
        Param()) == ExpectedResult());

  Executor ex1 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex1, Param()),
        Param()) == ExpectedResult());

  const Executor ex2 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex2, Param()),
        Param()) == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_prefer()
{
  constexpr bool b1 =
    asio::can_prefer<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_prefer<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_prefer<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_prefer<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_prefer()
{
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(Executor(), Param()),
          s())) == s(ExpectedResult()));

  Executor ex1 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex1, Param()),
          s())) == s(ExpectedResult()));

  const Executor ex2 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex2, Param()),
          s())) == s(ExpectedResult()));
}

void test_vars()
{
  ASIO_CHECK(s() == exec::outstanding_work);
  ASIO_CHECK(s() != exec::outstanding_work.untracked);
  ASIO_CHECK(s() != exec::outstanding_work.tracked);
  ASIO_CHECK(n1() == exec::outstanding_work.untracked);
  ASIO_CHECK(n1() != exec::outstanding_work.tracked);
  ASIO_CHECK(n2() == exec::outstanding_work.tracked);
  ASIO_CHECK(n2() != exec::outstanding_work.untracked);
}

ASIO_TEST_SUITE
(
  "outstanding_work",

  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, s, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n2, false>)

  ASIO_TEST_CASE3(test_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n2, false>)

  ASIO_TEST_CASE3(test_require<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n2, true>)

  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n1, n1>)
  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n2, n1>)

  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE(test_vars)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\prefer_only.cpp
//
// prefer_only.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/prefer_only.hpp"

#include <functional>
#include "asio/execution/any_executor.hpp"
#include "../unit_test.hpp"

using namespace asio;
namespace bindns = std;

static int possibly_blocking_count = 0;
static int never_blocking_count = 0;

struct possibly_blocking_executor
{
  template <typename F>
  void execute(const F&) const
  {
    ++possibly_blocking_count;
  }

  friend bool operator==(const possibly_blocking_executor&,
      const possibly_blocking_executor&) noexcept
  {
    return true;
  }

  friend bool operator!=(const possibly_blocking_executor&,
      const possibly_blocking_executor&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<possibly_blocking_executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<possibly_blocking_executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

} // namespace traits
} // namespace asio

struct never_blocking_executor
{
  static constexpr execution::blocking_t::never_t
    query(execution::blocking_t) noexcept
  {
    return execution::blocking_t::never_t();
  }

  template <typename F>
  void execute(const F&) const
  {
    ++never_blocking_count;
  }

  friend bool operator==(const never_blocking_executor&,
      const never_blocking_executor&) noexcept
  {
    return true;
  }

  friend bool operator!=(const never_blocking_executor&,
      const never_blocking_executor&) noexcept
  {
    return false;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<never_blocking_executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<never_blocking_executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename Param>
struct query_static_constexpr_member<
  never_blocking_executor, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, execution::blocking_t>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef execution::blocking_t::never_t result_type;

  static constexpr result_type value()
  {
    return result_type();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

struct either_blocking_executor
{
  execution::blocking_t blocking_;

  explicit either_blocking_executor(execution::blocking_t b)
    : blocking_(b)
  {
  }

  execution::blocking_t query(execution::blocking_t) const noexcept
  {
    return blocking_;
  }

  either_blocking_executor require(execution::blocking_t::possibly_t) const
  {
    return either_blocking_executor(execution::blocking.possibly);
  }

  either_blocking_executor require(execution::blocking_t::never_t) const
  {
    return either_blocking_executor(execution::blocking.never);
  }

  template <typename F>
  void execute(const F&) const
  {
    if (blocking_ == execution::blocking.never)
      ++never_blocking_count;
    else
      ++possibly_blocking_count;
  }

  friend bool operator==(const either_blocking_executor& a,
      const either_blocking_executor& b) noexcept
  {
    return a.blocking_ == b.blocking_;
  }

  friend bool operator!=(const either_blocking_executor& a,
      const either_blocking_executor& b) noexcept
  {
    return a.blocking_ != b.blocking_;
  }
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<either_blocking_executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<either_blocking_executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename Param>
struct query_member<
  either_blocking_executor, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, execution::blocking_t>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef execution::blocking_t result_type;
};

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename Param>
struct require_member<
  either_blocking_executor, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, execution::blocking_t>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;

  typedef either_blocking_executor result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

void prefer_only_executor_query_test()
{
  typedef execution::any_executor<
      execution::blocking_t,
      execution::prefer_only<execution::blocking_t::possibly_t>,
      execution::prefer_only<execution::blocking_t::never_t>
    > executor_type;

  executor_type ex1 = possibly_blocking_executor();

  ASIO_CHECK(
      asio::query(ex1, execution::blocking)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex1, execution::blocking.possibly)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex1, execution::blocking.never)
        == execution::blocking.possibly);

  executor_type ex2 = asio::prefer(ex1, execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex2, execution::blocking)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex2, execution::blocking.possibly)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex2, execution::blocking.never)
        == execution::blocking.possibly);

  executor_type ex3 = asio::prefer(ex1, execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex3, execution::blocking)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex3, execution::blocking.possibly)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex3, execution::blocking.never)
        == execution::blocking.possibly);

  executor_type ex4 = never_blocking_executor();

  ASIO_CHECK(
      asio::query(ex4, execution::blocking)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex4, execution::blocking.possibly)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex4, execution::blocking.never)
        == execution::blocking.never);

  executor_type ex5 = asio::prefer(ex4, execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex5, execution::blocking)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex5, execution::blocking.possibly)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex5, execution::blocking.never)
        == execution::blocking.never);

  executor_type ex6 = asio::prefer(ex4, execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex6, execution::blocking)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex6, execution::blocking.possibly)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex6, execution::blocking.never)
        == execution::blocking.never);

  executor_type ex7 = either_blocking_executor(execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex7, execution::blocking)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex7, execution::blocking.possibly)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex7, execution::blocking.never)
        == execution::blocking.possibly);

  executor_type ex8 = asio::prefer(ex7, execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex8, execution::blocking)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex8, execution::blocking.possibly)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex8, execution::blocking.never)
        == execution::blocking.possibly);

  executor_type ex9 = asio::prefer(ex7, execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex9, execution::blocking)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex9, execution::blocking.possibly)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex9, execution::blocking.never)
        == execution::blocking.never);

  executor_type ex10 = either_blocking_executor(execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex10, execution::blocking)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex10, execution::blocking.possibly)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex10, execution::blocking.never)
        == execution::blocking.never);

  executor_type ex11 = asio::prefer(ex7, execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex11, execution::blocking)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex11, execution::blocking.possibly)
        == execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex11, execution::blocking.never)
        == execution::blocking.possibly);

  executor_type ex12 = asio::prefer(ex7, execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex12, execution::blocking)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex12, execution::blocking.possibly)
        == execution::blocking.never);

  ASIO_CHECK(
      asio::query(ex12, execution::blocking.never)
        == execution::blocking.never);
}

void do_nothing()
{
}

void prefer_only_executor_execute_test()
{
  typedef execution::any_executor<
      execution::blocking_t,
      execution::prefer_only<execution::blocking_t::possibly_t>,
      execution::prefer_only<execution::blocking_t::never_t>
    > executor_type;

  executor_type ex1 = possibly_blocking_executor();

  ex1.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 1);
  ASIO_CHECK(never_blocking_count == 0);

  executor_type ex2 = asio::prefer(ex1, execution::blocking.possibly);

  ex2.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 2);
  ASIO_CHECK(never_blocking_count == 0);

  executor_type ex3 = asio::prefer(ex1, execution::blocking.never);

  ex3.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 3);
  ASIO_CHECK(never_blocking_count == 0);

  executor_type ex4 = never_blocking_executor();

  ex4.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 3);
  ASIO_CHECK(never_blocking_count == 1);

  executor_type ex5 = asio::prefer(ex4, execution::blocking.possibly);

  ex5.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 3);
  ASIO_CHECK(never_blocking_count == 2);

  executor_type ex6 = asio::prefer(ex4, execution::blocking.never);

  ex6.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 3);
  ASIO_CHECK(never_blocking_count == 3);

  executor_type ex7 = either_blocking_executor(execution::blocking.possibly);

  ex7.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 4);
  ASIO_CHECK(never_blocking_count == 3);

  executor_type ex8 = asio::prefer(ex7, execution::blocking.possibly);

  ex8.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 5);
  ASIO_CHECK(never_blocking_count == 3);

  executor_type ex9 = asio::prefer(ex7, execution::blocking.never);

  ex9.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 5);
  ASIO_CHECK(never_blocking_count == 4);

  executor_type ex10 = either_blocking_executor(execution::blocking.never);

  ex10.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 5);
  ASIO_CHECK(never_blocking_count == 5);

  executor_type ex11 = asio::prefer(ex7, execution::blocking.possibly);

  ex11.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 6);
  ASIO_CHECK(never_blocking_count == 5);

  executor_type ex12 = asio::prefer(ex7, execution::blocking.never);

  ex12.execute(&do_nothing);
  ASIO_CHECK(possibly_blocking_count == 6);
  ASIO_CHECK(never_blocking_count == 6);
}

ASIO_TEST_SUITE
(
  "prefer_only",
  ASIO_TEST_CASE(prefer_only_executor_query_test)
  ASIO_TEST_CASE(prefer_only_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution\relationship.cpp
//
// relationship.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution/relationship.hpp"

#include "asio/prefer.hpp"
#include "asio/query.hpp"
#include "asio/require.hpp"
#include "../unit_test.hpp"

namespace exec = asio::execution;

typedef exec::relationship_t s;
typedef exec::relationship_t::fork_t n1;
typedef exec::relationship_t::continuation_t n2;

struct ex_nq_nr
{
  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_nq_nr&, const ex_nq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <>
struct is_executor<ex_nq_nr> : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

template <typename ResultType, typename ParamType, typename Result>
struct ex_cq_nr
{
  static constexpr ResultType query(ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_cq_nr&, const ex_cq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_cq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_static_constexpr_member<
  ex_cq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef Result result_type; // Must return raw result type.

  static constexpr result_type value()
  {
    return Result();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_mq_nr
{
  ResultType query(ParamType) const noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_nr&, const ex_mq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_mq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_member<
  ex_mq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename ResultType, typename ParamType, typename Result>
struct ex_fq_nr
{
  friend ResultType query(const ex_fq_nr&, ParamType) noexcept
  {
    return Result();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_nr&, const ex_fq_nr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename ResultType, typename ParamType, typename Result>
struct is_executor<ex_fq_nr<ResultType, ParamType, Result> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename ResultType, typename ParamType,
  typename Result, typename Param>
struct query_free<
  ex_fq_nr<ResultType, ParamType, Result>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, ParamType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ResultType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_mq_mr
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  CurrentType query(OtherType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, OtherType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, OtherType>();
  }

  ex_mq_mr<OtherType, CurrentType> require(
      OtherType) const noexcept
  {
    return ex_mq_mr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_mq_mr<CurrentType, CurrentType>
{
  CurrentType query(CurrentType) const noexcept
  {
    return CurrentType();
  }

  ex_mq_mr<CurrentType, CurrentType> require(
      CurrentType) const noexcept
  {
    return ex_mq_mr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_mq_mr&, const ex_mq_mr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_mq_mr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_member<
  ex_mq_mr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_mq_mr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_MEMBER_TRAIT)

} // namespace traits
} // namespace asio

template <typename CurrentType, typename OtherType>
struct ex_fq_fr
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend CurrentType query(const ex_fq_fr&, OtherType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, OtherType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> require(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, OtherType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, OtherType>();
  }

  friend ex_fq_fr<OtherType, CurrentType> prefer(
      const ex_fq_fr&, OtherType) noexcept
  {
    return ex_fq_fr<OtherType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

template <typename CurrentType>
struct ex_fq_fr<CurrentType, CurrentType>
{
  friend CurrentType query(const ex_fq_fr&, CurrentType) noexcept
  {
    return CurrentType();
  }

  friend ex_fq_fr<CurrentType, CurrentType> require(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  friend ex_fq_fr<CurrentType, CurrentType> prefer(
      const ex_fq_fr&, CurrentType) noexcept
  {
    return ex_fq_fr<CurrentType, CurrentType>();
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return true;
  }

  friend bool operator!=(const ex_fq_fr&, const ex_fq_fr&) noexcept
  {
    return false;
  }
};

#if !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace execution {

template <typename CurrentType, typename OtherType>
struct is_executor<ex_fq_fr<CurrentType, OtherType> >
  : asio::true_type
{
};

} // namespace execution
} // namespace asio

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTION_IS_EXECUTOR_TRAIT)

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct query_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
      || asio::is_convertible<Param, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef CurrentType result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct require_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_REQUIRE_FREE_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, CurrentType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<CurrentType, OtherType> result_type;
};

template <typename CurrentType, typename OtherType, typename Param>
struct prefer_free<
  ex_fq_fr<CurrentType, OtherType>, Param,
  typename asio::enable_if<
    asio::is_convertible<Param, OtherType>::value
      && !asio::is_same<CurrentType, OtherType>::value
  >::type>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;

  typedef ex_fq_fr<OtherType, CurrentType> result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_PREFER_FREE_TRAIT)

} // namespace traits
} // namespace asio

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_query()
{
  constexpr bool b1 =
    asio::can_query<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_query<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_query<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_query<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_query()
{
  exec::relationship_t result1 = asio::query(Executor(), Param());
  ASIO_CHECK(result1 == ExpectedResult());

  Executor ex1 = {};
  exec::relationship_t result2 = asio::query(ex1, Param());
  ASIO_CHECK(result2 == ExpectedResult());

  const Executor ex2 = {};
  exec::relationship_t result3 = asio::query(ex2, Param());
  ASIO_CHECK(result3 == ExpectedResult());
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_constexpr_query()
{
  constexpr Executor ex1 = {};
  constexpr exec::relationship_t result1 = asio::query(ex1, Param());
  ASIO_CHECK(result1 == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_require()
{
  constexpr bool b1 =
    asio::can_require<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_require<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_require<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_require<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_require()
{
  ASIO_CHECK(
      asio::query(
        asio::require(Executor(), Param()),
        Param()) == ExpectedResult());

  Executor ex1 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex1, Param()),
        Param()) == ExpectedResult());

  const Executor ex2 = {};
  ASIO_CHECK(
      asio::query(
        asio::require(ex2, Param()),
        Param()) == ExpectedResult());
}

template <typename Executor, typename Param, bool ExpectedResult>
void test_can_prefer()
{
  constexpr bool b1 =
    asio::can_prefer<Executor, Param>::value;
  ASIO_CHECK(b1 == ExpectedResult);

  constexpr bool b2 =
    asio::can_prefer<const Executor, Param>::value;
  ASIO_CHECK(b2 == ExpectedResult);

  constexpr bool b3 =
    asio::can_prefer<Executor&, Param>::value;
  ASIO_CHECK(b3 == ExpectedResult);

  constexpr bool b4 =
    asio::can_prefer<const Executor&, Param>::value;
  ASIO_CHECK(b4 == ExpectedResult);
}

template <typename Executor, typename Param, typename ExpectedResult>
void test_prefer()
{
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(Executor(), Param()),
          s())) == s(ExpectedResult()));

  Executor ex1 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex1, Param()),
          s())) == s(ExpectedResult()));

  const Executor ex2 = {};
  ASIO_CHECK(
      s(asio::query(
        asio::prefer(ex2, Param()),
          s())) == s(ExpectedResult()));
}

void test_vars()
{
  ASIO_CHECK(s() == exec::relationship);
  ASIO_CHECK(s() != exec::relationship.fork);
  ASIO_CHECK(s() != exec::relationship.continuation);
  ASIO_CHECK(n1() == exec::relationship.fork);
  ASIO_CHECK(n1() != exec::relationship.continuation);
  ASIO_CHECK(n2() == exec::relationship.continuation);
  ASIO_CHECK(n2() != exec::relationship.fork);
}

ASIO_TEST_SUITE
(
  "relationship",

  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, s, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_query<ex_nq_nr, n2, false>)

  ASIO_TEST_CASE3(test_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, s, n1>)
  ASIO_TEST_CASE3(test_constexpr_query<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_require<ex_nq_nr, n2, false>)

  ASIO_TEST_CASE3(test_require<ex_nq_nr, n1, n1>)

  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, s, false>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n1, true>)
  ASIO_TEST_CASE3(test_can_prefer<ex_nq_nr, n2, true>)

  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n1, n1>)
  ASIO_TEST_CASE3(test_prefer<ex_nq_nr, n2, n1>)

  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_constexpr_query<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_require<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_cq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_cq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_mq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_mq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_mq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_mq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_mq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, s, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_query<ex_fq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, s, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, s, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_query<ex_fq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, s, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n1, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<s, n2, n2>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n1, s, n1>, n2, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n1, false>)
  ASIO_TEST_CASE5(test_can_require<ex_fq_nr<n2, s, n2>, n2, false>)

  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, s, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n1, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<s, n2, n2>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n1, s, n1>, n2, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, s, false>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n1, true>)
  ASIO_TEST_CASE5(test_can_prefer<ex_fq_nr<n2, s, n2>, n2, true>)

  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, s, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n1, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<s, n2, n2>, n2, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n1, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n1, s, n1>, n2, n1>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n1, n2>)
  ASIO_TEST_CASE5(test_prefer<ex_fq_nr<n2, s, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_mq_mr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n1>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_mq_mr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, s, true>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_query<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, s, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, s, n2>)
  ASIO_TEST_CASE4(test_query<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n1>, n2, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n1, false>)
  ASIO_TEST_CASE4(test_can_require<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_require<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n1, n2>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n1>, n2, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, s, false>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n1, true>)
  ASIO_TEST_CASE4(test_can_prefer<ex_fq_fr<n2, n2>, n2, true>)

  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n1>, n2, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n1, n2>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n1, n1>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n1>, n2, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n1, n2>)
  ASIO_TEST_CASE4(test_prefer<ex_fq_fr<n2, n2>, n2, n2>)

  ASIO_TEST_CASE(test_vars)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\allocator.cpp
//
// experimental/coro/partial.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"

#include <vector>
#include "asio/io_context.hpp"
#include "../../unit_test.hpp"

namespace exp =  asio::experimental;

namespace coro {

template<typename Value = void>
struct tracked_allocator
{
  using value_type = Value;
  std::vector<std::pair<void*, std::size_t>>   & allocs, &deallocs;

  tracked_allocator(std::vector<std::pair<void*, std::size_t>>   & allocs,
                    std::vector<std::pair<void*, std::size_t>>   & deallocs) : allocs(allocs), deallocs(deallocs) {}


  template<typename T>
  tracked_allocator(const tracked_allocator<T> & a) : allocs(a.allocs), deallocs(a.deallocs) {}

  value_type* allocate(std::size_t n)
  {
    auto p = new char[n * sizeof(Value)];
    allocs.emplace_back(p, n);
    return reinterpret_cast<value_type*>(p);
  }

  void deallocate(void* p, std::size_t n)
  {
    deallocs.emplace_back(p, n);
    delete[] static_cast<char*>(p);
//    ASIO_CHECK(allocs.back() == deallocs.back());
  }

  bool operator==(const tracked_allocator & rhs) const
  {
    return &allocs == &rhs.allocs
           && &deallocs == &rhs.deallocs;
  }
};

exp::coro<void, void, asio::any_io_executor, tracked_allocator<void>>
        alloc_test_impl(asio::io_context & ctx, int, std::allocator_arg_t, tracked_allocator<void> ta, double)
{
  co_return ;
}

void alloc_test()
{
  std::vector<std::pair<void*, std::size_t>> allocs, deallocs;
  asio::io_context ctx;
  bool ran = false;

  {
    auto pp = alloc_test_impl(ctx, 42, std::allocator_arg, {allocs, deallocs}, 42.);

    ASIO_CHECK(allocs.size()  == 1u);
    ASIO_CHECK(deallocs.empty());

    pp.async_resume([&](auto e){ran = true; ASIO_CHECK(!e);});
    ctx.run();
    ASIO_CHECK(deallocs.size() == 0u);
  }
  ctx.restart();
  ctx.run();
  ASIO_CHECK(deallocs.size() == 1u);
  ASIO_CHECK(allocs == deallocs);

  ASIO_CHECK(ran);

  ran = false;

  auto p = asio::experimental::detail::post_coroutine(
          ctx,
          asio::bind_allocator(tracked_allocator{allocs, deallocs}, [&]{ran = true;})).handle;
  ASIO_CHECK(allocs.size()  == 2u);
  ASIO_CHECK(deallocs.size() == 1u);
  p.resume();
  ASIO_CHECK(allocs.size()  == 3u);
  ASIO_CHECK(deallocs.size() == 2u);
  ctx.restart();
  ctx.run();

  ASIO_CHECK(allocs == deallocs);
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/allocate",
  ASIO_TEST_CASE(::coro::alloc_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\cancel.cpp
//
// experimental/coro/cancel.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"
#include <iostream>
#include "asio/bind_cancellation_slot.hpp"
#include "asio/io_context.hpp"
#include "asio/steady_timer.hpp"
#include "asio/this_coro.hpp"
#include "../../unit_test.hpp"

using namespace asio::experimental;
namespace this_coro = asio::this_coro;

namespace coro {


auto coro_simple_cancel_impl(asio::io_context& ) noexcept
  -> asio::experimental::coro<void() noexcept, asio::error_code>
{
    ASIO_CHECK(
        !(co_await this_coro::cancellation_state).cancelled());

    asio::steady_timer timer{
        co_await this_coro::executor,
        std::chrono::seconds(1)};

    ASIO_CHECK(
        !(co_await this_coro::cancellation_state).cancelled());

    auto ec = co_await timer;

    ASIO_CHECK(
        (co_await this_coro::cancellation_state).cancelled());

    co_return ec;
}

void coro_simple_cancel()
{
  asio::io_context ctx;
  asio::cancellation_signal sig;

  auto k = coro_simple_cancel_impl(ctx);

  asio::error_code res_ec;
  k.async_resume(
      asio::bind_cancellation_slot(sig.slot(),
        [&](asio::error_code ec) {res_ec = ec;}));
  asio::post(ctx, [&]{sig.emit(asio::cancellation_type::all);});

  ASIO_CHECK(!res_ec);

  ctx.run();

  ASIO_CHECK(res_ec == asio::error::operation_aborted);
}

auto coro_throw_cancel_impl(asio::io_context& )
  -> asio::experimental::coro<void() , void>
{
    asio::steady_timer timer{
        co_await this_coro::executor,
        std::chrono::seconds(1)};
    co_await timer;
}

void coro_throw_cancel()
{
  asio::io_context ctx;
  asio::cancellation_signal sig;

  auto k = coro_throw_cancel_impl(ctx);

  std::exception_ptr res_ex;
  k.async_resume(
      asio::bind_cancellation_slot(sig.slot(),
        [&](std::exception_ptr ex) {res_ex = ex;}));
  asio::post(ctx, [&]{sig.emit(asio::cancellation_type::all);});

  ASIO_CHECK(!res_ex);

  ctx.run();

  ASIO_CHECK(res_ex);
  try
  {
    if (res_ex)
      std::rethrow_exception(res_ex);
  }
  catch (asio::system_error& se)
  {
    ASIO_CHECK(se.code() == asio::error::operation_aborted);
  }
}

auto coro_simple_cancel_nested_k(asio::io_context&, int& cnt) noexcept
  -> asio::experimental::coro<
      void() noexcept,
      asio::error_code>
{
  asio::steady_timer timer{
          co_await this_coro::executor,
          std::chrono::milliseconds(100)};

  ASIO_CHECK(!(co_await this_coro::cancellation_state).cancelled());
  auto ec = co_await timer;
  cnt++;
  ASIO_CHECK((co_await this_coro::cancellation_state).cancelled());

  co_return ec;
}

auto coro_simple_cancel_nested_kouter(
    asio::io_context& ctx, int& cnt) noexcept
  -> asio::experimental::coro<
      asio::error_code() noexcept,
      asio::error_code>
{
    ASIO_CHECK(cnt == 0);
    co_yield co_await coro_simple_cancel_nested_k(ctx, cnt);
    ASIO_CHECK(cnt == 1);
    auto ec = co_await coro_simple_cancel_nested_k(ctx, cnt);
    ASIO_CHECK(cnt == 2);
    co_return ec;
}

void coro_simple_cancel_nested()
{
  asio::io_context ctx;
  asio::cancellation_signal sig;

  int cnt = 0;
  auto kouter = coro_simple_cancel_nested_kouter(ctx, cnt);

  asio::error_code res_ec;
  kouter.async_resume(
      asio::bind_cancellation_slot(sig.slot(),
        [&](asio::error_code ec) {res_ec = ec;}));
  asio::post(ctx, [&]{sig.emit(asio::cancellation_type::all);});
  ASIO_CHECK(!res_ec);
  ctx.run();
  ASIO_CHECK(res_ec == asio::error::operation_aborted);

  ctx.restart();
  res_ec = {};
  kouter.async_resume(
      asio::bind_cancellation_slot(sig.slot(),
        [&](asio::error_code ec) {res_ec = ec;}));
  asio::post(ctx, [&]{sig.emit(asio::cancellation_type::all);});
  ASIO_CHECK(!res_ec);
  ctx.run();
  ASIO_CHECK(res_ec == asio::error::operation_aborted);
  ASIO_CHECK(cnt == 2);
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/cancel",
  ASIO_TEST_CASE(::coro::coro_simple_cancel)
  ASIO_TEST_CASE(::coro::coro_throw_cancel)
  ASIO_TEST_CASE(::coro::coro_simple_cancel_nested)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\co_spawn.cpp
//
// experimental/coro/co_spawn.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/co_spawn.hpp"

#include <iostream>
#include "asio/io_context.hpp"
#include "asio/steady_timer.hpp"
#include "asio/this_coro.hpp"
#include "../../unit_test.hpp"

using namespace asio::experimental;
namespace this_coro = asio::this_coro;

namespace coro {

auto coro_simple_co_spawn_impl(asio::io_context& , bool &done) noexcept
  -> asio::experimental::coro<void() noexcept, int>
{
  asio::steady_timer timer(
      co_await this_coro::executor,
      std::chrono::milliseconds(10));

  done = true;

  co_return 42;
}

void coro_co_spawn()
{
  asio::io_context ctx;

  bool done1 = false;
  bool done2 = false;
  int res = 0;

  co_spawn(coro_simple_co_spawn_impl(ctx, done1),
      [&](int r){done2= true;  res = r;});

  ctx.run();

  ASIO_CHECK(done1);
  ASIO_CHECK(done2);
  ASIO_CHECK(res == 42);
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/co_spawn",
  ASIO_TEST_CASE(::coro::coro_co_spawn)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\exception.cpp
//
// experimental/coro/exception.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"

#include "asio/co_spawn.hpp"
#include "asio/detached.hpp"
#include "asio/io_context.hpp"
#include "asio/use_awaitable.hpp"
#include "asio/awaitable.hpp"
#include "../../unit_test.hpp"

using namespace asio::experimental;

namespace coro {

template <typename Func>
struct on_scope_exit
{
	Func func;

  static_assert(noexcept(func()));

  on_scope_exit(const Func &f)
    : func(static_cast< Func && >(f))
	{
	}

	on_scope_exit(Func &&f)
    : func(f)
	{
	}

  on_scope_exit(const on_scope_exit &) = delete;

	~on_scope_exit()
  {
    func();
  }
};

asio::experimental::coro<int> throwing_generator(
  asio::any_io_executor, int &last, bool &destroyed)
{
  on_scope_exit x = [&]() noexcept { destroyed = true; };
  (void)x;

  int i = 0;
  while (i < 3)
    co_yield last = ++i;

  throw std::runtime_error("throwing-generator");
}

asio::awaitable<void> throwing_generator_test()
{
  int val = 0;
  bool destr = false;
  {
    auto gi = throwing_generator(
        co_await asio::this_coro::executor,
        val, destr);
    bool caught = false;
    try
    {
      for (int i = 0; i < 10; i++)
      {
        ASIO_CHECK(val == i);
        const auto next = co_await gi.async_resume(asio::use_awaitable);
        ASIO_CHECK(next);
        ASIO_CHECK(val == *next);
        ASIO_CHECK(val == i + 1);
      }
    }
    catch (std::runtime_error &err)
    {
      caught = true;
      using std::operator ""sv;
      ASIO_CHECK(err.what() == "throwing-generator"sv);
    }
    ASIO_CHECK(val == 3);
    ASIO_CHECK(caught);
  }
  ASIO_CHECK(destr);
};

void run_throwing_generator_test()
{
  asio::io_context ctx;
  asio::co_spawn(ctx, throwing_generator_test(), asio::detached);
  ctx.run();
}

asio::experimental::coro<int(int)> throwing_stacked(
    asio::any_io_executor exec, int &val,
    bool &destroyed_inner, bool &destroyed)
{
  ASIO_CHECK((co_await asio::this_coro::throw_if_cancelled()));

  on_scope_exit x = [&]() noexcept { destroyed = true; };
  (void)x;

  auto gen = throwing_generator(exec, val, destroyed_inner);
  while (auto next = co_await gen) // 1, 2, 4, 8, ...
    ASIO_CHECK(42 ==(co_yield *next)); // offset is delayed by one cycle
}

asio::awaitable<void> throwing_generator_stacked_test()
{
  int val = 0;
  bool destr = false, destr_inner = false;
  {
    auto gi = throwing_stacked(
        co_await asio::this_coro::executor,
        val, destr, destr_inner);
    bool caught = false;
    try
    {
      for (int i = 0; i < 10; i++)
      {
        ASIO_CHECK(val == i);
        const auto next =
          co_await gi.async_resume(42, asio::use_awaitable);
        ASIO_CHECK(next);
        ASIO_CHECK(val == *next);
        ASIO_CHECK(val == i + 1);
      }
    }
    catch (std::runtime_error &err)
    {
      caught = true;
      using std::operator ""sv;
      ASIO_CHECK(err.what() == "throwing-generator"sv);
    }
    ASIO_CHECK(val == 3);
    ASIO_CHECK(caught);
  }
  ASIO_CHECK(destr);
  ASIO_CHECK(destr_inner);
};

void run_throwing_generator_stacked_test()
{
  asio::io_context ctx;
  asio::co_spawn(ctx,
      throwing_generator_stacked_test,
      asio::detached);
  ctx.run();
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/exception",
  ASIO_TEST_CASE(::coro::run_throwing_generator_stacked_test)
  ASIO_TEST_CASE(::coro::run_throwing_generator_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\executor.cpp
//
// experimental/coro/executor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"

#include "asio/thread_pool.hpp"
#include "asio/io_context.hpp"
#include "../../unit_test.hpp"

using namespace asio::experimental;

namespace coro {

#define ASIO_CHECKPOINT() \
  ASIO_TEST_IOSTREAM << __FILE__ << "(" << __LINE__ << "): " \
  << asio::detail::test_name() << ": " \
  << "Checkpoint" << std::endl;

template <typename T>
void different_execs()
{
  asio::thread_pool th_ctx{1u};
  asio::io_context ctx;

  auto o = std::make_optional(
      asio::prefer(th_ctx.get_executor(),
        asio::execution::outstanding_work.tracked));

  static bool ran_inner = false, ran_outer = false;

  struct c_inner_t
  {
    auto operator()(asio::any_io_executor e) -> asio::experimental::coro<T>
    {
      auto p = e.target<asio::thread_pool::executor_type>();
      ASIO_CHECKPOINT();
      ASIO_CHECK(p);
      ASIO_CHECK(p->running_in_this_thread());
      ran_inner = true;
      co_return;
    };

  };

  c_inner_t c_inner;

  struct c_outer_t
  {

    auto operator()(asio::any_io_executor e, int,
        asio::experimental::coro<T> tp)
      -> asio::experimental::coro<void>
    {
      auto p = e.target<asio::io_context::executor_type>();

      ASIO_CHECK(p);
      ASIO_CHECK(p->running_in_this_thread());
      ASIO_CHECKPOINT();

      co_await tp;

      ASIO_CHECKPOINT();
      ASIO_CHECK(p->running_in_this_thread());

      ran_outer = true;
    };
  };

  c_outer_t c_outer;

  bool ran = false;
  std::exception_ptr ex;

  auto c = c_outer(ctx.get_executor(), 10, c_inner(th_ctx.get_executor()));
  c.async_resume(
      [&](std::exception_ptr e)
      {
        ASIO_CHECK(!e);
        ASIO_CHECKPOINT();
        ran = true;
      });

  ASIO_CHECK(!ran);
  ctx.run();
  o.reset();
  ASIO_CHECK(ran);
  ASIO_CHECK(ran_inner);
  ASIO_CHECK(ran_outer);
  ASIO_CHECK(!ex);

  th_ctx.stop();
  th_ctx.join();
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/partial",
  ASIO_TEST_CASE(::coro::different_execs<void>)
  ASIO_TEST_CASE(::coro::different_execs<int()>)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\partial.cpp
//
// experimental/coro/partial.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"

#include "asio/io_context.hpp"
#include "../../unit_test.hpp"

using namespace asio::experimental;

namespace coro {

void partial()
{
  asio::io_context ctx;
  bool ran = false;
  auto p = detail::post_coroutine(ctx, [&]{ran = true;}).handle;
  ASIO_CHECK(!ran);
  p.resume();
  ASIO_CHECK(!ran);
  ctx.run();
  ASIO_CHECK(ran);
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/partial",
  ASIO_TEST_CASE(::coro::partial)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\simple_test.cpp
//
// experimental/coro/simple_test.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"

#include "asio/co_spawn.hpp"
#include "asio/detached.hpp"
#include "asio/io_context.hpp"
#include "asio/use_awaitable.hpp"
#include <iostream>
#include <vector>
#include "../../unit_test.hpp"

using namespace asio::experimental;

namespace asio {
namespace experimental {

template struct coro<void(), void, any_io_executor>;
template struct coro<int(), void, any_io_executor>;
template struct coro<void(), int, any_io_executor>;
template struct coro<int(int), void, any_io_executor>;
template struct coro<int(), int, any_io_executor>;
template struct coro<int(int), int, any_io_executor>;

template struct coro<void() noexcept, void, any_io_executor>;
template struct coro<int() noexcept, void, any_io_executor>;
template struct coro<void() noexcept, int, any_io_executor>;
template struct coro<int(int) noexcept, void, any_io_executor>;
template struct coro<int() noexcept, int, any_io_executor>;
template struct coro<int(int) noexcept, int, any_io_executor>;

} // namespace experimental
} // namespace asio

namespace coro {

template <typename Func>
struct on_scope_exit
{
	Func func;

  static_assert(noexcept(func()));

  on_scope_exit(const Func &f)
    : func(static_cast< Func && >(f))
	{
	}

	on_scope_exit(Func &&f)
    : func(f)
	{
	}

  on_scope_exit(const on_scope_exit &) = delete;

	~on_scope_exit()
  {
    func();
  }
};

asio::experimental::coro<int> generator_impl(
    asio::any_io_executor, int& last, bool& destroyed)
{
  on_scope_exit x = [&]() noexcept { destroyed = true; };
  (void)x;

  int i = 0;
  while (true)
    co_yield last = ++i;
}

asio::awaitable<void> generator_test()
{
  int val = 0;
  bool destr = false;
  {
    auto gi = generator_impl(
        co_await asio::this_coro::executor, val, destr);

    for (int i = 0; i < 10; i++)
    {
      ASIO_CHECK(val == i);
      const auto next = co_await gi.async_resume(asio::use_awaitable);
      ASIO_CHECK(next);
      ASIO_CHECK(val == *next);
      ASIO_CHECK(val == i + 1);
    }

    ASIO_CHECK(!destr);
  }
  ASIO_CHECK(destr);
};

void run_generator_test()
{
  asio::io_context ctx;
  asio::co_spawn(ctx, generator_test, asio::detached);
  ctx.run();
}

asio::experimental::coro<void, int> task_test(asio::io_context&)
{
  co_return 42;
}

asio::experimental::coro<void, int> task_throw(asio::io_context&)
{
  throw std::logic_error(__func__);
  co_return 42;
}

void run_task_test()
{
  asio::io_context ctx;

  bool tt1 = false;
  bool tt2 = false;
  bool tt3 = false;
  bool tt4 = false;
  auto tt = task_test(ctx);
  tt.async_resume(
      [&](std::exception_ptr pt, int i)
      {
        tt1 = true;
        ASIO_CHECK(!pt);
        ASIO_CHECK(i == 42);
        tt.async_resume(
            [&](std::exception_ptr pt, int)
            {
              tt2 = true;
              ASIO_CHECK(pt);
            });
      });

  auto tt_2 = task_throw(ctx);

  tt_2.async_resume(
      [&](std::exception_ptr pt, int)
      {
        tt3 = true;
        ASIO_CHECK(pt);
        tt.async_resume(
            [&](std::exception_ptr pt, int)
            {
              tt4 = true;
              ASIO_CHECK(pt);
            });
      });

  ctx.run();

  ASIO_CHECK(tt1);
  ASIO_CHECK(tt2);
  ASIO_CHECK(tt3);
  ASIO_CHECK(tt4);
}

asio::experimental::coro<char> completion_generator_test_impl(
    asio::any_io_executor, int limit)
{
  for (int i = 0; i < limit; i++)
    co_yield i;
}

asio::awaitable<void> completion_generator_test()
{
  std::vector<int> res;
  auto g = completion_generator_test_impl(
      co_await asio::this_coro::executor, 10);

  ASIO_CHECK(g.is_open());
  while (auto val = co_await g.async_resume(asio::use_awaitable))
    res.push_back(*val);

  ASIO_CHECK(!g.is_open());
  ASIO_CHECK((res == std::vector{0,1,2,3,4,5,6,7,8,9}));
};


void run_completion_generator_test()
{
  asio::io_context ctx;
  asio::co_spawn(ctx, completion_generator_test, asio::detached);
  ctx.run();
}

asio::experimental::coro<int(int)>
symmetrical_test_impl(asio::any_io_executor)
{
  int i = 0;
  while (true)
    i = (co_yield i) + i;
}

asio::awaitable<void> symmetrical_test()
{
  auto g = symmetrical_test_impl(co_await asio::this_coro::executor);

  ASIO_CHECK(g.is_open());

  ASIO_CHECK(0  == (co_await g.async_resume(0,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(1  == (co_await g.async_resume(1,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(3  == (co_await g.async_resume(2,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(6  == (co_await g.async_resume(3,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(10  == (co_await g.async_resume(4,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(15 == (co_await g.async_resume(5,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(21 == (co_await g.async_resume(6,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(28 == (co_await g.async_resume(7,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(36 == (co_await g.async_resume(8,
          asio::use_awaitable)).value_or(-1));

  ASIO_CHECK(45 == (co_await g.async_resume(9,
          asio::use_awaitable)).value_or(-1));
};

void run_symmetrical_test()
{
  asio::io_context ctx;
  asio::co_spawn(ctx, symmetrical_test, asio::detached);
  ctx.run();
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/simple_test",
  ASIO_TEST_CASE(::coro::run_generator_test)
  ASIO_TEST_CASE(::coro::run_task_test)
  ASIO_TEST_CASE(::coro::run_symmetrical_test)
  ASIO_TEST_CASE(::coro::run_completion_generator_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\stack_test.cpp
//
// experimental/coro/stack_test.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/coro.hpp"

#include "asio/detached.hpp"
#include "asio/io_context.hpp"
#include <iostream>
#include "../../unit_test.hpp"

using namespace asio::experimental;

namespace coro {

asio::experimental::coro<int()>
  stack_generator(asio::any_io_executor, int i = 1)
{
  for (;;)
  {
    co_yield i;
    i *= 2;
  }
}

asio::experimental::coro<int(int)>
stack_accumulate(asio::any_io_executor exec)
{
  auto gen  = stack_generator(exec);
  int offset = 0;
  while (auto next = co_await gen) // 1, 2, 4, 8, ...
    offset  = co_yield *next + offset; // offset is delayed by one cycle
}

asio::experimental::coro<int>
main_stack_coro(asio::io_context&, bool & done)
{
  auto g = stack_accumulate(co_await asio::this_coro::executor);

  ASIO_CHECK(g.is_open());
  ASIO_CHECK(1    == (co_await g(1000)).value_or(-1));
  ASIO_CHECK(2002 == (co_await g(2000)).value_or(-1));
  ASIO_CHECK(3004 == (co_await g(3000)).value_or(-1));
  ASIO_CHECK(4008 == (co_await g(4000)).value_or(-1));
  ASIO_CHECK(5016 == (co_await g(5000)).value_or(-1));
  ASIO_CHECK(6032 == (co_await g(6000)).value_or(-1));
  ASIO_CHECK(7064 == (co_await g(7000)).value_or(-1));
  ASIO_CHECK(8128 == (co_await g(8000)).value_or(-1));
  ASIO_CHECK(9256 == (co_await g(9000)).value_or(-1));
  ASIO_CHECK(511 == (co_await g(-1)).value_or(-1));
  done = true;
}

void stack_test()
{
  bool done = false;
  asio::io_context ctx;
  auto k = main_stack_coro(ctx, done);
  k.async_resume(asio::detached);
  ctx.run();
  ASIO_CHECK(done);
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/stack_test",
  ASIO_TEST_CASE(::coro::stack_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\coro\use_coro.cpp
//
// experimental/coro/use_coro.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/use_coro.hpp"

#include "asio/steady_timer.hpp"
#include <iostream>
#include "../../unit_test.hpp"

using namespace asio::experimental;

namespace coro {

asio::experimental::coro<void(), int>
awaiter(asio::any_io_executor exec)
{
  asio::steady_timer timer{exec};
  co_await timer.async_wait(use_coro);
  co_return 42;
}

asio::experimental::coro<void() noexcept, int>
awaiter_noexcept(asio::any_io_executor exec)
{
  asio::steady_timer timer{exec};
  auto ec = co_await timer.async_wait(asio::deferred);
  ASIO_CHECK(ec == asio::error_code{});
  co_return 42;
}

void stack_test2()
{
  bool done = false;
  asio::io_context ctx;

  auto k = awaiter(ctx.get_executor());
  auto k2 = awaiter_noexcept(ctx.get_executor());

  k.async_resume(
      [&](std::exception_ptr ex, int res)
      {
        ASIO_CHECK(!ex);
        ASIO_CHECK(res == 42);
        done = true;
      });

  k2.async_resume([&](int res)
       {
         ASIO_CHECK(res == 42);
         done = true;
       });

  ctx.run();
  ASIO_CHECK(done);
}

} // namespace coro

ASIO_TEST_SUITE
(
  "coro/use_coro",
  ASIO_TEST_CASE(::coro::stack_test2)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\awaitable_operators.cpp
//
// experimental/awaitable_operators.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/experimental/awaitable_operators.hpp"

#include "asio/co_spawn.hpp"
#include "asio/detached.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "../unit_test.hpp"

using asio::awaitable;
using namespace asio::experimental::awaitable_operators;

struct move_only
{
  move_only(int i) : value(i) {}
  move_only(const move_only&) = delete;
  move_only(move_only&&) {}
  move_only& operator=(const move_only&) = delete;
  move_only& operator=(move_only&&) { return *this; }
  int value;
};

awaitable<void> void_ok()
{
  co_return;
}

awaitable<void> void_ex()
{
  throw std::runtime_error("exception");
  co_return;
}

awaitable<void> void_post_loop()
{
  for (;;)
    co_await asio::post(asio::use_awaitable);
}

awaitable<int> int_0()
{
  co_return 0;
}

awaitable<int> int_1()
{
  co_return 1;
}

awaitable<int> int_2()
{
  co_return 2;
}

awaitable<int> int_ex()
{
  throw std::runtime_error("exception");
  co_return -1;
}

awaitable<move_only> move_only_0()
{
  co_return move_only(0);
}

awaitable<move_only> move_only_1()
{
  co_return move_only(1);
}

awaitable<move_only> move_only_2()
{
  co_return move_only(2);
}

awaitable<move_only> move_only_ex()
{
  throw std::runtime_error("exception");
  co_return move_only(-1);
}

awaitable<void> do_test_and_awaitable_operator()
{
  int i;
  std::tuple<int, int> ii;
  std::tuple<int, int, int> iii;

  co_await (void_ok() && void_ok());
  co_await (void_ok() && void_ok() && void_ok());
  try { co_await (void_ex() && void_ok()); } catch (...) {}
  try { co_await (void_ex() && void_ok() && void_ok()); } catch (...) {}
  try { co_await (void_ex() && void_post_loop()); } catch (...) {}
  try { co_await (void_ex() && void_ok() && void_post_loop()); } catch (...) {}

  i = co_await (void_ok() && int_0());
  ASIO_CHECK(i == 0);

  i = co_await (void_ok() && int_1());
  ASIO_CHECK(i == 1);

  i = co_await (int_0() && void_ok());
  ASIO_CHECK(i == 0);

  ii = co_await (int_0() && int_1());
  ASIO_CHECK(std::get<0>(ii) == 0);
  ASIO_CHECK(std::get<1>(ii) == 1);

  i = co_await (void_ok() && void_ok() && int_0());
  ASIO_CHECK(i == 0);

  i = co_await (void_ok() && int_0() && void_ok());
  ASIO_CHECK(i == 0);

  ii = co_await (void_ok() && int_0() && int_1());
  ASIO_CHECK(std::get<0>(ii) == 0);
  ASIO_CHECK(std::get<1>(ii) == 1);

  ii = co_await (int_0() && void_ok() && int_1());
  ASIO_CHECK(std::get<0>(ii) == 0);
  ASIO_CHECK(std::get<1>(ii) == 1);

  iii = co_await (int_0() && int_1() && int_2());
  ASIO_CHECK(std::get<0>(iii) == 0);
  ASIO_CHECK(std::get<1>(iii) == 1);
  ASIO_CHECK(std::get<2>(iii) == 2);
}

void test_and_awaitable_operator()
{
  asio::io_context ctx;
  co_spawn(ctx, do_test_and_awaitable_operator(), asio::detached);
  ctx.run();
}

awaitable<void> do_test_or_awaitable_operator()
{
  std::variant<int, int> ii;
  std::variant<int, std::monostate> iv;
  std::variant<std::monostate, int> vi;
  std::variant<std::monostate, std::monostate> vv;
  std::variant<int, int, int> iii;
  std::variant<int, int, std::monostate> iiv;
  std::variant<int, std::monostate, int> ivi;
  std::variant<int, std::monostate, std::monostate> ivv;
  std::variant<std::monostate, int, int> vii;
  std::variant<std::monostate, int, std::monostate> viv;
  std::variant<std::monostate, std::monostate, int> vvi;
  std::variant<std::monostate, std::monostate, std::monostate> vvv;

  vv = co_await (void_ok() || void_ok());
  ASIO_CHECK(vv.index() == 0);

  vv = co_await (void_ex() || void_ok());
  ASIO_CHECK(vv.index() == 1);

  vi = co_await (void_ok() || int_0());
  ASIO_CHECK(vi.index() == 0);

  vi = co_await (void_ex() || int_0());
  ASIO_CHECK(vi.index() == 1);

  iv = co_await (int_0() || void_ex());
  ASIO_CHECK(iv.index() == 0);
  ASIO_CHECK(std::get<0>(iv) == 0);

  ii = co_await (int_0() || int_1());
  ASIO_CHECK(ii.index() == 0);
  ASIO_CHECK(std::get<0>(ii) == 0);

  ii = co_await (int_ex() || int_1());
  ASIO_CHECK(ii.index() == 1);
  ASIO_CHECK(std::get<1>(ii) == 1);

  vvv = co_await (void_ok() || void_ok() || void_ok());
  ASIO_CHECK(vvv.index() == 0);

  vvv = co_await (void_ex() || void_ok() || void_ok());
  ASIO_CHECK(vvv.index() == 1);

  vvv = co_await (void_ex() || void_ex() || void_ok());
  ASIO_CHECK(vvv.index() == 2);

  vvi = co_await (void_ok() || void_ok() || int_0());
  ASIO_CHECK(vvi.index() == 0);

  viv = co_await (void_ok() || int_0() || void_ok());
  ASIO_CHECK(viv.index() == 0);

  viv = co_await (void_ex() || int_0() || void_ok());
  ASIO_CHECK(viv.index() == 1);
  ASIO_CHECK(std::get<1>(viv) == 0);

  vii = co_await (void_ex() || int_0() || int_1());
  ASIO_CHECK(vii.index() == 1);
  ASIO_CHECK(std::get<1>(vii) == 0);

  ivv = co_await (int_0() || void_ok() || void_ok());
  ASIO_CHECK(ivv.index() == 0);
  ASIO_CHECK(std::get<0>(ivv) == 0);

  ivv = co_await (int_ex() || void_ok() || void_ok());
  ASIO_CHECK(ivv.index() == 1);

  ivi = co_await (int_0() || void_ok() || int_1());
  ASIO_CHECK(ivi.index() == 0);
  ASIO_CHECK(std::get<0>(ivi) == 0);

  ivi = co_await (int_ex() || void_ok() || int_1());
  ASIO_CHECK(ivi.index() == 1);

  iiv = co_await (int_0() || int_1() || void_ok());
  ASIO_CHECK(iiv.index() == 0);
  ASIO_CHECK(std::get<0>(iiv) == 0);

  iiv = co_await (int_ex() || int_1() || void_ok());
  ASIO_CHECK(iiv.index() == 1);
  ASIO_CHECK(std::get<0>(iiv) == 1);

  iiv = co_await (int_ex() || int_ex() || void_ok());
  ASIO_CHECK(iiv.index() == 2);

  iii = co_await (int_0() || int_1() || int_2());
  ASIO_CHECK(iii.index() == 0);
  ASIO_CHECK(std::get<0>(iii) == 0);

  iii = co_await (int_ex() || int_1() || int_2());
  ASIO_CHECK(iii.index() == 1);
  ASIO_CHECK(std::get<1>(iii) == 1);

  iii = co_await (int_ex() || int_ex() || int_2());
  ASIO_CHECK(iii.index() == 2);
  ASIO_CHECK(std::get<2>(iii) == 2);

  std::variant<move_only, int> mi = co_await (move_only_0() || int_1());
  ASIO_CHECK(mi.index() == 0);
  ASIO_CHECK(std::get<0>(mi).value == 0);

  mi = co_await (move_only_ex() || int_1());
  ASIO_CHECK(mi.index() == 1);
  ASIO_CHECK(std::get<1>(mi) == 1);

  std::variant<move_only, move_only> mm =
    co_await (move_only_0() || move_only_1());
  ASIO_CHECK(mm.index() == 0);
  ASIO_CHECK(std::get<0>(mm).value == 0);

  mm = co_await (move_only_ex() || move_only_1());
  ASIO_CHECK(mm.index() == 1);
  ASIO_CHECK(std::get<1>(mm).value == 1);

  std::variant<move_only, move_only, move_only> mmm =
    co_await (move_only_0() || move_only_1() || move_only_2());
  ASIO_CHECK(mmm.index() == 0);
  ASIO_CHECK(std::get<0>(mmm).value == 0);

  mmm = co_await (move_only_ex() || move_only_1() || move_only_2());
  ASIO_CHECK(mmm.index() == 1);
  ASIO_CHECK(std::get<1>(mmm).value == 1);

  mmm = co_await (move_only_ex() || move_only_ex() || move_only_2());
  ASIO_CHECK(mmm.index() == 2);
  ASIO_CHECK(std::get<2>(mmm).value == 2);
}

void test_or_awaitable_operator()
{
  asio::io_context ctx;
  co_spawn(ctx, do_test_or_awaitable_operator(), asio::detached);
  ctx.run();
}

ASIO_TEST_SUITE
(
  "experimental/awaitable_operators",
  ASIO_TEST_CASE(test_and_awaitable_operator)
  ASIO_TEST_CASE(test_or_awaitable_operator)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\basic_channel.cpp
//
// experimental/basic_channel.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/basic_channel.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "experimental/basic_channel",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\basic_concurrent_channel.cpp
//
// experimental/basic_concurrent_channel.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/basic_concurrent_channel.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "experimental/basic_concurrent_channel",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\channel_traits.cpp
//
// experimental/channel_traits.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/channel_traits.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "experimental/channel_traits",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\channel.cpp
//
// experimental/channel.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/channel.hpp"

#include <utility>
#include "asio/any_completion_handler.hpp"
#include "asio/bind_executor.hpp"
#include "asio/bind_immediate_executor.hpp"
#include "asio/error.hpp"
#include "asio/io_context.hpp"
#include "asio/system_executor.hpp"
#include "../unit_test.hpp"

using namespace asio;
using namespace asio::experimental;

void unbuffered_channel_test()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  ASIO_CHECK(ch1.is_open());
  ASIO_CHECK(!ch1.ready());

  bool b1 = ch1.try_send(asio::error::eof, "hello");

  ASIO_CHECK(!b1);

  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
  bool b2 = ch1.try_send(asio::error::eof, std::move(s1));

  ASIO_CHECK(!b2);
  ASIO_CHECK(!s1.empty());

  asio::error_code ec1;
  std::string s2;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s2 = std::move(s);
      });

  bool b3 = ch1.try_send(asio::error::eof, std::move(s1));

  ASIO_CHECK(b3);
  ASIO_CHECK(s1.empty());

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s2 == "abcdefghijklmnopqrstuvwxyz");

  bool b4 = ch1.try_receive([](asio::error_code, std::string){});

  ASIO_CHECK(!b4);

  asio::error_code ec2 = asio::error::would_block;
  std::string s3 = "zyxwvutsrqponmlkjihgfedcba";
  ch1.async_send(asio::error::eof, std::move(s3),
      [&](asio::error_code ec)
      {
        ec2 = ec;
      });

  asio::error_code ec3;
  std::string s4;
  bool b5 = ch1.try_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec3 = ec;
        s4 = s;
      });

  ASIO_CHECK(b5);
  ASIO_CHECK(ec3 == asio::error::eof);
  ASIO_CHECK(s4 == "zyxwvutsrqponmlkjihgfedcba");

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec2);
}

void buffered_channel_test()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  ASIO_CHECK(ch1.is_open());
  ASIO_CHECK(!ch1.ready());

  bool b1 = ch1.try_send(asio::error::eof, "hello");

  ASIO_CHECK(b1);

  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
  bool b2 = ch1.try_send(asio::error::eof, std::move(s1));

  ASIO_CHECK(!b2);
  ASIO_CHECK(!s1.empty());

  asio::error_code ec1;
  std::string s2;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s2 = std::move(s);
      });

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s2 == "hello");

  bool b4 = ch1.try_receive([](asio::error_code, std::string){});

  ASIO_CHECK(!b4);

  asio::error_code ec2 = asio::error::would_block;
  std::string s3 = "zyxwvutsrqponmlkjihgfedcba";
  ch1.async_send(asio::error::eof, std::move(s3),
      [&](asio::error_code ec)
      {
        ec2 = ec;
      });

  asio::error_code ec3;
  std::string s4;
  bool b5 = ch1.try_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec3 = ec;
        s4 = s;
      });

  ASIO_CHECK(b5);
  ASIO_CHECK(ec3 == asio::error::eof);
  ASIO_CHECK(s4 == "zyxwvutsrqponmlkjihgfedcba");

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec2);

  bool b6 = ch1.try_send(asio::error_code(), "goodbye");

  ASIO_CHECK(b6);

  ch1.close();

  asio::error_code ec4;
  std::string s5;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec4 = ec;
        s5 = std::move(s);
      });

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec4);
  ASIO_CHECK(s5 == "goodbye");

  asio::error_code ec5;
  std::string s6;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec5 = ec;
        s6 = std::move(s);
      });

  ctx.restart();
  ctx.run();

  ASIO_CHECK(ec5 == asio::experimental::channel_errc::channel_closed);
  ASIO_CHECK(s6.empty());
}

void buffered_error_channel_test()
{
  io_context ctx;

  channel<void(asio::error_code)> ch1(ctx, 1);

  ASIO_CHECK(ch1.is_open());
  ASIO_CHECK(!ch1.ready());

  bool b1 = ch1.try_send(asio::error::eof);

  ASIO_CHECK(b1);

  bool b2 = ch1.try_send(asio::error::eof);

  ASIO_CHECK(!b2);

  asio::error_code ec1;
  ch1.async_receive(
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);

  bool b4 = ch1.try_receive([](asio::error_code){});

  ASIO_CHECK(!b4);

  asio::error_code ec2 = asio::error::would_block;
  ch1.async_send(asio::error::eof,
      [&](asio::error_code ec)
      {
        ec2 = ec;
      });

  asio::error_code ec3;
  bool b5 = ch1.try_receive(
      [&](asio::error_code ec)
      {
        ec3 = ec;
      });

  ASIO_CHECK(b5);
  ASIO_CHECK(ec3 == asio::error::eof);

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec2);
}

void unbuffered_non_immediate_receive()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec2 = ec;
        s2 = std::move(s);
      });

  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(!ec1);
  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");
}

void unbuffered_immediate_receive()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      bind_immediate_executor(system_executor(),
        [&](asio::error_code ec, std::string s)
        {
          ec2 = ec;
          s2 = std::move(s);
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);
  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");

  ctx.run();

  ASIO_CHECK(!ec1);
}

void unbuffered_executor_receive()
{
  io_context ctx;
  io_context ctx2;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      bind_executor(ctx2,
        [&](asio::error_code ec, std::string s)
        {
          ec2 = ec;
          s2 = std::move(s);
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);
  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(!ec1);
  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx2.run();

  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");
}

void unbuffered_non_immediate_send()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s1 = std::move(s);
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s2),
      [&](asio::error_code ec)
      {
        ec2 = ec;
      });

  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s1 == "0123456789");
  ASIO_CHECK(!ec2);
}

void unbuffered_immediate_send()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s1 = std::move(s);
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s2),
      bind_immediate_executor(system_executor(),
        [&](asio::error_code ec)
        {
          ec2 = ec;
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);
  ASIO_CHECK(!ec2);

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s1 == "0123456789");
}

void unbuffered_executor_send()
{
  io_context ctx;
  io_context ctx2;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s1 = std::move(s);
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s2),
      bind_executor(ctx2,
        [&](asio::error_code ec)
        {
          ec2 = ec;
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);
  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s1 == "0123456789");
  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx2.run();

  ASIO_CHECK(!ec2);
}

void buffered_non_immediate_receive()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(!ec1);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec2 = ec;
        s2 = std::move(s);
      });

  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.restart();
  ctx.run();

  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");
}

void buffered_immediate_receive()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(!ec1);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      bind_immediate_executor(system_executor(),
        [&](asio::error_code ec, std::string s)
        {
          ec2 = ec;
          s2 = std::move(s);
        }));

  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");

  ctx.restart();
  ctx.run();
}

void buffered_executor_receive()
{
  io_context ctx;
  io_context ctx2;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(!ec1);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      bind_executor(ctx2,
        [&](asio::error_code ec, std::string s)
        {
          ec2 = ec;
          s2 = std::move(s);
        }));

  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.restart();
  ctx.run();

  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx2.run();

  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");
}

void buffered_non_immediate_send()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      [&](asio::error_code ec)
      {
        ec1 = ec;
      });

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(!ec1);
}

void buffered_immediate_send()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      bind_immediate_executor(system_executor(),
        [&](asio::error_code ec)
        {
          ec1 = ec;
        }));

  ASIO_CHECK(!ec1);

  ctx.run();
}

void buffered_executor_send()
{
  io_context ctx;
  io_context ctx2;

  channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1 = "0123456789";
  ch1.async_send(asio::error::eof, std::move(s1),
      bind_executor(ctx2,
        [&](asio::error_code ec)
        {
          ec1 = ec;
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx2.run();

  ASIO_CHECK(!ec1);
}

void try_send_via_dispatch()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1;
  ch1.async_receive(
      bind_executor(asio::system_executor(),
        [&](asio::error_code ec, std::string s)
        {
          ec1 = ec;
          s1 = std::move(s);
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.poll();

  ASIO_CHECK(ec1 == asio::error::would_block);

  std::string s2 = "0123456789";
  ch1.try_send_via_dispatch(asio::error::eof, std::move(s2));

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s1 == "0123456789");
  ASIO_CHECK(s2.empty());
}

void try_send_n_via_dispatch()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1;
  ch1.async_receive(
      bind_executor(asio::system_executor(),
        [&](asio::error_code ec, std::string s)
        {
          ec1 = ec;
          s1 = std::move(s);
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);

  asio::error_code ec2 = asio::error::would_block;
  std::string s2;
  ch1.async_receive(
      bind_executor(asio::system_executor(),
        [&](asio::error_code ec, std::string s)
        {
          ec2 = ec;
          s2 = std::move(s);
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);

  ctx.poll();

  ASIO_CHECK(ec1 == asio::error::would_block);
  ASIO_CHECK(ec2 == asio::error::would_block);

  std::string s3 = "0123456789";
  ch1.try_send_n_via_dispatch(2, asio::error::eof, std::move(s3));

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s1 == "0123456789");
  ASIO_CHECK(ec2 == asio::error::eof);
  ASIO_CHECK(s2 == "0123456789");
  ASIO_CHECK(s3.empty());
}

struct multi_signature_handler
{
  std::string* s_;
  asio::error_code* ec_;

  void operator()(std::string s)
  {
    *s_ = s;
  }

  void operator()(asio::error_code ec)
  {
    *ec_ = ec;
  }
};

void implicit_error_signature_channel_test()
{
  io_context ctx;

  channel<void(std::string)> ch1(ctx);

  ASIO_CHECK(ch1.is_open());
  ASIO_CHECK(!ch1.ready());

  bool b1 = ch1.try_send("hello");

  ASIO_CHECK(!b1);

  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
  bool b2 = ch1.try_send(std::move(s1));

  ASIO_CHECK(!b2);
  ASIO_CHECK(!s1.empty());

  std::string s2;
  asio::error_code ec1 = asio::error::would_block;
  multi_signature_handler h1 = {&s2, &ec1};
  ch1.async_receive(h1);

  bool b3 = ch1.try_send(std::move(s1));

  ASIO_CHECK(b3);
  ASIO_CHECK(s1.empty());

  ctx.run();

  ASIO_CHECK(s2 == "abcdefghijklmnopqrstuvwxyz");
  ASIO_CHECK(ec1 == asio::error::would_block);

  std::string s3;
  asio::error_code ec2;
  multi_signature_handler h2 = {&s3, &ec2};
  bool b4 = ch1.try_receive(h2);

  ASIO_CHECK(!b4);

  std::string s4 = "zyxwvutsrqponmlkjihgfedcba";
  asio::error_code ec3;
  ch1.async_send(std::move(s4),
      [&](asio::error_code ec)
      {
        ec3 = ec;
      });

  std::string s5;
  asio::error_code ec4 = asio::error::would_block;
  multi_signature_handler h3 = {&s5, &ec4};
  bool b5 = ch1.try_receive(h3);

  ASIO_CHECK(b5);
  ASIO_CHECK(ec4 == asio::error::would_block);
  ASIO_CHECK(s5 == "zyxwvutsrqponmlkjihgfedcba");

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec3);

  std::string s6;
  asio::error_code ec5 = asio::error::would_block;
  multi_signature_handler h4 = {&s6, &ec5};
  ch1.async_receive(h4);

  ch1.close();

  ctx.restart();
  ctx.run();

  ASIO_CHECK(s6.empty());
  ASIO_CHECK(ec5 == asio::experimental::channel_errc::channel_closed);
}

void channel_with_any_completion_handler_test()
{
  io_context ctx;

  channel<void(asio::error_code, std::string)> ch1(ctx);

  asio::error_code ec1 = asio::error::would_block;
  std::string s1;
  ch1.async_receive(
      asio::any_completion_handler<
        void(asio::error_code, std::string)>(
          [&](asio::error_code ec, std::string s)
          {
            ec1 = ec;
            s1 = std::move(s);
          }));

  asio::error_code ec2 = asio::error::would_block;
  std::string s2 = "zyxwvutsrqponmlkjihgfedcba";
  ch1.async_send(asio::error::eof, std::move(s2),
      asio::any_completion_handler<void(asio::error_code)>(
        [&](asio::error_code ec)
        {
          ec2 = ec;
        }));

  ASIO_CHECK(ec1 == asio::error::would_block);
  ASIO_CHECK(ec2 == asio::error::would_block);

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s1 == "zyxwvutsrqponmlkjihgfedcba");
  ASIO_CHECK(!ec2);
}

ASIO_TEST_SUITE
(
  "experimental/channel",
  ASIO_TEST_CASE(unbuffered_channel_test)
  ASIO_TEST_CASE(buffered_channel_test)
  ASIO_TEST_CASE(buffered_error_channel_test)
  ASIO_TEST_CASE(unbuffered_non_immediate_receive)
  ASIO_TEST_CASE(unbuffered_immediate_receive)
  ASIO_TEST_CASE(unbuffered_executor_receive)
  ASIO_TEST_CASE(unbuffered_non_immediate_send)
  ASIO_TEST_CASE(unbuffered_immediate_send)
  ASIO_TEST_CASE(unbuffered_executor_send)
  ASIO_TEST_CASE(buffered_non_immediate_receive)
  ASIO_TEST_CASE(buffered_immediate_receive)
  ASIO_TEST_CASE(buffered_executor_receive)
  ASIO_TEST_CASE(buffered_non_immediate_send)
  ASIO_TEST_CASE(buffered_immediate_send)
  ASIO_TEST_CASE(buffered_executor_send)
  ASIO_TEST_CASE(try_send_via_dispatch)
  ASIO_TEST_CASE(try_send_n_via_dispatch)
  ASIO_TEST_CASE(implicit_error_signature_channel_test)
  ASIO_TEST_CASE(channel_with_any_completion_handler_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\co_composed.cpp
//
// experimental/co_composed.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/experimental/co_composed.hpp"

#include "asio/bind_cancellation_slot.hpp"
#include "asio/deferred.hpp"
#include "asio/detached.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "../unit_test.hpp"

template <typename CompletionToken>
auto async_throw(CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      [](auto) { throw 42; }, token);
}

template <typename CompletionToken>
auto throw_first(CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      asio::experimental::co_composed(
        [](auto state) -> void
        {
          throw 42;
          co_yield state.complete();
        }), token);
}

void test_throw_first()
{
  try
  {
    throw_first(asio::detached);
    ASIO_CHECK(0);
  }
  catch (int)
  {
  }
}

template <typename CompletionToken>
auto throw_after_await(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      asio::experimental::co_composed(
        [](auto state, asio::io_context& ctx) -> void
        {
          co_await asio::post(ctx, asio::deferred);
          throw 42;
          co_yield state.complete();
        }), token, std::ref(ctx));
}

void test_throw_after_await()
{
  try
  {
    asio::io_context ctx(1);
    throw_after_await(ctx, asio::detached);
    ctx.run();
    ASIO_CHECK(0);
  }
  catch (int)
  {
  }
}

template <typename CompletionToken>
auto throw_in_first_suspend(CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      asio::experimental::co_composed(
        [](auto state) -> void
        {
          co_await async_throw(asio::deferred);
          co_yield state.complete();
        }), token);
}

void test_throw_in_first_suspend()
{
  try
  {
    throw_in_first_suspend(asio::detached);
    ASIO_CHECK(0);
  }
  catch (int)
  {
  }
}

template <typename CompletionToken>
auto throw_in_suspend_after_await(
    asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      asio::experimental::co_composed(
        [](auto state, asio::io_context& ctx) -> void
        {
          co_await asio::post(ctx, asio::deferred);
          co_await async_throw(asio::deferred);
          co_yield state.complete();
        }), token, std::ref(ctx));
}

void test_throw_in_suspend_after_await()
{
  try
  {
    asio::io_context ctx(1);
    throw_in_suspend_after_await(ctx, asio::detached);
    ctx.run();
    ASIO_CHECK(0);
  }
  catch (int)
  {
  }
}

template <typename CompletionToken>
auto post_loop(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void(int)>(
      asio::experimental::co_composed(
        [](auto state, asio::io_context& ctx) -> void
        {
          int i = 0;
          for (; i < 100; ++i)
            co_await asio::post(ctx, asio::deferred);
          co_yield state.complete(i);
        }, ctx), token, std::ref(ctx));
}

void test_post_loop()
{
  asio::io_context ctx(1);
  int count = 0;
  post_loop(ctx, [&](int i){ count = i; });
  ctx.run();
  ASIO_CHECK(count == 100);
}

template <typename CompletionToken>
auto nested_post(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      asio::experimental::co_composed(
        [](auto state, asio::io_context& ctx) -> void
        {
          co_await asio::post(ctx, asio::deferred);
          co_yield state.complete();
        }, ctx), token, std::ref(ctx));
}

template <typename CompletionToken>
auto nested_post_loop(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void(int)>(
      asio::experimental::co_composed(
        [](auto state, asio::io_context& ctx) -> void
        {
          int i = 0;
          for (; i < 100; ++i)
            co_await nested_post(ctx, asio::deferred);
          co_yield state.complete(i);
        }, ctx), token, std::ref(ctx));
}

void test_nested_post_loop()
{
  asio::io_context ctx(1);
  int count = 0;
  nested_post_loop(ctx, [&](int i){ count = i; });
  ctx.run();
  ASIO_CHECK(count == 100);
}

template <typename CompletionToken>
auto post_loop_return_1_0(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void()>(
      asio::experimental::co_composed<void()>(
        [](auto, asio::io_context& ctx) -> void
        {
          int i = 0;
          for (; i < 100; ++i)
            co_await asio::post(ctx, asio::deferred);
          co_return {};
        }, ctx), token, std::ref(ctx));
}

void test_post_loop_return_1_0()
{
  asio::io_context ctx(1);
  bool done = false;
  post_loop_return_1_0(ctx, [&]{ done = true; });
  ctx.run();
  ASIO_CHECK(done);
}

template <typename CompletionToken>
auto post_loop_return_1_1(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void(int)>(
      asio::experimental::co_composed<void(int)>(
        [](auto, asio::io_context& ctx) -> void
        {
          int i = 0;
          for (; i < 100; ++i)
            co_await asio::post(ctx, asio::deferred);
          co_return {i};
        }, ctx), token, std::ref(ctx));
}

void test_post_loop_return_1_1()
{
  asio::io_context ctx(1);
  int count = 0;
  post_loop_return_1_1(ctx, [&](int i){ count = i; });
  ctx.run();
  ASIO_CHECK(count == 100);
}

template <typename CompletionToken>
auto post_loop_return_1_2(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void(int, char)>(
      asio::experimental::co_composed<void(int, char)>(
        [](auto, asio::io_context& ctx) -> void
        {
          int i = 0;
          for (; i < 100; ++i)
            co_await asio::post(ctx, asio::deferred);
          co_return {i, 'A'};
        }, ctx), token, std::ref(ctx));
}

void test_post_loop_return_1_2()
{
  asio::io_context ctx(1);
  int count = 0;
  char ch = 0;
  post_loop_return_1_2(ctx, [&](int i, char c){ count = i, ch = c; });
  ctx.run();
  ASIO_CHECK(count == 100);
  ASIO_CHECK(ch == 'A');
}

template <typename CompletionToken>
auto post_loop_return_2(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<CompletionToken, void(), void(int)>(
      asio::experimental::co_composed<void(), void(int)>(
        [](auto, asio::io_context& ctx) -> void
        {
          int i = 0;
          for (; i < 100; ++i)
            co_await asio::post(ctx, asio::deferred);
          co_return {i};
        }, ctx), token, std::ref(ctx));
}

void test_post_loop_return_2()
{
  asio::io_context ctx(1);
  int count = 0;
  post_loop_return_2(ctx, [&](int i = 0){ count = i; });
  ctx.run();
  ASIO_CHECK(count == 100);
}

template <typename CompletionToken>
auto complete_on_cancel(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<
    CompletionToken, void(asio::error_code, int)>(
      asio::experimental::co_composed<
        void(asio::error_code, int)>(
          [](auto state, asio::io_context& ctx) -> void
          {
            state.on_cancellation_complete_with(
                asio::error::invalid_argument, 42);
            int i = 0;
            for (; i < 100; ++i)
              co_await asio::post(ctx, asio::deferred);
            co_return {asio::error::eof, i};
          }, ctx), token, std::ref(ctx));
}

void test_complete_on_cancel()
{
  asio::io_context ctx(1);
  int count = 0;
  asio::error_code ec;
  asio::cancellation_signal cancel;

  complete_on_cancel(ctx,
      [&](asio::error_code e, int i)
      {
        ec = e;
        count = i;
      });

  ctx.run();

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 100);

  complete_on_cancel(ctx,
      asio::bind_cancellation_slot(cancel.slot(),
        [&](asio::error_code e, int i)
        {
          ec = e;
          count = i;
        }));

  ctx.restart();
  ctx.run_one();
  cancel.emit(asio::cancellation_type::all);
  ctx.run();

  ASIO_CHECK(ec == asio::error::invalid_argument);
  ASIO_CHECK(count == 42);

  complete_on_cancel(ctx,
      asio::bind_cancellation_slot(cancel.slot(),
        [&](asio::error_code e, int i)
        {
          ec = e;
          count = i;
        }));

  ctx.restart();
  ctx.run();

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 100);
}

template <typename CompletionToken>
auto complete_with_default_on_cancel(
    asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<
    CompletionToken, void(asio::error_code, int)>(
      asio::experimental::co_composed<
        void(asio::error_code, int)>(
          [](auto, asio::io_context& ctx) -> void
          {
            int i = 0;
            for (; i < 100; ++i)
              co_await asio::post(ctx, asio::deferred);
            co_return {asio::error::eof, i};
          }, ctx), token, std::ref(ctx));
}

void test_complete_with_default_on_cancel()
{
  asio::io_context ctx(1);
  int count = 0;
  asio::error_code ec;
  asio::cancellation_signal cancel;

  complete_with_default_on_cancel(ctx,
      [&](asio::error_code e, int i)
      {
        ec = e;
        count = i;
      });

  ctx.run();

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 100);

  complete_with_default_on_cancel(ctx,
      asio::bind_cancellation_slot(cancel.slot(),
        [&](asio::error_code e, int i)
        {
          ec = e;
          count = i;
        }));

  ctx.restart();
  ctx.run_one();
  cancel.emit(asio::cancellation_type::all);
  ctx.run();

  ASIO_CHECK(ec == asio::error::operation_aborted);
  ASIO_CHECK(count == 0);

  complete_with_default_on_cancel(ctx,
      asio::bind_cancellation_slot(cancel.slot(),
        [&](asio::error_code e, int i)
        {
          ec = e;
          count = i;
        }));

  ctx.restart();
  ctx.run();

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 100);
}

template <typename CompletionToken>
auto throw_on_cancel(asio::io_context& ctx, CompletionToken&& token)
{
  return asio::async_initiate<
    CompletionToken, void(asio::error_code, int)>(
      asio::experimental::co_composed<
        void(asio::error_code, int)>(
          [](auto state, asio::io_context& ctx) -> void
          {
            try
            {
              state.throw_if_cancelled(true);
              int i = 0;
              for (; i < 100; ++i)
                co_await asio::post(ctx, asio::deferred);
              co_return {asio::error::eof, i};
            }
            catch (...)
            {
              co_return {asio::error::invalid_argument, 42};
            }
          }, ctx), token, std::ref(ctx));
}

void test_throw_on_cancel()
{
  asio::io_context ctx(1);
  int count = 0;
  asio::error_code ec;
  asio::cancellation_signal cancel;

  throw_on_cancel(ctx,
      [&](asio::error_code e, int i)
      {
        ec = e;
        count = i;
      });

  ctx.run();

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 100);

  throw_on_cancel(ctx,
      asio::bind_cancellation_slot(cancel.slot(),
        [&](asio::error_code e, int i)
        {
          ec = e;
          count = i;
        }));

  ctx.restart();
  ctx.run_one();
  cancel.emit(asio::cancellation_type::all);
  ctx.run();

  ASIO_CHECK(ec == asio::error::invalid_argument);
  ASIO_CHECK(count == 42);

  throw_on_cancel(ctx,
      asio::bind_cancellation_slot(cancel.slot(),
        [&](asio::error_code e, int i)
        {
          ec = e;
          count = i;
        }));

  ctx.restart();
  ctx.run();

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 100);
}

ASIO_TEST_SUITE
(
  "experimental/co_composed",
  ASIO_TEST_CASE(test_throw_first)
  ASIO_TEST_CASE(test_throw_after_await)
  ASIO_TEST_CASE(test_throw_in_first_suspend)
  ASIO_TEST_CASE(test_throw_in_suspend_after_await)
  ASIO_TEST_CASE(test_post_loop)
  ASIO_TEST_CASE(test_nested_post_loop)
  ASIO_TEST_CASE(test_post_loop_return_1_0)
  ASIO_TEST_CASE(test_post_loop_return_1_1)
  ASIO_TEST_CASE(test_post_loop_return_1_2)
  ASIO_TEST_CASE(test_post_loop_return_2)
  ASIO_TEST_CASE(test_complete_on_cancel)
  ASIO_TEST_CASE(test_complete_with_default_on_cancel)
  ASIO_TEST_CASE(test_throw_on_cancel)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\concurrent_channel.cpp
//
// experimental/concurrent_channel.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/concurrent_channel.hpp"

#include <utility>
#include "asio/error.hpp"
#include "asio/io_context.hpp"
#include "../unit_test.hpp"

using namespace asio;
using namespace asio::experimental;

void unbuffered_concurrent_channel_test()
{
  io_context ctx;

  concurrent_channel<void(asio::error_code, std::string)> ch1(ctx);

  ASIO_CHECK(ch1.is_open());
  ASIO_CHECK(!ch1.ready());

  bool b1 = ch1.try_send(asio::error::eof, "hello");

  ASIO_CHECK(!b1);

  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
  bool b2 = ch1.try_send(asio::error::eof, std::move(s1));

  ASIO_CHECK(!b2);
  ASIO_CHECK(!s1.empty());

  asio::error_code ec1;
  std::string s2;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s2 = std::move(s);
      });

  bool b3 = ch1.try_send(asio::error::eof, std::move(s1));

  ASIO_CHECK(b3);
  ASIO_CHECK(s1.empty());

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s2 == "abcdefghijklmnopqrstuvwxyz");

  bool b4 = ch1.try_receive([](asio::error_code, std::string){});

  ASIO_CHECK(!b4);

  asio::error_code ec2 = asio::error::would_block;
  std::string s3 = "zyxwvutsrqponmlkjihgfedcba";
  ch1.async_send(asio::error::eof, std::move(s3),
      [&](asio::error_code ec)
      {
        ec2 = ec;
      });

  asio::error_code ec3;
  std::string s4;
  bool b5 = ch1.try_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec3 = ec;
        s4 = s;
      });

  ASIO_CHECK(b5);
  ASIO_CHECK(ec3 == asio::error::eof);
  ASIO_CHECK(s4 == "zyxwvutsrqponmlkjihgfedcba");

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec2);
};

void buffered_concurrent_channel_test()
{
  io_context ctx;

  concurrent_channel<void(asio::error_code, std::string)> ch1(ctx, 1);

  ASIO_CHECK(ch1.is_open());
  ASIO_CHECK(!ch1.ready());

  bool b1 = ch1.try_send(asio::error::eof, "hello");

  ASIO_CHECK(b1);

  std::string s1 = "abcdefghijklmnopqrstuvwxyz";
  bool b2 = ch1.try_send(asio::error::eof, std::move(s1));

  ASIO_CHECK(!b2);
  ASIO_CHECK(!s1.empty());

  asio::error_code ec1;
  std::string s2;
  ch1.async_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec1 = ec;
        s2 = std::move(s);
      });

  ctx.run();

  ASIO_CHECK(ec1 == asio::error::eof);
  ASIO_CHECK(s2 == "hello");

  bool b4 = ch1.try_receive([](asio::error_code, std::string){});

  ASIO_CHECK(!b4);

  asio::error_code ec2 = asio::error::would_block;
  std::string s3 = "zyxwvutsrqponmlkjihgfedcba";
  ch1.async_send(asio::error::eof, std::move(s3),
      [&](asio::error_code ec)
      {
        ec2 = ec;
      });

  asio::error_code ec3;
  std::string s4;
  bool b5 = ch1.try_receive(
      [&](asio::error_code ec, std::string s)
      {
        ec3 = ec;
        s4 = s;
      });

  ASIO_CHECK(b5);
  ASIO_CHECK(ec3 == asio::error::eof);
  ASIO_CHECK(s4 == "zyxwvutsrqponmlkjihgfedcba");

  ctx.restart();
  ctx.run();

  ASIO_CHECK(!ec2);
};

ASIO_TEST_SUITE
(
  "experimental/concurrent_channel",
  ASIO_TEST_CASE(unbuffered_concurrent_channel_test)
  ASIO_TEST_CASE(buffered_concurrent_channel_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\parallel_group.cpp
//
// experimental/parallel_group.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/parallel_group.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "experimental/parallel_group",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\experimental\promise.cpp
//
// promise.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2021-2023 Klemens D. Morgenstern
//                         (klemens dot morgenstern at gmx dot net)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/experimental/promise.hpp"

#include "asio/append.hpp"
#include "asio/bind_cancellation_slot.hpp"
#include "asio/compose.hpp"
#include "asio/deferred.hpp"
#include "asio/experimental/use_promise.hpp"
#include "asio/steady_timer.hpp"
#include "../unit_test.hpp"

namespace promise {

void promise_tester()
{
  using namespace asio;
  using namespace std::chrono;

  io_context ctx;

  steady_timer timer1{ctx}, timer2{ctx};

  const auto started_when = steady_clock::now();
  timer1.expires_at(started_when + milliseconds(5000));
  timer2.expires_at(started_when + milliseconds(1000));
  auto p1 = timer1.async_wait(experimental::use_promise);

  steady_clock::time_point completed_when;
  asio::error_code ec;
  bool called = false;

  p1([&](asio::error_code ec_)
      {
        ec = ec_;
        called = true;
        completed_when = steady_clock::now();
      });

  steady_clock::time_point timer2_done;
  timer2.async_wait(
      [&](asio::error_code)
      {
        timer2_done = steady_clock::now();
        p1.cancel();
      });

  ctx.run();

  static_assert(
      asio::is_async_operation<decltype(p1)>::value,
      "promise is async_op");

  ASIO_CHECK(timer2_done + milliseconds(1) > started_when);
  ASIO_CHECK(completed_when > timer2_done);
  ASIO_CHECK(called);
  ASIO_CHECK(ec == error::operation_aborted);

  timer1.expires_after(milliseconds(0));
  auto p2 = timer1.async_wait(
      asio::append(experimental::use_promise, 123));

  ec = asio::error::would_block;
  called = false;

  p2([&](asio::error_code ec_, int i)
      {
        ASIO_CHECK(i == 123);
        ec = ec_;
        called = true;
      });

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(!called);

  ctx.restart();
  ctx.run();

  static_assert(
      asio::is_async_operation<decltype(p2)>::value,
      "promise is async_op");

  ASIO_CHECK(!ec);
  ASIO_CHECK(called);
}

void promise_slot_tester()
{
  using namespace asio;
  using namespace std::chrono;

  io_context ctx;

  steady_timer timer1{ctx}, timer2{ctx};

  const auto started_when = steady_clock::now();
  timer1.expires_at(started_when + milliseconds(2500));
  timer2.expires_at(started_when + milliseconds(1000));
  auto p = timer1.async_wait(experimental::use_promise);

  steady_clock::time_point completed_when;
  asio::error_code ec;
  bool called = false;

  asio::cancellation_signal sig;

  p(asio::bind_cancellation_slot(
        sig.slot(),
        [&](asio::error_code ec_)
        {
          ec = ec_;
          called = true;
          completed_when = steady_clock::now();
        }));

  steady_clock::time_point timer2_done;
  timer2.async_wait(
      [&](asio::error_code)
      {
        timer2_done = steady_clock::now();
        sig.emit(asio::cancellation_type::all);
      });

  ctx.run();

  static_assert(
      asio::is_async_operation<decltype(p)>::value,
      "promise is async_op");

  ASIO_CHECK(timer2_done + milliseconds(1) > started_when);
  ASIO_CHECK(completed_when > timer2_done);
  ASIO_CHECK(called);
  ASIO_CHECK(ec == error::operation_aborted);
}

void early_completion()
{
  using namespace asio;
  using namespace std::chrono;

  io_context ctx;
  auto p = asio::post(ctx, asio::experimental::use_promise);
  ctx.run();

  ASIO_CHECK(p.completed());

  bool completed = false;
  p([&]{completed = true;});
  ASIO_CHECK(!completed);
  ctx.restart();
  ctx.run();
  ASIO_CHECK(completed);
}

struct test_cancel_impl_op
{
  asio::steady_timer & tim;
  asio::error_code &ec;
  template<typename Self>
  void operator()(Self& self)
  {
    tim.async_wait(std::forward<Self>(self));
  }

  template<typename Self>
  void operator()(Self& self, asio::error_code ec_)
  {
    ec = ec_;
    self.complete(ec_);
  }
};

template <typename CompletionToken>
ASIO_INITFN_AUTO_RESULT_TYPE(
    CompletionToken, void(asio::error_code))
test_cancel_impl(asio::steady_timer & tim,
                 asio::error_code &ec,
                 CompletionToken&& token)
{
  return asio::async_compose<CompletionToken, void(asio::error_code)>(
      test_cancel_impl_op{tim, ec}, token, tim);
}

void test_cancel()
{
  asio::io_context ctx;
  asio::steady_timer tim{ctx, std::chrono::seconds(10)};
  asio::error_code ec;

  {
    auto p = test_cancel_impl(
        tim, ec, asio::experimental::use_promise);
  }

  ctx.run();

  ASIO_CHECK_MESSAGE(
      ec == asio::error::operation_aborted,
      ec.message());
}

} // namespace promise

ASIO_TEST_SUITE
(
  "promise",
  ASIO_TEST_CASE(promise::promise_tester)
  ASIO_TEST_CASE(promise::promise_slot_tester)
  ASIO_TEST_CASE(promise::early_completion)
  ASIO_TEST_CASE(promise::test_cancel)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\generic\basic_endpoint.cpp
//
// generic/basic_endpoint.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/generic/basic_endpoint.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "generic/basic_endpoint",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\generic\datagram_protocol.cpp
//
// generic/datagram_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/generic/datagram_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "asio/ip/udp.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"

#if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
# define generic cpp_generic
#endif

//------------------------------------------------------------------------------

// generic_datagram_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// generic::datagram_socket::socket compile and link correctly. Runtime
// failures are ignored.

namespace generic_datagram_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
  using namespace asio;
  namespace generic = asio::generic;
  typedef generic::datagram_protocol dp;

  const int af_inet = ASIO_OS_DEF(AF_INET);
  const int ipproto_udp = ASIO_OS_DEF(IPPROTO_UDP);
  const int sock_dgram = ASIO_OS_DEF(SOCK_DGRAM);

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    socket_base::send_buffer_size socket_option;
    socket_base::bytes_readable io_control_command;
    archetypes::immediate_handler immediate;
    asio::error_code ec;

    // basic_datagram_socket constructors.

    dp::socket socket1(ioc);
    dp::socket socket2(ioc, dp(af_inet, ipproto_udp));
    dp::socket socket3(ioc, dp::endpoint());
#if !defined(ASIO_WINDOWS_RUNTIME)
    dp::socket::native_handle_type native_socket1
      = ::socket(af_inet, sock_dgram, 0);
    dp::socket socket4(ioc, dp(af_inet, ipproto_udp), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    dp::socket socket5(std::move(socket4));
    asio::ip::udp::socket udp_socket(ioc);
    dp::socket socket6(std::move(udp_socket));

    // basic_datagram_socket operators.

    socket1 = dp::socket(ioc);
    socket1 = std::move(socket2);
    socket1 = asio::ip::udp::socket(ioc);

    // basic_io_object functions.

    dp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    dp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(dp(af_inet, ipproto_udp));
    socket1.open(dp(af_inet, ipproto_udp), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    dp::socket::native_handle_type native_socket2
      = ::socket(af_inet, sock_dgram, 0);
    socket1.assign(dp(af_inet, ipproto_udp), native_socket2);
    dp::socket::native_handle_type native_socket3
      = ::socket(af_inet, sock_dgram, 0);
    socket1.assign(dp(af_inet, ipproto_udp), native_socket3, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    dp::socket::native_handle_type native_socket4 = socket1.native_handle();
    (void)native_socket4;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(dp::endpoint());
    socket1.bind(dp::endpoint(), ec);

    socket1.connect(dp::endpoint());
    socket1.connect(dp::endpoint(), ec);

    socket1.async_connect(dp::endpoint(), connect_handler);
    socket1.async_connect(dp::endpoint(), immediate);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    dp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    dp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    dp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    dp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_datagram_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler);
    socket1.async_send(buffer(const_char_buffer), send_handler);
    socket1.async_send(null_buffers(), send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);
    socket1.async_send(buffer(mutable_char_buffer), immediate);
    socket1.async_send(buffer(const_char_buffer), immediate);
    socket1.async_send(null_buffers(), immediate);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);

    socket1.send_to(buffer(mutable_char_buffer),
        dp::endpoint());
    socket1.send_to(buffer(const_char_buffer),
        dp::endpoint());
    socket1.send_to(null_buffers(),
        dp::endpoint());
    socket1.send_to(buffer(mutable_char_buffer),
        dp::endpoint(), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        dp::endpoint(), in_flags);
    socket1.send_to(null_buffers(),
        dp::endpoint(), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        dp::endpoint(), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        dp::endpoint(), in_flags, ec);
    socket1.send_to(null_buffers(),
        dp::endpoint(), in_flags, ec);

    socket1.async_send_to(buffer(mutable_char_buffer),
        dp::endpoint(), send_handler);
    socket1.async_send_to(buffer(const_char_buffer),
        dp::endpoint(), send_handler);
    socket1.async_send_to(null_buffers(),
        dp::endpoint(), send_handler);
    socket1.async_send_to(buffer(mutable_char_buffer),
        dp::endpoint(), in_flags, send_handler);
    socket1.async_send_to(buffer(const_char_buffer),
        dp::endpoint(), in_flags, send_handler);
    socket1.async_send_to(null_buffers(),
        dp::endpoint(), in_flags, send_handler);
    socket1.async_send_to(buffer(mutable_char_buffer),
        dp::endpoint(), immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        dp::endpoint(), immediate);
    socket1.async_send_to(null_buffers(),
        dp::endpoint(), immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        dp::endpoint(), in_flags, immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        dp::endpoint(), in_flags, immediate);
    socket1.async_send_to(null_buffers(),
        dp::endpoint(), in_flags, immediate);

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler);
    socket1.async_receive(null_buffers(), receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), in_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), immediate);
    socket1.async_receive(null_buffers(), immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_receive(null_buffers(), in_flags, immediate);

    dp::endpoint endpoint;
    socket1.receive_from(buffer(mutable_char_buffer), endpoint);
    socket1.receive_from(null_buffers(), endpoint);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags);
    socket1.receive_from(null_buffers(), endpoint, in_flags);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags, ec);
    socket1.receive_from(null_buffers(), endpoint, in_flags, ec);

    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, receive_handler);
    socket1.async_receive_from(null_buffers(),
        endpoint, receive_handler);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, receive_handler);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, receive_handler);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, immediate);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, immediate);
  }
  catch (std::exception&)
  {
  }
}

} // namespace generic_datagram_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "generic/datagram_protocol",
  ASIO_COMPILE_TEST_CASE(generic_datagram_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\generic\raw_protocol.cpp
//
// generic/raw_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/generic/raw_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "asio/ip/icmp.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"

#if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
# define generic cpp_generic
#endif

//------------------------------------------------------------------------------

// generic_raw_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// generic::raw_socket::socket compile and link correctly. Runtime failures
// are ignored.

namespace generic_raw_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
  using namespace asio;
  namespace generic = asio::generic;
  typedef generic::raw_protocol rp;

  const int af_inet = ASIO_OS_DEF(AF_INET);
  const int ipproto_icmp = ASIO_OS_DEF(IPPROTO_ICMP);
  const int sock_raw = ASIO_OS_DEF(SOCK_RAW);

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    socket_base::send_buffer_size socket_option;
    socket_base::bytes_readable io_control_command;
    archetypes::immediate_handler immediate;
    asio::error_code ec;

    // basic_raw_socket constructors.

    rp::socket socket1(ioc);
    rp::socket socket2(ioc, rp(af_inet, ipproto_icmp));
    rp::socket socket3(ioc, rp::endpoint());
#if !defined(ASIO_WINDOWS_RUNTIME)
    rp::socket::native_handle_type native_socket1
      = ::socket(af_inet, sock_raw, 0);
    rp::socket socket4(ioc, rp(af_inet, ipproto_icmp), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    rp::socket socket5(std::move(socket4));
    asio::ip::icmp::socket icmp_socket(ioc);
    rp::socket socket6(std::move(icmp_socket));

    // basic_datagram_socket operators.

    socket1 = rp::socket(ioc);
    socket1 = std::move(socket2);
    socket1 = asio::ip::icmp::socket(ioc);

    // basic_io_object functions.

    rp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    rp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(rp(af_inet, ipproto_icmp));
    socket1.open(rp(af_inet, ipproto_icmp), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    rp::socket::native_handle_type native_socket2
      = ::socket(af_inet, sock_raw, 0);
    socket1.assign(rp(af_inet, ipproto_icmp), native_socket2);
    rp::socket::native_handle_type native_socket3
      = ::socket(af_inet, sock_raw, 0);
    socket1.assign(rp(af_inet, ipproto_icmp), native_socket3, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    rp::socket::native_handle_type native_socket4 = socket1.native_handle();
    (void)native_socket4;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(rp::endpoint());
    socket1.bind(rp::endpoint(), ec);

    socket1.connect(rp::endpoint());
    socket1.connect(rp::endpoint(), ec);

    socket1.async_connect(rp::endpoint(), connect_handler);
    socket1.async_connect(rp::endpoint(), immediate);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    rp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    rp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    rp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    rp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_raw_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler);
    socket1.async_send(buffer(const_char_buffer), send_handler);
    socket1.async_send(null_buffers(), send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);
    socket1.async_send(buffer(mutable_char_buffer), immediate);
    socket1.async_send(buffer(const_char_buffer), immediate);
    socket1.async_send(null_buffers(), immediate);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);

    socket1.send_to(buffer(mutable_char_buffer),
        rp::endpoint());
    socket1.send_to(buffer(const_char_buffer),
        rp::endpoint());
    socket1.send_to(null_buffers(),
        rp::endpoint());
    socket1.send_to(buffer(mutable_char_buffer),
        rp::endpoint(), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        rp::endpoint(), in_flags);
    socket1.send_to(null_buffers(),
        rp::endpoint(), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        rp::endpoint(), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        rp::endpoint(), in_flags, ec);
    socket1.send_to(null_buffers(),
        rp::endpoint(), in_flags, ec);

    socket1.async_send_to(buffer(mutable_char_buffer),
        rp::endpoint(), send_handler);
    socket1.async_send_to(buffer(const_char_buffer),
        rp::endpoint(), send_handler);
    socket1.async_send_to(null_buffers(),
        rp::endpoint(), send_handler);
    socket1.async_send_to(buffer(mutable_char_buffer),
        rp::endpoint(), in_flags, send_handler);
    socket1.async_send_to(buffer(const_char_buffer),
        rp::endpoint(), in_flags, send_handler);
    socket1.async_send_to(null_buffers(),
        rp::endpoint(), in_flags, send_handler);
    socket1.async_send_to(buffer(mutable_char_buffer),
        rp::endpoint(), immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        rp::endpoint(), immediate);
    socket1.async_send_to(null_buffers(),
        rp::endpoint(), immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        rp::endpoint(), in_flags, immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        rp::endpoint(), in_flags, immediate);
    socket1.async_send_to(null_buffers(),
        rp::endpoint(), in_flags, immediate);

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler);
    socket1.async_receive(null_buffers(), receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), in_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), immediate);
    socket1.async_receive(null_buffers(), immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        immediate);
    socket1.async_receive(null_buffers(), in_flags, immediate);

    rp::endpoint endpoint;
    socket1.receive_from(buffer(mutable_char_buffer), endpoint);
    socket1.receive_from(null_buffers(), endpoint);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags);
    socket1.receive_from(null_buffers(), endpoint, in_flags);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags, ec);
    socket1.receive_from(null_buffers(), endpoint, in_flags, ec);

    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, receive_handler);
    socket1.async_receive_from(null_buffers(),
        endpoint, receive_handler);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, receive_handler);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, receive_handler);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, immediate);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, immediate);
  }
  catch (std::exception&)
  {
  }
}

} // namespace generic_raw_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "generic/raw_protocol",
  ASIO_COMPILE_TEST_CASE(generic_raw_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\generic\seq_packet_protocol.cpp
//
// generic/seq_packet_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/generic/seq_packet_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"

#if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
# define generic cpp_generic
#endif

//------------------------------------------------------------------------------

// generic_seq_packet_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// generic::seq_packet_socket::socket compile and link correctly. Runtime
// failures are ignored.

namespace generic_seq_packet_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
  using namespace asio;
  namespace generic = asio::generic;
  typedef generic::seq_packet_protocol spp;

  const int af_inet = ASIO_OS_DEF(AF_INET);
  const int sock_seqpacket = ASIO_OS_DEF(SOCK_SEQPACKET);

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    const socket_base::message_flags in_flags = 0;
    socket_base::message_flags out_flags = 0;
    socket_base::send_buffer_size socket_option;
    socket_base::bytes_readable io_control_command;
    archetypes::immediate_handler immediate;
    asio::error_code ec;

    // basic_seq_packet_socket constructors.

    spp::socket socket1(ioc);
    spp::socket socket2(ioc, spp(af_inet, 0));
    spp::socket socket3(ioc, spp::endpoint());
#if !defined(ASIO_WINDOWS_RUNTIME)
    spp::socket::native_handle_type native_socket1
      = ::socket(af_inet, sock_seqpacket, 0);
    spp::socket socket4(ioc, spp(af_inet, 0), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    spp::socket socket5(std::move(socket4));

    // basic_seq_packet_socket operators.

    socket1 = spp::socket(ioc);
    socket1 = std::move(socket2);

    // basic_io_object functions.

    spp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    spp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(spp(af_inet, 0));
    socket1.open(spp(af_inet, 0), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    spp::socket::native_handle_type native_socket2
      = ::socket(af_inet, sock_seqpacket, 0);
    socket1.assign(spp(af_inet, 0), native_socket2);
    spp::socket::native_handle_type native_socket3
      = ::socket(af_inet, sock_seqpacket, 0);
    socket1.assign(spp(af_inet, 0), native_socket3, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    spp::socket::native_handle_type native_socket4 = socket1.native_handle();
    (void)native_socket4;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(spp::endpoint());
    socket1.bind(spp::endpoint(), ec);

    socket1.connect(spp::endpoint());
    socket1.connect(spp::endpoint(), ec);

    socket1.async_connect(spp::endpoint(), connect_handler);
    socket1.async_connect(spp::endpoint(), immediate);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    spp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    spp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    spp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    spp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_seq_packet_socket functions.

    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);

    socket1.receive(buffer(mutable_char_buffer), out_flags);
    socket1.receive(null_buffers(), out_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, out_flags);
    socket1.receive(null_buffers(), in_flags, out_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, out_flags, ec);
    socket1.receive(null_buffers(), in_flags, out_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), out_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), out_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        out_flags, receive_handler);
    socket1.async_receive(null_buffers(), in_flags, out_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), out_flags, immediate);
    socket1.async_receive(null_buffers(), out_flags, immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        out_flags, immediate);
    socket1.async_receive(null_buffers(), in_flags, out_flags, immediate);
  }
  catch (std::exception&)
  {
  }
}

} // namespace generic_seq_packet_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "generic/seq_packet_protocol",
  ASIO_COMPILE_TEST_CASE(generic_seq_packet_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\generic\stream_protocol.cpp
//
// generic/stream_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/generic/stream_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"

#if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
# define generic cpp_generic
#endif

//------------------------------------------------------------------------------

// generic_stream_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// generic::stream_protocol::socket compile and link correctly. Runtime
// failures are ignored.

namespace generic_stream_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
  using namespace asio;
  namespace generic = asio::generic;
  typedef generic::stream_protocol sp;

  const int af_inet = ASIO_OS_DEF(AF_INET);
  const int ipproto_tcp = ASIO_OS_DEF(IPPROTO_TCP);
  const int sock_stream = ASIO_OS_DEF(SOCK_STREAM);

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    socket_base::keep_alive socket_option;
    socket_base::bytes_readable io_control_command;
    archetypes::immediate_handler immediate;
    asio::error_code ec;

    // basic_stream_socket constructors.

    sp::socket socket1(ioc);
    sp::socket socket2(ioc, sp(af_inet, ipproto_tcp));
    sp::socket socket3(ioc, sp::endpoint());
#if defined(ASIO_WINDOWS_RUNTIME)
    Windows::Networking::Sockets::StreamSocket^ native_socket1 = nullptr;
#else // defined(ASIO_WINDOWS_RUNTIME)
    sp::socket::native_handle_type native_socket1
      = ::socket(af_inet, sock_stream, 0);
#endif // defined(ASIO_WINDOWS_RUNTIME)
    sp::socket socket4(ioc, sp(af_inet, ipproto_tcp), native_socket1);

    sp::socket socket5(std::move(socket4));
    asio::ip::tcp::socket tcp_socket(ioc);
    sp::socket socket6(std::move(tcp_socket));

    // basic_stream_socket operators.

    socket1 = sp::socket(ioc);
    socket1 = std::move(socket2);
    socket1 = asio::ip::tcp::socket(ioc);

    // basic_io_object functions.

    sp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    sp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(sp(af_inet, ipproto_tcp));
    socket1.open(sp(af_inet, ipproto_tcp), ec);

#if defined(ASIO_WINDOWS_RUNTIME)
    Windows::Networking::Sockets::StreamSocket^ native_socket2 = nullptr;
#else // defined(ASIO_WINDOWS_RUNTIME)
    sp::socket::native_handle_type native_socket2
      = ::socket(af_inet, sock_stream, 0);
#endif // defined(ASIO_WINDOWS_RUNTIME)
    socket1.assign(sp(af_inet, ipproto_tcp), native_socket2);
#if defined(ASIO_WINDOWS_RUNTIME)
    Windows::Networking::Sockets::StreamSocket^ native_socket3 = nullptr;
#else // defined(ASIO_WINDOWS_RUNTIME)
    sp::socket::native_handle_type native_socket3
      = ::socket(af_inet, sock_stream, 0);
#endif // defined(ASIO_WINDOWS_RUNTIME)
    socket1.assign(sp(af_inet, ipproto_tcp), native_socket3, ec);

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    sp::socket::native_handle_type native_socket4 = socket1.native_handle();
    (void)native_socket4;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(sp::endpoint());
    socket1.bind(sp::endpoint(), ec);

    socket1.connect(sp::endpoint());
    socket1.connect(sp::endpoint(), ec);

    socket1.async_connect(sp::endpoint(), connect_handler);
    socket1.async_connect(sp::endpoint(), immediate);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    sp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    sp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    sp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    sp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_stream_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler);
    socket1.async_send(buffer(const_char_buffer), send_handler);
    socket1.async_send(null_buffers(), send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);
    socket1.async_send(buffer(mutable_char_buffer), immediate);
    socket1.async_send(buffer(const_char_buffer), immediate);
    socket1.async_send(null_buffers(), immediate);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler);
    socket1.async_receive(null_buffers(), receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), in_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), immediate);
    socket1.async_receive(null_buffers(), immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        immediate);
    socket1.async_receive(null_buffers(), in_flags, immediate);

    socket1.write_some(buffer(mutable_char_buffer));
    socket1.write_some(buffer(const_char_buffer));
    socket1.write_some(null_buffers());
    socket1.write_some(buffer(mutable_char_buffer), ec);
    socket1.write_some(buffer(const_char_buffer), ec);
    socket1.write_some(null_buffers(), ec);

    socket1.async_write_some(buffer(mutable_char_buffer), write_some_handler);
    socket1.async_write_some(buffer(const_char_buffer), write_some_handler);
    socket1.async_write_some(null_buffers(), write_some_handler);
    socket1.async_write_some(buffer(mutable_char_buffer), immediate);
    socket1.async_write_some(buffer(const_char_buffer), immediate);
    socket1.async_write_some(null_buffers(), immediate);

    socket1.read_some(buffer(mutable_char_buffer));
    socket1.read_some(buffer(mutable_char_buffer), ec);
    socket1.read_some(null_buffers(), ec);

    socket1.async_read_some(buffer(mutable_char_buffer), read_some_handler);
    socket1.async_read_some(null_buffers(), read_some_handler);
    socket1.async_read_some(buffer(mutable_char_buffer), immediate);
    socket1.async_read_some(null_buffers(), immediate);
  }
  catch (std::exception&)
  {
  }
}

} // namespace generic_stream_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "generic/stream_protocol",
  ASIO_COMPILE_TEST_CASE(generic_stream_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address_v4_iterator.cpp
//
// address_v4_iterator.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address_v4_iterator.hpp"

#include "../unit_test.hpp"

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address_v4_iterator",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address_v4_range.cpp
//
// address_v4_range.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address_v4_range.hpp"

#include "../unit_test.hpp"

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address_v4_range",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address_v4.cpp
//
// address_v4.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address_v4.hpp"

#include "../unit_test.hpp"
#include <sstream>

//------------------------------------------------------------------------------

// ip_address_v4_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::address_v4 compile and link correctly. Runtime failures are ignored.

namespace ip_address_v4_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    asio::error_code ec;

    // address_v4 constructors.

    ip::address_v4 addr1;
    const ip::address_v4::bytes_type const_bytes_value = { { 127, 0, 0, 1 } };
    ip::address_v4 addr2(const_bytes_value);
    const unsigned long const_ulong_value = 0x7F000001;
    ip::address_v4 addr3(const_ulong_value);

    // address_v4 functions.

    bool b = addr1.is_loopback();
    (void)b;

    b = addr1.is_unspecified();
    (void)b;

#if !defined(ASIO_NO_DEPRECATED)
    b = addr1.is_class_a();
    (void)b;

    b = addr1.is_class_b();
    (void)b;

    b = addr1.is_class_c();
    (void)b;
#endif // !defined(ASIO_NO_DEPRECATED)

    b = addr1.is_multicast();
    (void)b;

    ip::address_v4::bytes_type bytes_value = addr1.to_bytes();
    (void)bytes_value;

    ip::address_v4::uint_type uint_value = addr1.to_uint();
    (void)uint_value;

#if !defined(ASIO_NO_DEPRECATED)
    unsigned long ulong_value = addr1.to_ulong();
    (void)ulong_value;
#endif // !defined(ASIO_NO_DEPRECATED)

    std::string string_value = addr1.to_string();
#if !defined(ASIO_NO_DEPRECATED)
    string_value = addr1.to_string(ec);
#endif // !defined(ASIO_NO_DEPRECATED)

    // address_v4 static functions.

#if !defined(ASIO_NO_DEPRECATED)
    addr1 = ip::address_v4::from_string("127.0.0.1");
    addr1 = ip::address_v4::from_string("127.0.0.1", ec);
    addr1 = ip::address_v4::from_string(string_value);
    addr1 = ip::address_v4::from_string(string_value, ec);
#endif // !defined(ASIO_NO_DEPRECATED)

    addr1 = ip::address_v4::any();

    addr1 = ip::address_v4::loopback();

    addr1 = ip::address_v4::broadcast();

#if !defined(ASIO_NO_DEPRECATED)
    addr1 = ip::address_v4::broadcast(addr2, addr3);

    addr1 = ip::address_v4::netmask(addr2);
#endif // !defined(ASIO_NO_DEPRECATED)

    // address_v4 comparisons.

    b = (addr1 == addr2);
    (void)b;

    b = (addr1 != addr2);
    (void)b;

    b = (addr1 < addr2);
    (void)b;

    b = (addr1 > addr2);
    (void)b;

    b = (addr1 <= addr2);
    (void)b;

    b = (addr1 >= addr2);
    (void)b;

    // address_v4 creation functions.

    addr1 = ip::make_address_v4(const_bytes_value);
    addr1 = ip::make_address_v4(const_ulong_value);
    addr1 = ip::make_address_v4("127.0.0.1");
    addr1 = ip::make_address_v4("127.0.0.1", ec);
    addr1 = ip::make_address_v4(string_value);
    addr1 = ip::make_address_v4(string_value, ec);
#if defined(ASIO_HAS_STRING_VIEW)
# if defined(ASIO_HAS_STD_STRING_VIEW)
    std::string_view string_view_value("127.0.0.1");
# elif defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    std::experimental::string_view string_view_value("127.0.0.1");
# endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    addr1 = ip::make_address_v4(string_view_value);
    addr1 = ip::make_address_v4(string_view_value, ec);
#endif // defined(ASIO_HAS_STRING_VIEW)

    // address_v4 I/O.

    std::ostringstream os;
    os << addr1;

#if !defined(BOOST_NO_STD_WSTREAMBUF)
    std::wostringstream wos;
    wos << addr1;
#endif // !defined(BOOST_NO_STD_WSTREAMBUF)

#if defined(ASIO_HAS_STD_HASH)
    std::size_t hash1 = std::hash<ip::address_v4>()(addr1);
    (void)hash1;
#endif // defined(ASIO_HAS_STD_HASH)
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_address_v4_compile

//------------------------------------------------------------------------------

// ip_address_v4_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that the various public member functions meet the
// necessary postconditions.

namespace ip_address_v4_runtime {

void test()
{
  using asio::ip::address_v4;

  address_v4 a1;
  ASIO_CHECK(a1.to_bytes()[0] == 0);
  ASIO_CHECK(a1.to_bytes()[1] == 0);
  ASIO_CHECK(a1.to_bytes()[2] == 0);
  ASIO_CHECK(a1.to_bytes()[3] == 0);
  ASIO_CHECK(a1.to_uint() == 0);
#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(a1.to_ulong() == 0);
#endif // !defined(ASIO_NO_DEPRECATED)

  address_v4::bytes_type b1 = {{ 1, 2, 3, 4 }};
  address_v4 a2(b1);
  ASIO_CHECK(a2.to_bytes()[0] == 1);
  ASIO_CHECK(a2.to_bytes()[1] == 2);
  ASIO_CHECK(a2.to_bytes()[2] == 3);
  ASIO_CHECK(a2.to_bytes()[3] == 4);
  ASIO_CHECK(((a2.to_uint() >> 24) & 0xFF) == b1[0]);
  ASIO_CHECK(((a2.to_uint() >> 16) & 0xFF) == b1[1]);
  ASIO_CHECK(((a2.to_uint() >> 8) & 0xFF) == b1[2]);
  ASIO_CHECK((a2.to_uint() & 0xFF) == b1[3]);
#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(((a2.to_ulong() >> 24) & 0xFF) == b1[0]);
  ASIO_CHECK(((a2.to_ulong() >> 16) & 0xFF) == b1[1]);
  ASIO_CHECK(((a2.to_ulong() >> 8) & 0xFF) == b1[2]);
  ASIO_CHECK((a2.to_ulong() & 0xFF) == b1[3]);
#endif // !defined(ASIO_NO_DEPRECATED)

  address_v4 a3(0x01020304);
  ASIO_CHECK(a3.to_bytes()[0] == 1);
  ASIO_CHECK(a3.to_bytes()[1] == 2);
  ASIO_CHECK(a3.to_bytes()[2] == 3);
  ASIO_CHECK(a3.to_bytes()[3] == 4);
  ASIO_CHECK(a3.to_uint() == 0x01020304);
#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(a3.to_ulong() == 0x01020304);
#endif // !defined(ASIO_NO_DEPRECATED)

  ASIO_CHECK(address_v4(0x7F000001).is_loopback());
  ASIO_CHECK(address_v4(0x7F000002).is_loopback());
  ASIO_CHECK(!address_v4(0x00000000).is_loopback());
  ASIO_CHECK(!address_v4(0x01020304).is_loopback());

  ASIO_CHECK(address_v4(0x00000000).is_unspecified());
  ASIO_CHECK(!address_v4(0x7F000001).is_unspecified());
  ASIO_CHECK(!address_v4(0x01020304).is_unspecified());

#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(address_v4(0x01000000).is_class_a());
  ASIO_CHECK(address_v4(0x7F000000).is_class_a());
  ASIO_CHECK(!address_v4(0x80000000).is_class_a());
  ASIO_CHECK(!address_v4(0xBFFF0000).is_class_a());
  ASIO_CHECK(!address_v4(0xC0000000).is_class_a());
  ASIO_CHECK(!address_v4(0xDFFFFF00).is_class_a());
  ASIO_CHECK(!address_v4(0xE0000000).is_class_a());
  ASIO_CHECK(!address_v4(0xEFFFFFFF).is_class_a());
  ASIO_CHECK(!address_v4(0xF0000000).is_class_a());
  ASIO_CHECK(!address_v4(0xFFFFFFFF).is_class_a());

  ASIO_CHECK(!address_v4(0x01000000).is_class_b());
  ASIO_CHECK(!address_v4(0x7F000000).is_class_b());
  ASIO_CHECK(address_v4(0x80000000).is_class_b());
  ASIO_CHECK(address_v4(0xBFFF0000).is_class_b());
  ASIO_CHECK(!address_v4(0xC0000000).is_class_b());
  ASIO_CHECK(!address_v4(0xDFFFFF00).is_class_b());
  ASIO_CHECK(!address_v4(0xE0000000).is_class_b());
  ASIO_CHECK(!address_v4(0xEFFFFFFF).is_class_b());
  ASIO_CHECK(!address_v4(0xF0000000).is_class_b());
  ASIO_CHECK(!address_v4(0xFFFFFFFF).is_class_b());

  ASIO_CHECK(!address_v4(0x01000000).is_class_c());
  ASIO_CHECK(!address_v4(0x7F000000).is_class_c());
  ASIO_CHECK(!address_v4(0x80000000).is_class_c());
  ASIO_CHECK(!address_v4(0xBFFF0000).is_class_c());
  ASIO_CHECK(address_v4(0xC0000000).is_class_c());
  ASIO_CHECK(address_v4(0xDFFFFF00).is_class_c());
  ASIO_CHECK(!address_v4(0xE0000000).is_class_c());
  ASIO_CHECK(!address_v4(0xEFFFFFFF).is_class_c());
  ASIO_CHECK(!address_v4(0xF0000000).is_class_c());
  ASIO_CHECK(!address_v4(0xFFFFFFFF).is_class_c());
#endif // !defined(ASIO_NO_DEPRECATED)

  ASIO_CHECK(!address_v4(0x01000000).is_multicast());
  ASIO_CHECK(!address_v4(0x7F000000).is_multicast());
  ASIO_CHECK(!address_v4(0x80000000).is_multicast());
  ASIO_CHECK(!address_v4(0xBFFF0000).is_multicast());
  ASIO_CHECK(!address_v4(0xC0000000).is_multicast());
  ASIO_CHECK(!address_v4(0xDFFFFF00).is_multicast());
  ASIO_CHECK(address_v4(0xE0000000).is_multicast());
  ASIO_CHECK(address_v4(0xEFFFFFFF).is_multicast());
  ASIO_CHECK(!address_v4(0xF0000000).is_multicast());
  ASIO_CHECK(!address_v4(0xFFFFFFFF).is_multicast());

  address_v4 a4 = address_v4::any();
  ASIO_CHECK(a4.to_bytes()[0] == 0);
  ASIO_CHECK(a4.to_bytes()[1] == 0);
  ASIO_CHECK(a4.to_bytes()[2] == 0);
  ASIO_CHECK(a4.to_bytes()[3] == 0);
  ASIO_CHECK(a4.to_uint() == 0);
#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(a4.to_ulong() == 0);
#endif // !defined(ASIO_NO_DEPRECATED)

  address_v4 a5 = address_v4::loopback();
  ASIO_CHECK(a5.to_bytes()[0] == 0x7F);
  ASIO_CHECK(a5.to_bytes()[1] == 0);
  ASIO_CHECK(a5.to_bytes()[2] == 0);
  ASIO_CHECK(a5.to_bytes()[3] == 0x01);
  ASIO_CHECK(a5.to_uint() == 0x7F000001);
#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(a5.to_ulong() == 0x7F000001);
#endif // !defined(ASIO_NO_DEPRECATED)

  address_v4 a6 = address_v4::broadcast();
  ASIO_CHECK(a6.to_bytes()[0] == 0xFF);
  ASIO_CHECK(a6.to_bytes()[1] == 0xFF);
  ASIO_CHECK(a6.to_bytes()[2] == 0xFF);
  ASIO_CHECK(a6.to_bytes()[3] == 0xFF);
  ASIO_CHECK(a6.to_uint() == 0xFFFFFFFF);
#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(a6.to_ulong() == 0xFFFFFFFF);
#endif // !defined(ASIO_NO_DEPRECATED)

#if !defined(ASIO_NO_DEPRECATED)
  address_v4 class_a_net(0xFF000000);
  address_v4 class_b_net(0xFFFF0000);
  address_v4 class_c_net(0xFFFFFF00);
  address_v4 other_net(0xFFFFFFFF);
  ASIO_CHECK(address_v4::netmask(address_v4(0x01000000)) == class_a_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0x7F000000)) == class_a_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0x80000000)) == class_b_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xBFFF0000)) == class_b_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xC0000000)) == class_c_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xDFFFFF00)) == class_c_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xE0000000)) == other_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xEFFFFFFF)) == other_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xF0000000)) == other_net);
  ASIO_CHECK(address_v4::netmask(address_v4(0xFFFFFFFF)) == other_net);
#endif // !defined(ASIO_NO_DEPRECATED)
}

} // namespace ip_address_v4_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address_v4",
  ASIO_COMPILE_TEST_CASE(ip_address_v4_compile::test)
  ASIO_TEST_CASE(ip_address_v4_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address_v6_iterator.cpp
//
// address_v6_iterator.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address_v6_iterator.hpp"

#include "../unit_test.hpp"

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address_v6_iterator",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address_v6_range.cpp
//
// address_v6_range.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address_v6_range.hpp"

#include "../unit_test.hpp"

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address_v6_range",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address_v6.cpp
//
// address_v6.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address_v6.hpp"

#include "../unit_test.hpp"
#include <sstream>

//------------------------------------------------------------------------------

// ip_address_v6_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::address_v6 compile and link correctly. Runtime failures are ignored.

namespace ip_address_v6_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    asio::error_code ec;

    // address_v6 constructors.

    ip::address_v6 addr1;
    const ip::address_v6::bytes_type const_bytes_value = { { 0 } };
    ip::address_v6 addr2(const_bytes_value);

    // address_v6 functions.

    unsigned long scope_id = addr1.scope_id();
    addr1.scope_id(scope_id);

    bool b = addr1.is_unspecified();
    (void)b;

    b = addr1.is_loopback();
    (void)b;

    b = addr1.is_multicast();
    (void)b;

    b = addr1.is_link_local();
    (void)b;

    b = addr1.is_site_local();
    (void)b;

    b = addr1.is_v4_mapped();
    (void)b;

#if !defined(ASIO_NO_DEPRECATED)
    b = addr1.is_v4_compatible();
    (void)b;
#endif // !defined(ASIO_NO_DEPRECATED)

    b = addr1.is_multicast_node_local();
    (void)b;

    b = addr1.is_multicast_link_local();
    (void)b;

    b = addr1.is_multicast_site_local();
    (void)b;

    b = addr1.is_multicast_org_local();
    (void)b;

    b = addr1.is_multicast_global();
    (void)b;

    ip::address_v6::bytes_type bytes_value = addr1.to_bytes();
    (void)bytes_value;

    std::string string_value = addr1.to_string();
#if !defined(ASIO_NO_DEPRECATED)
    string_value = addr1.to_string(ec);
#endif // !defined(ASIO_NO_DEPRECATED)

#if !defined(ASIO_NO_DEPRECATED)
    ip::address_v4 addr3 = addr1.to_v4();
#endif // !defined(ASIO_NO_DEPRECATED)

    // address_v6 static functions.

#if !defined(ASIO_NO_DEPRECATED)
    addr1 = ip::address_v6::from_string("0::0");
    addr1 = ip::address_v6::from_string("0::0", ec);
    addr1 = ip::address_v6::from_string(string_value);
    addr1 = ip::address_v6::from_string(string_value, ec);
#endif // !defined(ASIO_NO_DEPRECATED)

    addr1 = ip::address_v6::any();

    addr1 = ip::address_v6::loopback();

#if !defined(ASIO_NO_DEPRECATED)
    addr1 = ip::address_v6::v4_mapped(addr3);

    addr1 = ip::address_v6::v4_compatible(addr3);
#endif // !defined(ASIO_NO_DEPRECATED)

    // address_v6 comparisons.

    b = (addr1 == addr2);
    (void)b;

    b = (addr1 != addr2);
    (void)b;

    b = (addr1 < addr2);
    (void)b;

    b = (addr1 > addr2);
    (void)b;

    b = (addr1 <= addr2);
    (void)b;

    b = (addr1 >= addr2);
    (void)b;

    // address_v6 creation functions.

    addr1 = ip::make_address_v6(const_bytes_value, scope_id);
    addr1 = ip::make_address_v6("0::0");
    addr1 = ip::make_address_v6("0::0", ec);
    addr1 = ip::make_address_v6(string_value);
    addr1 = ip::make_address_v6(string_value, ec);
#if defined(ASIO_HAS_STRING_VIEW)
# if defined(ASIO_HAS_STD_STRING_VIEW)
    std::string_view string_view_value("0::0");
# else // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    std::experimental::string_view string_view_value("0::0");
# endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    addr1 = ip::make_address_v6(string_view_value);
    addr1 = ip::make_address_v6(string_view_value, ec);
#endif // defined(ASIO_HAS_STRING_VIEW)

    // address_v6 IPv4-mapped conversion.
#if defined(ASIO_NO_DEPRECATED)
    ip::address_v4 addr3;
#endif // defined(ASIO_NO_DEPRECATED)
    addr1 = ip::make_address_v6(ip::v4_mapped, addr3);
    addr3 = ip::make_address_v4(ip::v4_mapped, addr1);

    // address_v6 I/O.

    std::ostringstream os;
    os << addr1;

#if !defined(BOOST_NO_STD_WSTREAMBUF)
    std::wostringstream wos;
    wos << addr1;
#endif // !defined(BOOST_NO_STD_WSTREAMBUF)

#if defined(ASIO_HAS_STD_HASH)
    std::size_t hash1 = std::hash<ip::address_v6>()(addr1);
    (void)hash1;
#endif // defined(ASIO_HAS_STD_HASH)
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_address_v6_compile

//------------------------------------------------------------------------------

// ip_address_v6_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that the various public member functions meet the
// necessary postconditions.

namespace ip_address_v6_runtime {

void test()
{
  using asio::ip::address_v6;

  address_v6 a1;
  ASIO_CHECK(a1.is_unspecified());
  ASIO_CHECK(a1.scope_id() == 0);

  address_v6::bytes_type b1 = {{ 1, 2, 3, 4, 5,
    6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 }};
  address_v6 a2(b1, 12345);
  ASIO_CHECK(a2.to_bytes()[0] == 1);
  ASIO_CHECK(a2.to_bytes()[1] == 2);
  ASIO_CHECK(a2.to_bytes()[2] == 3);
  ASIO_CHECK(a2.to_bytes()[3] == 4);
  ASIO_CHECK(a2.to_bytes()[4] == 5);
  ASIO_CHECK(a2.to_bytes()[5] == 6);
  ASIO_CHECK(a2.to_bytes()[6] == 7);
  ASIO_CHECK(a2.to_bytes()[7] == 8);
  ASIO_CHECK(a2.to_bytes()[8] == 9);
  ASIO_CHECK(a2.to_bytes()[9] == 10);
  ASIO_CHECK(a2.to_bytes()[10] == 11);
  ASIO_CHECK(a2.to_bytes()[11] == 12);
  ASIO_CHECK(a2.to_bytes()[12] == 13);
  ASIO_CHECK(a2.to_bytes()[13] == 14);
  ASIO_CHECK(a2.to_bytes()[14] == 15);
  ASIO_CHECK(a2.to_bytes()[15] == 16);
  ASIO_CHECK(a2.scope_id() == 12345);

  address_v6 a3;
  a3.scope_id(12345);
  ASIO_CHECK(a3.scope_id() == 12345);

  address_v6 unspecified_address;
  address_v6::bytes_type loopback_bytes = {{ 0 }};
  loopback_bytes[15] = 1;
  address_v6 loopback_address(loopback_bytes);
  address_v6::bytes_type link_local_bytes = {{ 0xFE, 0x80, 1 }};
  address_v6 link_local_address(link_local_bytes);
  address_v6::bytes_type site_local_bytes = {{ 0xFE, 0xC0, 1 }};
  address_v6 site_local_address(site_local_bytes);
  address_v6::bytes_type v4_mapped_bytes = {{ 0 }};
  v4_mapped_bytes[10] = 0xFF, v4_mapped_bytes[11] = 0xFF;
  v4_mapped_bytes[12] = 1, v4_mapped_bytes[13] = 2;
  v4_mapped_bytes[14] = 3, v4_mapped_bytes[15] = 4;
  address_v6 v4_mapped_address(v4_mapped_bytes);
  address_v6::bytes_type v4_compat_bytes = {{ 0 }};
  v4_compat_bytes[12] = 1, v4_compat_bytes[13] = 2;
  v4_compat_bytes[14] = 3, v4_compat_bytes[15] = 4;
  address_v6 v4_compat_address(v4_compat_bytes);
  address_v6::bytes_type mcast_global_bytes = {{ 0xFF, 0x0E, 1 }};
  address_v6 mcast_global_address(mcast_global_bytes);
  address_v6::bytes_type mcast_link_local_bytes = {{ 0xFF, 0x02, 1 }};
  address_v6 mcast_link_local_address(mcast_link_local_bytes);
  address_v6::bytes_type mcast_node_local_bytes = {{ 0xFF, 0x01, 1 }};
  address_v6 mcast_node_local_address(mcast_node_local_bytes);
  address_v6::bytes_type mcast_org_local_bytes = {{ 0xFF, 0x08, 1 }};
  address_v6 mcast_org_local_address(mcast_org_local_bytes);
  address_v6::bytes_type mcast_site_local_bytes = {{ 0xFF, 0x05, 1 }};
  address_v6 mcast_site_local_address(mcast_site_local_bytes);

  ASIO_CHECK(!unspecified_address.is_loopback());
  ASIO_CHECK(loopback_address.is_loopback());
  ASIO_CHECK(!link_local_address.is_loopback());
  ASIO_CHECK(!site_local_address.is_loopback());
  ASIO_CHECK(!v4_mapped_address.is_loopback());
  ASIO_CHECK(!v4_compat_address.is_loopback());
  ASIO_CHECK(!mcast_global_address.is_loopback());
  ASIO_CHECK(!mcast_link_local_address.is_loopback());
  ASIO_CHECK(!mcast_node_local_address.is_loopback());
  ASIO_CHECK(!mcast_org_local_address.is_loopback());
  ASIO_CHECK(!mcast_site_local_address.is_loopback());

  ASIO_CHECK(unspecified_address.is_unspecified());
  ASIO_CHECK(!loopback_address.is_unspecified());
  ASIO_CHECK(!link_local_address.is_unspecified());
  ASIO_CHECK(!site_local_address.is_unspecified());
  ASIO_CHECK(!v4_mapped_address.is_unspecified());
  ASIO_CHECK(!v4_compat_address.is_unspecified());
  ASIO_CHECK(!mcast_global_address.is_unspecified());
  ASIO_CHECK(!mcast_link_local_address.is_unspecified());
  ASIO_CHECK(!mcast_node_local_address.is_unspecified());
  ASIO_CHECK(!mcast_org_local_address.is_unspecified());
  ASIO_CHECK(!mcast_site_local_address.is_unspecified());

  ASIO_CHECK(!unspecified_address.is_link_local());
  ASIO_CHECK(!loopback_address.is_link_local());
  ASIO_CHECK(link_local_address.is_link_local());
  ASIO_CHECK(!site_local_address.is_link_local());
  ASIO_CHECK(!v4_mapped_address.is_link_local());
  ASIO_CHECK(!v4_compat_address.is_link_local());
  ASIO_CHECK(!mcast_global_address.is_link_local());
  ASIO_CHECK(!mcast_link_local_address.is_link_local());
  ASIO_CHECK(!mcast_node_local_address.is_link_local());
  ASIO_CHECK(!mcast_org_local_address.is_link_local());
  ASIO_CHECK(!mcast_site_local_address.is_link_local());

  ASIO_CHECK(!unspecified_address.is_site_local());
  ASIO_CHECK(!loopback_address.is_site_local());
  ASIO_CHECK(!link_local_address.is_site_local());
  ASIO_CHECK(site_local_address.is_site_local());
  ASIO_CHECK(!v4_mapped_address.is_site_local());
  ASIO_CHECK(!v4_compat_address.is_site_local());
  ASIO_CHECK(!mcast_global_address.is_site_local());
  ASIO_CHECK(!mcast_link_local_address.is_site_local());
  ASIO_CHECK(!mcast_node_local_address.is_site_local());
  ASIO_CHECK(!mcast_org_local_address.is_site_local());
  ASIO_CHECK(!mcast_site_local_address.is_site_local());

  ASIO_CHECK(!unspecified_address.is_v4_mapped());
  ASIO_CHECK(!loopback_address.is_v4_mapped());
  ASIO_CHECK(!link_local_address.is_v4_mapped());
  ASIO_CHECK(!site_local_address.is_v4_mapped());
  ASIO_CHECK(v4_mapped_address.is_v4_mapped());
  ASIO_CHECK(!v4_compat_address.is_v4_mapped());
  ASIO_CHECK(!mcast_global_address.is_v4_mapped());
  ASIO_CHECK(!mcast_link_local_address.is_v4_mapped());
  ASIO_CHECK(!mcast_node_local_address.is_v4_mapped());
  ASIO_CHECK(!mcast_org_local_address.is_v4_mapped());
  ASIO_CHECK(!mcast_site_local_address.is_v4_mapped());

#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(!unspecified_address.is_v4_compatible());
  ASIO_CHECK(!loopback_address.is_v4_compatible());
  ASIO_CHECK(!link_local_address.is_v4_compatible());
  ASIO_CHECK(!site_local_address.is_v4_compatible());
  ASIO_CHECK(!v4_mapped_address.is_v4_compatible());
  ASIO_CHECK(v4_compat_address.is_v4_compatible());
  ASIO_CHECK(!mcast_global_address.is_v4_compatible());
  ASIO_CHECK(!mcast_link_local_address.is_v4_compatible());
  ASIO_CHECK(!mcast_node_local_address.is_v4_compatible());
  ASIO_CHECK(!mcast_org_local_address.is_v4_compatible());
  ASIO_CHECK(!mcast_site_local_address.is_v4_compatible());
#endif // !defined(ASIO_NO_DEPRECATED)

  ASIO_CHECK(!unspecified_address.is_multicast());
  ASIO_CHECK(!loopback_address.is_multicast());
  ASIO_CHECK(!link_local_address.is_multicast());
  ASIO_CHECK(!site_local_address.is_multicast());
  ASIO_CHECK(!v4_mapped_address.is_multicast());
  ASIO_CHECK(!v4_compat_address.is_multicast());
  ASIO_CHECK(mcast_global_address.is_multicast());
  ASIO_CHECK(mcast_link_local_address.is_multicast());
  ASIO_CHECK(mcast_node_local_address.is_multicast());
  ASIO_CHECK(mcast_org_local_address.is_multicast());
  ASIO_CHECK(mcast_site_local_address.is_multicast());

  ASIO_CHECK(!unspecified_address.is_multicast_global());
  ASIO_CHECK(!loopback_address.is_multicast_global());
  ASIO_CHECK(!link_local_address.is_multicast_global());
  ASIO_CHECK(!site_local_address.is_multicast_global());
  ASIO_CHECK(!v4_mapped_address.is_multicast_global());
  ASIO_CHECK(!v4_compat_address.is_multicast_global());
  ASIO_CHECK(mcast_global_address.is_multicast_global());
  ASIO_CHECK(!mcast_link_local_address.is_multicast_global());
  ASIO_CHECK(!mcast_node_local_address.is_multicast_global());
  ASIO_CHECK(!mcast_org_local_address.is_multicast_global());
  ASIO_CHECK(!mcast_site_local_address.is_multicast_global());

  ASIO_CHECK(!unspecified_address.is_multicast_link_local());
  ASIO_CHECK(!loopback_address.is_multicast_link_local());
  ASIO_CHECK(!link_local_address.is_multicast_link_local());
  ASIO_CHECK(!site_local_address.is_multicast_link_local());
  ASIO_CHECK(!v4_mapped_address.is_multicast_link_local());
  ASIO_CHECK(!v4_compat_address.is_multicast_link_local());
  ASIO_CHECK(!mcast_global_address.is_multicast_link_local());
  ASIO_CHECK(mcast_link_local_address.is_multicast_link_local());
  ASIO_CHECK(!mcast_node_local_address.is_multicast_link_local());
  ASIO_CHECK(!mcast_org_local_address.is_multicast_link_local());
  ASIO_CHECK(!mcast_site_local_address.is_multicast_link_local());

  ASIO_CHECK(!unspecified_address.is_multicast_node_local());
  ASIO_CHECK(!loopback_address.is_multicast_node_local());
  ASIO_CHECK(!link_local_address.is_multicast_node_local());
  ASIO_CHECK(!site_local_address.is_multicast_node_local());
  ASIO_CHECK(!v4_mapped_address.is_multicast_node_local());
  ASIO_CHECK(!v4_compat_address.is_multicast_node_local());
  ASIO_CHECK(!mcast_global_address.is_multicast_node_local());
  ASIO_CHECK(!mcast_link_local_address.is_multicast_node_local());
  ASIO_CHECK(mcast_node_local_address.is_multicast_node_local());
  ASIO_CHECK(!mcast_org_local_address.is_multicast_node_local());
  ASIO_CHECK(!mcast_site_local_address.is_multicast_node_local());

  ASIO_CHECK(!unspecified_address.is_multicast_org_local());
  ASIO_CHECK(!loopback_address.is_multicast_org_local());
  ASIO_CHECK(!link_local_address.is_multicast_org_local());
  ASIO_CHECK(!site_local_address.is_multicast_org_local());
  ASIO_CHECK(!v4_mapped_address.is_multicast_org_local());
  ASIO_CHECK(!v4_compat_address.is_multicast_org_local());
  ASIO_CHECK(!mcast_global_address.is_multicast_org_local());
  ASIO_CHECK(!mcast_link_local_address.is_multicast_org_local());
  ASIO_CHECK(!mcast_node_local_address.is_multicast_org_local());
  ASIO_CHECK(mcast_org_local_address.is_multicast_org_local());
  ASIO_CHECK(!mcast_site_local_address.is_multicast_org_local());

  ASIO_CHECK(!unspecified_address.is_multicast_site_local());
  ASIO_CHECK(!loopback_address.is_multicast_site_local());
  ASIO_CHECK(!link_local_address.is_multicast_site_local());
  ASIO_CHECK(!site_local_address.is_multicast_site_local());
  ASIO_CHECK(!v4_mapped_address.is_multicast_site_local());
  ASIO_CHECK(!v4_compat_address.is_multicast_site_local());
  ASIO_CHECK(!mcast_global_address.is_multicast_site_local());
  ASIO_CHECK(!mcast_link_local_address.is_multicast_site_local());
  ASIO_CHECK(!mcast_node_local_address.is_multicast_site_local());
  ASIO_CHECK(!mcast_org_local_address.is_multicast_site_local());
  ASIO_CHECK(mcast_site_local_address.is_multicast_site_local());

  ASIO_CHECK(address_v6::loopback().is_loopback());
}

} // namespace ip_address_v6_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address_v6",
  ASIO_COMPILE_TEST_CASE(ip_address_v6_compile::test)
  ASIO_TEST_CASE(ip_address_v6_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\address.cpp
//
// address.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/address.hpp"

#include "../unit_test.hpp"
#include <sstream>

//------------------------------------------------------------------------------

// ip_address_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::address compile and link correctly. Runtime failures are ignored.

namespace ip_address_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    asio::error_code ec;

    // address constructors.

    ip::address addr1;
    const ip::address_v4 const_addr_v4;
    ip::address addr2(const_addr_v4);
    const ip::address_v6 const_addr_v6;
    ip::address addr3(const_addr_v6);

    // address functions.

    bool b = addr1.is_v4();
    (void)b;

    b = addr1.is_v6();
    (void)b;

    b = addr1.is_loopback();
    (void)b;

    b = addr1.is_unspecified();
    (void)b;

    b = addr1.is_multicast();
    (void)b;

    ip::address_v4 addr_v4_value = addr1.to_v4();
    (void)addr_v4_value;

    ip::address_v6 addr_v6_value = addr1.to_v6();
    (void)addr_v6_value;

    std::string string_value = addr1.to_string();
#if !defined(ASIO_NO_DEPRECATED)
    string_value = addr1.to_string(ec);
#endif // !defined(ASIO_NO_DEPRECATED)

    // address static functions.

#if !defined(ASIO_NO_DEPRECATED)
    addr1 = ip::address::from_string("127.0.0.1");
    addr1 = ip::address::from_string("127.0.0.1", ec);
    addr1 = ip::address::from_string(string_value);
    addr1 = ip::address::from_string(string_value, ec);
#endif // !defined(ASIO_NO_DEPRECATED)

    // address comparisons.

    b = (addr1 == addr2);
    (void)b;

    b = (addr1 != addr2);
    (void)b;

    b = (addr1 < addr2);
    (void)b;

    b = (addr1 > addr2);
    (void)b;

    b = (addr1 <= addr2);
    (void)b;

    b = (addr1 >= addr2);
    (void)b;

    // address creation functions.

    addr1 = ip::make_address("127.0.0.1");
    addr1 = ip::make_address("127.0.0.1", ec);
    addr1 = ip::make_address(string_value);
    addr1 = ip::make_address(string_value, ec);
#if defined(ASIO_HAS_STRING_VIEW)
# if defined(ASIO_HAS_STD_STRING_VIEW)
    std::string_view string_view_value("127.0.0.1");
# elif defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    std::experimental::string_view string_view_value("127.0.0.1");
# endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    addr1 = ip::make_address(string_view_value);
    addr1 = ip::make_address(string_view_value, ec);
#endif // defined(ASIO_HAS_STRING_VIEW)

    // address I/O.

    std::ostringstream os;
    os << addr1;

#if !defined(BOOST_NO_STD_WSTREAMBUF)
    std::wostringstream wos;
    wos << addr1;
#endif // !defined(BOOST_NO_STD_WSTREAMBUF)

    std::size_t hash1 = std::hash<ip::address>()(addr1);
    (void)hash1;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_address_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/address",
  ASIO_COMPILE_TEST_CASE(ip_address_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\basic_endpoint.cpp
//
// basic_endpoint.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/basic_endpoint.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ip/basic_endpoint",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\basic_resolver_entry.cpp
//
// basic_resolver_entry.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/basic_resolver_entry.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ip/basic_resolver_entry",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\basic_resolver_iterator.cpp
//
// basic_resolver_iterator.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/basic_resolver_iterator.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ip/basic_resolver_iterator",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\basic_resolver_query.cpp
//
// basic_resolver_query.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/basic_resolver_query.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ip/basic_resolver_query",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\basic_resolver.cpp
//
// basic_resolver.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/basic_resolver.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ip/basic_resolver",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\host_name.cpp
//
// host_name.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/host_name.hpp"

#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// ip_host_name_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all host_name functions compile and link
// correctly. Runtime failures are ignored.

namespace ip_host_name_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    asio::error_code ec;

    std::string host_name = ip::host_name();
    std::string host_name2 = ip::host_name(ec);
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_host_name_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/host_name",
  ASIO_COMPILE_TEST_CASE(ip_host_name_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\icmp.cpp
//
// icmp.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/icmp.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "asio/placeholders.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"
#include "../archetypes/gettable_socket_option.hpp"
#include "../archetypes/io_control_command.hpp"
#include "../archetypes/settable_socket_option.hpp"

//------------------------------------------------------------------------------

// ip_icmp_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::icmp::socket compile and link correctly. Runtime failures are ignored.

namespace ip_icmp_socket_compile {

struct connect_handler
{
  connect_handler() {}
  void operator()(const asio::error_code&) {}
  connect_handler(connect_handler&&) {}
private:
  connect_handler(const connect_handler&);
};

struct send_handler
{
  send_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  send_handler(send_handler&&) {}
private:
  send_handler(const send_handler&);
};

struct receive_handler
{
  receive_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  receive_handler(receive_handler&&) {}
private:
  receive_handler(const receive_handler&);
};

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    archetypes::settable_socket_option<void> settable_socket_option1;
    archetypes::settable_socket_option<int> settable_socket_option2;
    archetypes::settable_socket_option<double> settable_socket_option3;
    archetypes::gettable_socket_option<void> gettable_socket_option1;
    archetypes::gettable_socket_option<int> gettable_socket_option2;
    archetypes::gettable_socket_option<double> gettable_socket_option3;
    archetypes::io_control_command io_control_command;
    archetypes::immediate_handler immediate;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_datagram_socket constructors.

    ip::icmp::socket socket1(ioc);
    ip::icmp::socket socket2(ioc, ip::icmp::v4());
    ip::icmp::socket socket3(ioc, ip::icmp::v6());
    ip::icmp::socket socket4(ioc, ip::icmp::endpoint(ip::icmp::v4(), 0));
    ip::icmp::socket socket5(ioc, ip::icmp::endpoint(ip::icmp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::icmp::socket::native_handle_type native_socket1
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    ip::icmp::socket socket6(ioc, ip::icmp::v4(), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::icmp::socket socket7(ioc_ex);
    ip::icmp::socket socket8(ioc_ex, ip::icmp::v4());
    ip::icmp::socket socket9(ioc_ex, ip::icmp::v6());
    ip::icmp::socket socket10(ioc_ex, ip::icmp::endpoint(ip::icmp::v4(), 0));
    ip::icmp::socket socket11(ioc_ex, ip::icmp::endpoint(ip::icmp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::icmp::socket::native_handle_type native_socket2
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    ip::icmp::socket socket12(ioc_ex, ip::icmp::v4(), native_socket2);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::icmp::socket socket13(std::move(socket6));

    // basic_datagram_socket operators.

    socket1 = ip::icmp::socket(ioc);
    socket1 = std::move(socket2);

    // basic_io_object functions.

    ip::icmp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    ip::icmp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    const ip::icmp::socket& socket14 = socket1;
    const ip::icmp::socket::lowest_layer_type& lowest_layer2
      = socket14.lowest_layer();
    (void)lowest_layer2;

    socket1.open(ip::icmp::v4());
    socket1.open(ip::icmp::v6());
    socket1.open(ip::icmp::v4(), ec);
    socket1.open(ip::icmp::v6(), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::icmp::socket::native_handle_type native_socket3
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    socket1.assign(ip::icmp::v4(), native_socket3);
    ip::icmp::socket::native_handle_type native_socket4
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    socket1.assign(ip::icmp::v4(), native_socket4, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    socket1.release();
    socket1.release(ec);

    ip::icmp::socket::native_handle_type native_socket5
      = socket1.native_handle();
    (void)native_socket5;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(ip::icmp::endpoint(ip::icmp::v4(), 0));
    socket1.bind(ip::icmp::endpoint(ip::icmp::v6(), 0));
    socket1.bind(ip::icmp::endpoint(ip::icmp::v4(), 0), ec);
    socket1.bind(ip::icmp::endpoint(ip::icmp::v6(), 0), ec);

    socket1.connect(ip::icmp::endpoint(ip::icmp::v4(), 0));
    socket1.connect(ip::icmp::endpoint(ip::icmp::v6(), 0));
    socket1.connect(ip::icmp::endpoint(ip::icmp::v4(), 0), ec);
    socket1.connect(ip::icmp::endpoint(ip::icmp::v6(), 0), ec);

    socket1.async_connect(ip::icmp::endpoint(ip::icmp::v4(), 0),
        connect_handler());
    socket1.async_connect(ip::icmp::endpoint(ip::icmp::v6(), 0),
        connect_handler());
    socket1.async_connect(ip::icmp::endpoint(ip::icmp::v4(), 0), immediate);
    socket1.async_connect(ip::icmp::endpoint(ip::icmp::v6(), 0), immediate);
    int i1 = socket1.async_connect(ip::icmp::endpoint(ip::icmp::v4(), 0), lazy);
    (void)i1;
    int i2 = socket1.async_connect(ip::icmp::endpoint(ip::icmp::v6(), 0), lazy);
    (void)i2;

    socket1.set_option(settable_socket_option1);
    socket1.set_option(settable_socket_option1, ec);
    socket1.set_option(settable_socket_option2);
    socket1.set_option(settable_socket_option2, ec);
    socket1.set_option(settable_socket_option3);
    socket1.set_option(settable_socket_option3, ec);

    socket1.get_option(gettable_socket_option1);
    socket1.get_option(gettable_socket_option1, ec);
    socket1.get_option(gettable_socket_option2);
    socket1.get_option(gettable_socket_option2, ec);
    socket1.get_option(gettable_socket_option3);
    socket1.get_option(gettable_socket_option3, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    bool non_blocking1 = socket1.non_blocking();
    (void)non_blocking1;
    socket1.non_blocking(true);
    socket1.non_blocking(false, ec);

    bool non_blocking2 = socket1.native_non_blocking();
    (void)non_blocking2;
    socket1.native_non_blocking(true);
    socket1.native_non_blocking(false, ec);

    ip::icmp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    ip::icmp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    ip::icmp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    ip::icmp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_datagram_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler());
    socket1.async_send(buffer(const_char_buffer), send_handler());
    socket1.async_send(null_buffers(), send_handler());
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler());
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler());
    socket1.async_send(null_buffers(), in_flags, send_handler());
    socket1.async_send(buffer(mutable_char_buffer), immediate);
    socket1.async_send(buffer(const_char_buffer), immediate);
    socket1.async_send(null_buffers(), immediate);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);
    int i3 = socket1.async_send(buffer(mutable_char_buffer), lazy);
    (void)i3;
    int i4 = socket1.async_send(buffer(const_char_buffer), lazy);
    (void)i4;
    int i5 = socket1.async_send(null_buffers(), lazy);
    (void)i5;
    int i6 = socket1.async_send(buffer(mutable_char_buffer), in_flags, lazy);
    (void)i6;
    int i7 = socket1.async_send(buffer(const_char_buffer), in_flags, lazy);
    (void)i7;
    int i8 = socket1.async_send(null_buffers(), in_flags, lazy);
    (void)i8;

    socket1.send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0));
    socket1.send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0));
    socket1.send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0));
    socket1.send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0));
    socket1.send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0));
    socket1.send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0));
    socket1.send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags);
    socket1.send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags);
    socket1.send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, ec);
    socket1.send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, ec);
    socket1.send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, ec);
    socket1.send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, ec);

    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), send_handler());
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), send_handler());
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, send_handler());
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, send_handler());
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), immediate);
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), immediate);
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, immediate);
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, immediate);
    socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, immediate);
    int i9 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), lazy);
    (void)i9;
    int i10 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), lazy);
    (void)i10;
    int i11 = socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), lazy);
    (void)i11;
    int i12 = socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), lazy);
    (void)i12;
    int i13 = socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), lazy);
    (void)i13;
    int i14 = socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), lazy);
    (void)i14;
    int i15 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, lazy);
    (void)i15;
    int i16 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, lazy);
    (void)i16;
    int i17 = socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, lazy);
    (void)i17;
    int i18 = socket1.async_send_to(buffer(const_char_buffer),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, lazy);
    (void)i18;
    int i19 = socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v4(), 0), in_flags, lazy);
    (void)i19;
    int i20 = socket1.async_send_to(null_buffers(),
        ip::icmp::endpoint(ip::icmp::v6(), 0), in_flags, lazy);
    (void)i20;

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler());
    socket1.async_receive(null_buffers(), receive_handler());
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler());
    socket1.async_receive(null_buffers(), in_flags, receive_handler());
    socket1.async_receive(buffer(mutable_char_buffer), immediate);
    socket1.async_receive(null_buffers(), immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_receive(null_buffers(), in_flags, immediate);
    int i21 = socket1.async_receive(buffer(mutable_char_buffer), lazy);
    (void)i21;
    int i22 = socket1.async_receive(null_buffers(), lazy);
    (void)i22;
    int i23 = socket1.async_receive(buffer(mutable_char_buffer),
        in_flags, lazy);
    (void)i23;
    int i24 = socket1.async_receive(null_buffers(), in_flags, lazy);
    (void)i24;

    ip::icmp::endpoint endpoint;
    socket1.receive_from(buffer(mutable_char_buffer), endpoint);
    socket1.receive_from(null_buffers(), endpoint);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags);
    socket1.receive_from(null_buffers(), endpoint, in_flags);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags, ec);
    socket1.receive_from(null_buffers(), endpoint, in_flags, ec);

    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, receive_handler());
    socket1.async_receive_from(null_buffers(),
        endpoint, receive_handler());
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, receive_handler());
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, receive_handler());
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, immediate);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, immediate);
    int i25 = socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, lazy);
    (void)i25;
    int i26 = socket1.async_receive_from(null_buffers(),
        endpoint, lazy);
    (void)i26;
    int i27 = socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, lazy);
    (void)i27;
    int i28 = socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, lazy);
    (void)i28;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_icmp_socket_compile

//------------------------------------------------------------------------------

// ip_icmp_resolver_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::icmp::resolver compile and link correctly. Runtime failures are ignored.

namespace ip_icmp_resolver_compile {

struct resolve_handler
{
  resolve_handler() {}
  void operator()(const asio::error_code&,
      asio::ip::icmp::resolver::results_type) {}
  resolve_handler(resolve_handler&&) {}
private:
  resolve_handler(const resolve_handler&);
};

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    archetypes::lazy_handler lazy;
    asio::error_code ec;
#if !defined(ASIO_NO_DEPRECATED)
    ip::icmp::resolver::query q(ip::icmp::v4(), "localhost", "0");
#endif // !defined(ASIO_NO_DEPRECATED)
    ip::icmp::endpoint e(ip::address_v4::loopback(), 0);

    // basic_resolver constructors.

    ip::icmp::resolver resolver(ioc);
    ip::icmp::resolver resolver2(ioc_ex);

    ip::icmp::resolver resolver3(std::move(resolver));

    // basic_resolver operators.

    resolver = ip::icmp::resolver(ioc);
    resolver = std::move(resolver3);

    // basic_io_object functions.

    ip::icmp::resolver::executor_type ex = resolver.get_executor();
    (void)ex;

    // basic_resolver functions.

    resolver.cancel();

#if !defined(ASIO_NO_DEPRECATED)
    ip::icmp::resolver::results_type results1 = resolver.resolve(q);
    (void)results1;

    ip::icmp::resolver::results_type results2 = resolver.resolve(q, ec);
    (void)results2;
#endif // !defined(ASIO_NO_DEPRECATED)

    ip::icmp::resolver::results_type results3 = resolver.resolve("", "");
    (void)results3;

    ip::icmp::resolver::results_type results4 = resolver.resolve("", "", ec);
    (void)results4;

    ip::icmp::resolver::results_type results5 =
      resolver.resolve("", "", ip::icmp::resolver::flags());
    (void)results5;

    ip::icmp::resolver::results_type results6 =
      resolver.resolve("", "", ip::icmp::resolver::flags(), ec);
    (void)results6;

    ip::icmp::resolver::results_type results7 =
      resolver.resolve(ip::icmp::v4(), "", "");
    (void)results7;

    ip::icmp::resolver::results_type results8 =
      resolver.resolve(ip::icmp::v4(), "", "", ec);
    (void)results8;

    ip::icmp::resolver::results_type results9 =
      resolver.resolve(ip::icmp::v4(), "", "", ip::icmp::resolver::flags());
    (void)results9;

    ip::icmp::resolver::results_type results10 =
      resolver.resolve(ip::icmp::v4(), "", "", ip::icmp::resolver::flags(), ec);
    (void)results10;

    ip::icmp::resolver::results_type results11 = resolver.resolve(e);
    (void)results11;

    ip::icmp::resolver::results_type results12 = resolver.resolve(e, ec);
    (void)results12;

#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve(q, resolve_handler());
    int i1 = resolver.async_resolve(q, lazy);
    (void)i1;
#endif // !defined(ASIO_NO_DEPRECATED)

    resolver.async_resolve("", "", resolve_handler());
    int i2 = resolver.async_resolve("", "", lazy);
    (void)i2;

    resolver.async_resolve("", "",
        ip::icmp::resolver::flags(), resolve_handler());
    int i3 = resolver.async_resolve("", "",
        ip::icmp::resolver::flags(), lazy);
    (void)i3;
    resolver.async_resolve(ip::icmp::v4(), "", "", resolve_handler());
    int i4 = resolver.async_resolve(ip::icmp::v4(), "", "", lazy);
    (void)i4;

    resolver.async_resolve(ip::icmp::v4(),
        "", "", ip::icmp::resolver::flags(), resolve_handler());
    int i5 = resolver.async_resolve(ip::icmp::v4(),
        "", "", ip::icmp::resolver::flags(), lazy);
    (void)i5;

    resolver.async_resolve(e, resolve_handler());
    int i6 = resolver.async_resolve(e, lazy);
    (void)i6;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_icmp_resolver_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/icmp",
  ASIO_COMPILE_TEST_CASE(ip_icmp_socket_compile::test)
  ASIO_COMPILE_TEST_CASE(ip_icmp_resolver_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\multicast.cpp
//
// multicast.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/multicast.hpp"

#include "asio/io_context.hpp"
#include "asio/ip/udp.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// ip_multicast_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all nested classes, enums and constants in
// ip::multicast compile and link correctly. Runtime failures are ignored.

namespace ip_multicast_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    ip::udp::socket sock(ioc);
    const ip::address address;
    const ip::address_v4 address_v4;
    const ip::address_v6 address_v6;

    // join_group class.

    ip::multicast::join_group join_group1;
    ip::multicast::join_group join_group2(address);
    ip::multicast::join_group join_group3(address_v4);
    ip::multicast::join_group join_group4(address_v4, address_v4);
    ip::multicast::join_group join_group5(address_v6);
    ip::multicast::join_group join_group6(address_v6, 1);
    sock.set_option(join_group6);

    // leave_group class.

    ip::multicast::leave_group leave_group1;
    ip::multicast::leave_group leave_group2(address);
    ip::multicast::leave_group leave_group3(address_v4);
    ip::multicast::leave_group leave_group4(address_v4, address_v4);
    ip::multicast::leave_group leave_group5(address_v6);
    ip::multicast::leave_group leave_group6(address_v6, 1);
    sock.set_option(leave_group6);

    // outbound_interface class.

    ip::multicast::outbound_interface outbound_interface1;
    ip::multicast::outbound_interface outbound_interface2(address_v4);
    ip::multicast::outbound_interface outbound_interface3(1);
    sock.set_option(outbound_interface3);

    // hops class.

    ip::multicast::hops hops1(1024);
    sock.set_option(hops1);
    ip::multicast::hops hops2;
    sock.get_option(hops2);
    hops1 = 1;
    (void)static_cast<int>(hops1.value());

    // enable_loopback class.

    ip::multicast::enable_loopback enable_loopback1(true);
    sock.set_option(enable_loopback1);
    ip::multicast::enable_loopback enable_loopback2;
    sock.get_option(enable_loopback2);
    enable_loopback1 = true;
    (void)static_cast<bool>(enable_loopback1);
    (void)static_cast<bool>(!enable_loopback1);
    (void)static_cast<bool>(enable_loopback1.value());
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_multicast_compile

//------------------------------------------------------------------------------

// ip_multicast_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the socket options defined
// in the ip::multicast namespace.

namespace ip_multicast_runtime {

#if defined(__hpux)
// HP-UX doesn't declare this function extern "C", so it is declared again here
// to avoid a linker error about an undefined symbol.
extern "C" unsigned int if_nametoindex(const char*);
#endif // defined(__hpux)

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  io_context ioc;
  asio::error_code ec;

  ip::udp::endpoint ep_v4(ip::address_v4::loopback(), 0);
  ip::udp::socket sock_v4(ioc);
  sock_v4.open(ep_v4.protocol(), ec);
  sock_v4.bind(ep_v4, ec);
  bool have_v4 = !ec;

  ip::udp::endpoint ep_v6(ip::address_v6::loopback(), 0);
  ip::udp::socket sock_v6(ioc);
  sock_v6.open(ep_v6.protocol(), ec);
  sock_v6.bind(ep_v6, ec);
  bool have_v6 = !ec;

  ASIO_CHECK(have_v4 || have_v6);

#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Windows CE seems to have problems with some multicast group addresses.
  // The following address works on CE, but as it is not a private multicast
  // address it will not be used on other platforms.
  const ip::address multicast_address_v4 = ip::make_address("239.0.0.4", ec);
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  const ip::address multicast_address_v4 = ip::make_address("239.255.0.1", ec);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK(!have_v4 || !ec);

#if (defined(__MACH__) && defined(__APPLE__)) \
  || defined(__FreeBSD__) \
  || defined(__NetBSD__) \
  || defined(__OpenBSD__)
  const ip::address multicast_address_v6 = ip::make_address("ff02::1%lo0", ec);
#else // (defined(__MACH__) && defined(__APPLE__))
      //   || defined(__FreeBSD__)
      //   || defined(__NetBSD__)
      //   || defined(__OpenBSD__)
  const ip::address multicast_address_v6 = ip::make_address("ff01::1", ec);
#endif // (defined(__MACH__) && defined(__APPLE__))
       //   || defined(__FreeBSD__)
       //   || defined(__NetBSD__)
       //   || defined(__OpenBSD__)
  ASIO_CHECK(!have_v6 || !ec);

  // join_group class.

  if (have_v4)
  {
    ip::multicast::join_group join_group(multicast_address_v4);
    sock_v4.set_option(join_group, ec);
    ASIO_CHECK_MESSAGE(!ec || ec == error::no_such_device,
                       ec.value() << ", " << ec.message());

    if (!ec)
    {
      // leave_group class.

      ip::multicast::leave_group leave_group(multicast_address_v4);
      sock_v4.set_option(leave_group, ec);
      ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    }
  }

  if (have_v6)
  {
    ip::multicast::join_group join_group(multicast_address_v6);
    sock_v6.set_option(join_group, ec);
    ASIO_CHECK_MESSAGE(!ec || ec == error::no_such_device,
                       ec.value() << ", " << ec.message());

    if (!ec)
    {
      // leave_group class.

      ip::multicast::leave_group leave_group(multicast_address_v6);
      sock_v6.set_option(leave_group, ec);
      ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    }
  }

  // outbound_interface class.

  if (have_v4)
  {
    ip::multicast::outbound_interface outbound_interface(
        ip::address_v4::loopback());
    sock_v4.set_option(outbound_interface, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  }

  if (have_v6)
  {
#if defined(__hpux)
    ip::multicast::outbound_interface outbound_interface(if_nametoindex("lo0"));
#else
    ip::multicast::outbound_interface outbound_interface(1);
#endif
    sock_v6.set_option(outbound_interface, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  }

  // hops class.

  if (have_v4)
  {
    ip::multicast::hops hops1(1);
    ASIO_CHECK(hops1.value() == 1);
    sock_v4.set_option(hops1, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

    ip::multicast::hops hops2;
    sock_v4.get_option(hops2, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(hops2.value() == 1);

    ip::multicast::hops hops3(0);
    ASIO_CHECK(hops3.value() == 0);
    sock_v4.set_option(hops3, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

    ip::multicast::hops hops4;
    sock_v4.get_option(hops4, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(hops4.value() == 0);
  }

  if (have_v6)
  {
    ip::multicast::hops hops1(1);
    ASIO_CHECK(hops1.value() == 1);
    sock_v6.set_option(hops1, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

    ip::multicast::hops hops2;
    sock_v6.get_option(hops2, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(hops2.value() == 1);

    ip::multicast::hops hops3(0);
    ASIO_CHECK(hops3.value() == 0);
    sock_v6.set_option(hops3, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

    ip::multicast::hops hops4;
    sock_v6.get_option(hops4, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(hops4.value() == 0);
  }

  // enable_loopback class.

  if (have_v4)
  {
    ip::multicast::enable_loopback enable_loopback1(true);
    ASIO_CHECK(enable_loopback1.value());
    ASIO_CHECK(static_cast<bool>(enable_loopback1));
    ASIO_CHECK(!!enable_loopback1);
    sock_v4.set_option(enable_loopback1, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Option is not supported under Windows CE.
    ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
        ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

    ip::multicast::enable_loopback enable_loopback2;
    sock_v4.get_option(enable_loopback2, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Not supported under Windows CE but can get value.
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(enable_loopback2.value());
    ASIO_CHECK(static_cast<bool>(enable_loopback2));
    ASIO_CHECK(!!enable_loopback2);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

    ip::multicast::enable_loopback enable_loopback3(false);
    ASIO_CHECK(!enable_loopback3.value());
    ASIO_CHECK(!static_cast<bool>(enable_loopback3));
    ASIO_CHECK(!enable_loopback3);
    sock_v4.set_option(enable_loopback3, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Option is not supported under Windows CE.
    ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
        ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

    ip::multicast::enable_loopback enable_loopback4;
    sock_v4.get_option(enable_loopback4, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Not supported under Windows CE but can get value.
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(!enable_loopback4.value());
    ASIO_CHECK(!static_cast<bool>(enable_loopback4));
    ASIO_CHECK(!enable_loopback4);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  }

  if (have_v6)
  {
    ip::multicast::enable_loopback enable_loopback1(true);
    ASIO_CHECK(enable_loopback1.value());
    ASIO_CHECK(static_cast<bool>(enable_loopback1));
    ASIO_CHECK(!!enable_loopback1);
    sock_v6.set_option(enable_loopback1, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

    ip::multicast::enable_loopback enable_loopback2;
    sock_v6.get_option(enable_loopback2, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(enable_loopback2.value());
    ASIO_CHECK(static_cast<bool>(enable_loopback2));
    ASIO_CHECK(!!enable_loopback2);

    ip::multicast::enable_loopback enable_loopback3(false);
    ASIO_CHECK(!enable_loopback3.value());
    ASIO_CHECK(!static_cast<bool>(enable_loopback3));
    ASIO_CHECK(!enable_loopback3);
    sock_v6.set_option(enable_loopback3, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

    ip::multicast::enable_loopback enable_loopback4;
    sock_v6.get_option(enable_loopback4, ec);
    ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
    ASIO_CHECK(!enable_loopback4.value());
    ASIO_CHECK(!static_cast<bool>(enable_loopback4));
    ASIO_CHECK(!enable_loopback4);
  }
}

} // namespace ip_multicast_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/multicast",
  ASIO_COMPILE_TEST_CASE(ip_multicast_compile::test)
  ASIO_TEST_CASE(ip_multicast_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\network_v4.cpp
//
// network_v4.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/network_v4.hpp"

#include "../unit_test.hpp"
#include <sstream>

//------------------------------------------------------------------------------

// ip_network_v4_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::network_v4 compile and link correctly. Runtime failures are ignored.

namespace ip_network_v4_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    asio::error_code ec;

    // network_v4 constructors.

    ip::network_v4 net1(ip::make_address_v4("192.168.1.0"), 32);
    ip::network_v4 net2(ip::make_address_v4("192.168.1.0"),
        ip::make_address_v4("255.255.255.0"));

    // network_v4 functions.

    ip::address_v4 addr1 = net1.address();
    (void)addr1;

    unsigned short prefix_len = net1.prefix_length();
    (void)prefix_len;

    ip::address_v4 addr2 = net1.netmask();
    (void)addr2;

    ip::address_v4 addr3 = net1.network();
    (void)addr3;

    ip::address_v4 addr4 = net1.broadcast();
    (void)addr4;

    ip::address_v4_range hosts = net1.hosts();
    (void)hosts;

    ip::network_v4 net3 = net1.canonical();
    (void)net3;

    bool b1 = net1.is_host();
    (void)b1;

    bool b2 = net1.is_subnet_of(net2);
    (void)b2;

    std::string s1 = net1.to_string();
    (void)s1;

    std::string s2 = net1.to_string(ec);
    (void)s2;

    // network_v4 comparisons.

    bool b3 = (net1 == net2);
    (void)b3;

    bool b4 = (net1 != net2);
    (void)b4;

    // network_v4 creation functions.

    net1 = ip::make_network_v4(ip::address_v4(), 24);
    net1 = ip::make_network_v4(ip::address_v4(), ip::address_v4());
    net1 = ip::make_network_v4("10.0.0.0/8");
    net1 = ip::make_network_v4("10.0.0.0/8", ec);
    net1 = ip::make_network_v4(s1);
    net1 = ip::make_network_v4(s1, ec);
#if defined(ASIO_HAS_STRING_VIEW)
# if defined(ASIO_HAS_STD_STRING_VIEW)
    std::string_view string_view_value("10.0.0.0/8");
# elif defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    std::experimental::string_view string_view_value("10.0.0.0/8");
# endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    net1 = ip::make_network_v4(string_view_value);
    net1 = ip::make_network_v4(string_view_value, ec);
#endif // defined(ASIO_HAS_STRING_VIEW)

    // network_v4 I/O.

    std::ostringstream os;
    os << net1;

#if !defined(BOOST_NO_STD_WSTREAMBUF)
    std::wostringstream wos;
    wos << net1;
#endif // !defined(BOOST_NO_STD_WSTREAMBUF)
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_network_v4_compile

//------------------------------------------------------------------------------

// ip_network_v4_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that the various public member functions meet the
// necessary postconditions.

namespace ip_network_v4_runtime {

void test()
{
  using asio::ip::address_v4;
  using asio::ip::make_address_v4;
  using asio::ip::network_v4;
  using asio::ip::make_network_v4;

  address_v4 addr = make_address_v4("1.2.3.4");

  // calculate prefix length

  network_v4 net1(addr, make_address_v4("255.255.255.0"));
  ASIO_CHECK(net1.prefix_length() == 24);

  network_v4 net2(addr, make_address_v4("255.255.255.192"));
  ASIO_CHECK(net2.prefix_length() == 26);

  network_v4 net3(addr, make_address_v4("128.0.0.0"));
  ASIO_CHECK(net3.prefix_length() == 1);

  std::string msg;
  try
  {
    make_network_v4(addr, make_address_v4("255.255.255.1"));
  }
  catch(std::exception& ex)
  {
    msg = ex.what();
  }
  ASIO_CHECK(msg == std::string("non-contiguous netmask"));

  msg.clear();
  try
  {
    make_network_v4(addr, make_address_v4("0.255.255.0"));
  }
  catch(std::exception& ex)
  {
    msg = ex.what();
  }
  ASIO_CHECK(msg == std::string("non-contiguous netmask"));

  // calculate netmask

  network_v4 net4(addr, 23);
  ASIO_CHECK(net4.netmask() == make_address_v4("255.255.254.0"));

  network_v4 net5(addr, 12);
  ASIO_CHECK(net5.netmask() == make_address_v4("255.240.0.0"));

  network_v4 net6(addr, 24);
  ASIO_CHECK(net6.netmask() == make_address_v4("255.255.255.0"));

  network_v4 net7(addr, 16);
  ASIO_CHECK(net7.netmask() == make_address_v4("255.255.0.0"));

  network_v4 net8(addr, 8);
  ASIO_CHECK(net8.netmask() == make_address_v4("255.0.0.0"));

  network_v4 net9(addr, 32);
  ASIO_CHECK(net9.netmask() == make_address_v4("255.255.255.255"));

  network_v4 net10(addr, 1);
  ASIO_CHECK(net10.netmask() == make_address_v4("128.0.0.0"));

  network_v4 net11(addr, 0);
  ASIO_CHECK(net11.netmask() == make_address_v4("0.0.0.0"));

  msg.clear();
  try
  {
    make_network_v4(addr, 33);
  }
  catch(std::out_of_range& ex)
  {
    msg = ex.what();
  }
  ASIO_CHECK(msg == std::string("prefix length too large"));

  // construct address range from address and prefix length
  ASIO_CHECK(network_v4(make_address_v4("192.168.77.100"), 32).network() == make_address_v4("192.168.77.100"));
  ASIO_CHECK(network_v4(make_address_v4("192.168.77.100"), 24).network() == make_address_v4("192.168.77.0"));
  ASIO_CHECK(network_v4(make_address_v4("192.168.77.128"), 25).network() == make_address_v4("192.168.77.128"));

  // construct address range from string in CIDR notation
  ASIO_CHECK(make_network_v4("192.168.77.100/32").network() == make_address_v4("192.168.77.100"));
  ASIO_CHECK(make_network_v4("192.168.77.100/24").network() == make_address_v4("192.168.77.0"));
  ASIO_CHECK(make_network_v4("192.168.77.128/25").network() == make_address_v4("192.168.77.128"));

  // construct network from invalid string
  asio::error_code ec;
  make_network_v4("10.0.0.256/24", ec);
  ASIO_CHECK(!!ec);
  make_network_v4("10.0.0.0/33", ec);
  ASIO_CHECK(!!ec);
  make_network_v4("10.0.0.0/-1", ec);
  ASIO_CHECK(!!ec);
  make_network_v4("10.0.0.0/", ec);
  ASIO_CHECK(!!ec);
  make_network_v4("10.0.0.0", ec);
  ASIO_CHECK(!!ec);

  // prefix length
  ASIO_CHECK(make_network_v4("193.99.144.80/24").prefix_length() == 24);
  ASIO_CHECK(network_v4(make_address_v4("193.99.144.80"), 24).prefix_length() == 24);
  ASIO_CHECK(network_v4(make_address_v4("192.168.77.0"), make_address_v4("255.255.255.0")).prefix_length() == 24);

  // to string
  std::string a("192.168.77.0/32");
  ASIO_CHECK(make_network_v4(a.c_str()).to_string() == a);
  ASIO_CHECK(network_v4(make_address_v4("192.168.77.10"), 24).to_string() == std::string("192.168.77.10/24"));

  // return host part
  ASIO_CHECK(make_network_v4("192.168.77.11/24").address() == make_address_v4("192.168.77.11"));

  // return host in CIDR notation
  ASIO_CHECK(make_network_v4("192.168.78.30/20").address().to_string() == "192.168.78.30");

  // return network in CIDR notation
  ASIO_CHECK(make_network_v4("192.168.78.30/20").canonical().to_string() == "192.168.64.0/20");

  // is host
  ASIO_CHECK(make_network_v4("192.168.77.0/32").is_host());
  ASIO_CHECK(!make_network_v4("192.168.77.0/31").is_host());

  // is real subnet of
  ASIO_CHECK(make_network_v4("192.168.0.192/24").is_subnet_of(make_network_v4("192.168.0.0/16")));
  ASIO_CHECK(make_network_v4("192.168.0.0/24").is_subnet_of(make_network_v4("192.168.192.168/16")));
  ASIO_CHECK(make_network_v4("192.168.0.192/24").is_subnet_of(make_network_v4("192.168.192.168/16")));
  ASIO_CHECK(make_network_v4("192.168.0.0/24").is_subnet_of(make_network_v4("192.168.0.0/16")));
  ASIO_CHECK(make_network_v4("192.168.0.0/24").is_subnet_of(make_network_v4("192.168.0.0/23")));
  ASIO_CHECK(make_network_v4("192.168.0.0/24").is_subnet_of(make_network_v4("192.168.0.0/0")));
  ASIO_CHECK(make_network_v4("192.168.0.0/32").is_subnet_of(make_network_v4("192.168.0.0/24")));

  ASIO_CHECK(!make_network_v4("192.168.0.0/32").is_subnet_of(make_network_v4("192.168.0.0/32")));
  ASIO_CHECK(!make_network_v4("192.168.0.0/24").is_subnet_of(make_network_v4("192.168.1.0/24")));
  ASIO_CHECK(!make_network_v4("192.168.0.0/16").is_subnet_of(make_network_v4("192.168.1.0/24")));

  network_v4 r(make_network_v4("192.168.0.0/24"));
  ASIO_CHECK(!r.is_subnet_of(r));

  network_v4 net12(make_network_v4("192.168.0.2/24"));
  network_v4 net13(make_network_v4("192.168.1.1/28"));
  network_v4 net14(make_network_v4("192.168.1.21/28"));
  // network
  ASIO_CHECK(net12.network() == make_address_v4("192.168.0.0"));
  ASIO_CHECK(net13.network() == make_address_v4("192.168.1.0"));
  ASIO_CHECK(net14.network() == make_address_v4("192.168.1.16"));
  // netmask
  ASIO_CHECK(net12.netmask() == make_address_v4("255.255.255.0"));
  ASIO_CHECK(net13.netmask() == make_address_v4("255.255.255.240"));
  ASIO_CHECK(net14.netmask() == make_address_v4("255.255.255.240"));
  // broadcast
  ASIO_CHECK(net12.broadcast() == make_address_v4("192.168.0.255"));
  ASIO_CHECK(net13.broadcast() == make_address_v4("192.168.1.15"));
  ASIO_CHECK(net14.broadcast() == make_address_v4("192.168.1.31"));
  // iterator
  ASIO_CHECK(std::distance(net12.hosts().begin(),net12.hosts().end()) == 254);
  ASIO_CHECK(*net12.hosts().begin() == make_address_v4("192.168.0.1"));
  ASIO_CHECK(net12.hosts().end() != net12.hosts().find(make_address_v4("192.168.0.10")));
  ASIO_CHECK(net12.hosts().end() == net12.hosts().find(make_address_v4("192.168.1.10")));
  ASIO_CHECK(std::distance(net13.hosts().begin(),net13.hosts().end()) == 14);
  ASIO_CHECK(*net13.hosts().begin() == make_address_v4("192.168.1.1"));
  ASIO_CHECK(net13.hosts().end() != net13.hosts().find(make_address_v4("192.168.1.14")));
  ASIO_CHECK(net13.hosts().end() == net13.hosts().find(make_address_v4("192.168.1.15")));
  ASIO_CHECK(std::distance(net14.hosts().begin(),net14.hosts().end()) == 14);
  ASIO_CHECK(*net14.hosts().begin() == make_address_v4("192.168.1.17"));
  ASIO_CHECK(net14.hosts().end() != net14.hosts().find(make_address_v4("192.168.1.30")));
  ASIO_CHECK(net14.hosts().end() == net14.hosts().find(make_address_v4("192.168.1.31")));
}

} // namespace ip_network_v4_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/network_v4",
  ASIO_COMPILE_TEST_CASE(ip_network_v4_compile::test)
  ASIO_TEST_CASE(ip_network_v4_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\network_v6.cpp
//
// network_v6.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2014 Oliver Kowalke (oliver dot kowalke at gmail dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/network_v6.hpp"

#include "../unit_test.hpp"
#include <sstream>

//------------------------------------------------------------------------------

// ip_network_v6_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::network_v6 compile and link correctly. Runtime failures are ignored.

namespace ip_network_v6_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    asio::error_code ec;

    // network_v6 constructors.

    ip::network_v6 net1(ip::make_address_v6("2001:370::10:7344"), 64);
    ip::network_v6 net2(ip::make_address_v6("2001:370::10:7345"), 96);

    // network_v6 functions.

    ip::address_v6 addr1 = net1.address();
    (void)addr1;

    unsigned short prefix_len = net1.prefix_length();
    (void)prefix_len;

    ip::address_v6 addr3 = net1.network();
    (void)addr3;

    ip::address_v6_range hosts = net1.hosts();
    (void)hosts;

    ip::network_v6 net3 = net1.canonical();
    (void)net3;

    bool b1 = net1.is_host();
    (void)b1;

    bool b2 = net1.is_subnet_of(net2);
    (void)b2;

    std::string s1 = net1.to_string();
    (void)s1;

    std::string s2 = net1.to_string(ec);
    (void)s2;

    // network_v6 comparisons.

    bool b3 = (net1 == net2);
    (void)b3;

    bool b4 = (net1 != net2);
    (void)b4;

    // network_v6 creation functions.

    net1 = ip::make_network_v6(ip::address_v6(), 24);
    net1 = ip::make_network_v6("10.0.0.0/8");
    net1 = ip::make_network_v6("10.0.0.0/8", ec);
    net1 = ip::make_network_v6(s1);
    net1 = ip::make_network_v6(s1, ec);
#if defined(ASIO_HAS_STRING_VIEW)
# if defined(ASIO_HAS_STD_STRING_VIEW)
    std::string_view string_view_value("0::0/8");
# elif defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    std::experimental::string_view string_view_value("0::0/8");
# endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    net1 = ip::make_network_v6(string_view_value);
    net1 = ip::make_network_v6(string_view_value, ec);
#endif // defined(ASIO_STD_STRING_VIEW)

    // network_v6 I/O.

    std::ostringstream os;
    os << net1;

#if !defined(BOOST_NO_STD_WSTREAMBUF)
    std::wostringstream wos;
    wos << net1;
#endif // !defined(BOOST_NO_STD_WSTREAMBUF)
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_network_v6_compile

//------------------------------------------------------------------------------

// ip_network_v6_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that the various public member functions meet the
// necessary postconditions.

namespace ip_network_v6_runtime {

void test()
{
  using asio::ip::address_v6;
  using asio::ip::make_address_v6;
  using asio::ip::network_v6;
  using asio::ip::make_network_v6;

  address_v6 addr = make_address_v6("2001:370::10:7344");

  std::string msg;
  try
  {
    make_network_v6(addr, 129);
  }
  catch(std::out_of_range& ex)
  {
    msg = ex.what();
  }
  ASIO_CHECK(msg == std::string("prefix length too large"));

  // construct address range from address and prefix length
  ASIO_CHECK(network_v6(make_address_v6("2001:370::10:7344"), 128).network() == make_address_v6("2001:370::10:7344"));
  ASIO_CHECK(network_v6(make_address_v6("2001:370::10:7344"), 64).network() == make_address_v6("2001:370::"));
  ASIO_CHECK(network_v6(make_address_v6("2001:370::10:7344"), 27).network() == make_address_v6("2001:360::"));

  // construct address range from string in CIDR notation
  ASIO_CHECK(make_network_v6("2001:370::10:7344/128").network() == make_address_v6("2001:370::10:7344"));
  ASIO_CHECK(make_network_v6("2001:370::10:7344/64").network() == make_address_v6("2001:370::"));
  ASIO_CHECK(make_network_v6("2001:370::10:7344/27").network() == make_address_v6("2001:360::"));

  // construct network from invalid string
  asio::error_code ec;
  make_network_v6("a:b/24", ec);
  ASIO_CHECK(!!ec);
  make_network_v6("2001:370::10:7344/129", ec);
  ASIO_CHECK(!!ec);
  make_network_v6("2001:370::10:7344/-1", ec);
  ASIO_CHECK(!!ec);
  make_network_v6("2001:370::10:7344/", ec);
  ASIO_CHECK(!!ec);
  make_network_v6("2001:370::10:7344", ec);
  ASIO_CHECK(!!ec);

  // prefix length
  ASIO_CHECK(make_network_v6("2001:370::10:7344/128").prefix_length() == 128);
  ASIO_CHECK(network_v6(make_address_v6("2001:370::10:7344"), 27).prefix_length() == 27);

  // to string
  std::string a("2001:370::10:7344/64");
  ASIO_CHECK(make_network_v6(a.c_str()).to_string() == a);
  ASIO_CHECK(network_v6(make_address_v6("2001:370::10:7344"), 27).to_string() == std::string("2001:370::10:7344/27"));

  // return host part
  ASIO_CHECK(make_network_v6("2001:370::10:7344/64").address() == make_address_v6("2001:370::10:7344"));
  ASIO_CHECK(make_network_v6("2001:370::10:7344/27").address().to_string() == "2001:370::10:7344");

  // return network in CIDR notation
  ASIO_CHECK(make_network_v6("2001:370::10:7344/27").canonical().to_string() == "2001:360::/27");

  // is host
  ASIO_CHECK(make_network_v6("2001:370::10:7344/128").is_host());
  ASIO_CHECK(!make_network_v6("2001:370::10:7344/127").is_host());

  // is real subnet of
  ASIO_CHECK(make_network_v6("2001:370::10:3744/64").is_subnet_of(make_network_v6("2001:370::/16")));
  ASIO_CHECK(make_network_v6("2001:370::/64").is_subnet_of(make_network_v6("2001:370::/16")));
  ASIO_CHECK(make_network_v6("2001:0db8:85a3::/64").is_subnet_of(make_network_v6("2001:0d00::/24")));

  ASIO_CHECK(!make_network_v6("2001:370::10:3744/128").is_subnet_of(make_network_v6("2001:370::10:3744/128")));
  ASIO_CHECK(make_network_v6("2001:0db8:85a3::/64").is_subnet_of(make_network_v6("2001:0dc0::/24")));

  network_v6 r(make_network_v6("2001:370::/64"));
  ASIO_CHECK(!r.is_subnet_of(r));

  network_v6 net12(make_network_v6("2001:370::10:7344/64"));
  network_v6 net13(make_network_v6("2001:0db8::/127"));
  network_v6 net14(make_network_v6("2001:0db8::/125"));
  network_v6 net15(make_network_v6("2001:0db8::/119"));

  // network
  ASIO_CHECK(net12.network() == make_address_v6("2001:370::"));
  ASIO_CHECK(net13.network() == make_address_v6("2001:0db8::"));
  ASIO_CHECK(net14.network() == make_address_v6("2001:0db8::"));
  ASIO_CHECK(net15.network() == make_address_v6("2001:0db8::"));

  // iterator
  //ASIO_CHECK(std::distance(net12.hosts().begin(),net12.hosts().end()) == 18446744073709552000);
  ASIO_CHECK(std::distance(net13.hosts().begin(),net13.hosts().end()) == 2);
  ASIO_CHECK(std::distance(net14.hosts().begin(),net14.hosts().end()) == 8);
  ASIO_CHECK(std::distance(net15.hosts().begin(),net15.hosts().end()) == 512);
  ASIO_CHECK(*net12.hosts().begin() == make_address_v6("2001:0370::"));
  ASIO_CHECK(net12.hosts().end() != net12.hosts().find(make_address_v6("2001:0370::ffff:ffff:ffff:ffff")));
  ASIO_CHECK(*net13.hosts().begin() == make_address_v6("2001:0db8::"));
  ASIO_CHECK(net13.hosts().end() != net13.hosts().find(make_address_v6("2001:0db8::1")));
  ASIO_CHECK(net13.hosts().end() == net13.hosts().find(make_address_v6("2001:0db8::2")));
  ASIO_CHECK(*net14.hosts().begin() == make_address_v6("2001:0db8::"));
  ASIO_CHECK(net14.hosts().end() != net14.hosts().find(make_address_v6("2001:0db8::7")));
  ASIO_CHECK(net14.hosts().end() == net14.hosts().find(make_address_v6("2001:0db8::8")));
  ASIO_CHECK(*net15.hosts().begin() == make_address_v6("2001:0db8::"));
  ASIO_CHECK(net15.hosts().end() != net15.hosts().find(make_address_v6("2001:0db8::01ff")));
  ASIO_CHECK(net15.hosts().end() == net15.hosts().find(make_address_v6("2001:0db8::0200")));
}

} // namespace ip_network_v6_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/network_v6",
  ASIO_COMPILE_TEST_CASE(ip_network_v6_compile::test)
  ASIO_TEST_CASE(ip_network_v6_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\resolver_query_base.cpp
//
// resolver_query_base.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/resolver_query_base.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ip/resolver_query_base",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\tcp.cpp
//
// tcp.cpp
// ~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Enable cancel() support on Windows.
#define ASIO_ENABLE_CANCELIO 1

// Test that header file is self-contained.
#include "asio/ip/tcp.hpp"

#include <cstring>
#include <functional>
#include "asio/io_context.hpp"
#include "asio/read.hpp"
#include "asio/write.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"
#include "../archetypes/gettable_socket_option.hpp"
#include "../archetypes/io_control_command.hpp"
#include "../archetypes/settable_socket_option.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
# include <boost/array.hpp>
#else // defined(ASIO_HAS_BOOST_ARRAY)
# include <array>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

//------------------------------------------------------------------------------

// ip_tcp_compile test
// ~~~~~~~~~~~~~~~~~~~
// The following test checks that all nested classes, enums and constants in
// ip::tcp compile and link correctly. Runtime failures are ignored.

namespace ip_tcp_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    ip::tcp::socket sock(ioc);

    // no_delay class.

    ip::tcp::no_delay no_delay1(true);
    sock.set_option(no_delay1);
    ip::tcp::no_delay no_delay2;
    sock.get_option(no_delay2);
    no_delay1 = true;
    (void)static_cast<bool>(no_delay1);
    (void)static_cast<bool>(!no_delay1);
    (void)static_cast<bool>(no_delay1.value());

    ip::tcp::endpoint ep;
    (void)static_cast<std::size_t>(std::hash<ip::tcp::endpoint>()(ep));
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_tcp_compile

//------------------------------------------------------------------------------

// ip_tcp_runtime test
// ~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the ip::tcp class.

namespace ip_tcp_runtime {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  io_context ioc;
  ip::tcp::socket sock(ioc, ip::tcp::v4());
  asio::error_code ec;

  // no_delay class.

  ip::tcp::no_delay no_delay1(true);
  ASIO_CHECK(no_delay1.value());
  ASIO_CHECK(static_cast<bool>(no_delay1));
  ASIO_CHECK(!!no_delay1);
  sock.set_option(no_delay1, ec);
  ASIO_CHECK(!ec);

  ip::tcp::no_delay no_delay2;
  sock.get_option(no_delay2, ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(no_delay2.value());
  ASIO_CHECK(static_cast<bool>(no_delay2));
  ASIO_CHECK(!!no_delay2);

  ip::tcp::no_delay no_delay3(false);
  ASIO_CHECK(!no_delay3.value());
  ASIO_CHECK(!static_cast<bool>(no_delay3));
  ASIO_CHECK(!no_delay3);
  sock.set_option(no_delay3, ec);
  ASIO_CHECK(!ec);

  ip::tcp::no_delay no_delay4;
  sock.get_option(no_delay4, ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(!no_delay4.value());
  ASIO_CHECK(!static_cast<bool>(no_delay4));
  ASIO_CHECK(!no_delay4);
}

} // namespace ip_tcp_runtime

//------------------------------------------------------------------------------

// ip_tcp_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::tcp::socket compile and link correctly. Runtime failures are ignored.

namespace ip_tcp_socket_compile {

struct connect_handler
{
  connect_handler() {}
  void operator()(const asio::error_code&) {}
  connect_handler(connect_handler&&) {}
private:
  connect_handler(const connect_handler&);
};

struct wait_handler
{
  wait_handler() {}
  void operator()(const asio::error_code&) {}
  wait_handler(wait_handler&&) {}
private:
  wait_handler(const wait_handler&);
};

struct send_handler
{
  send_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  send_handler(send_handler&&) {}
private:
  send_handler(const send_handler&);
};

struct receive_handler
{
  receive_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  receive_handler(receive_handler&&) {}
private:
  receive_handler(const receive_handler&);
};

struct write_some_handler
{
  write_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  write_some_handler(write_some_handler&&) {}
private:
  write_some_handler(const write_some_handler&);
};

struct read_some_handler
{
  read_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  read_some_handler(read_some_handler&&) {}
private:
  read_some_handler(const read_some_handler&);
};

void test()
{
#if defined(ASIO_HAS_BOOST_ARRAY)
  using boost::array;
#else // defined(ASIO_HAS_BOOST_ARRAY)
  using std::array;
#endif // defined(ASIO_HAS_BOOST_ARRAY)

  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    array<asio::mutable_buffer, 2> mutable_buffers = {{
        asio::buffer(mutable_char_buffer, 10),
        asio::buffer(mutable_char_buffer + 10, 10) }};
    array<asio::const_buffer, 2> const_buffers = {{
        asio::buffer(const_char_buffer, 10),
        asio::buffer(const_char_buffer + 10, 10) }};
    socket_base::message_flags in_flags = 0;
    archetypes::settable_socket_option<void> settable_socket_option1;
    archetypes::settable_socket_option<int> settable_socket_option2;
    archetypes::settable_socket_option<double> settable_socket_option3;
    archetypes::gettable_socket_option<void> gettable_socket_option1;
    archetypes::gettable_socket_option<int> gettable_socket_option2;
    archetypes::gettable_socket_option<double> gettable_socket_option3;
    archetypes::io_control_command io_control_command;
    archetypes::immediate_handler immediate;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_stream_socket constructors.

    ip::tcp::socket socket1(ioc);
    ip::tcp::socket socket2(ioc, ip::tcp::v4());
    ip::tcp::socket socket3(ioc, ip::tcp::v6());
    ip::tcp::socket socket4(ioc, ip::tcp::endpoint(ip::tcp::v4(), 0));
    ip::tcp::socket socket5(ioc, ip::tcp::endpoint(ip::tcp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::tcp::socket::native_handle_type native_socket1
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    ip::tcp::socket socket6(ioc, ip::tcp::v4(), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::tcp::socket socket7(ioc_ex);
    ip::tcp::socket socket8(ioc_ex, ip::tcp::v4());
    ip::tcp::socket socket9(ioc_ex, ip::tcp::v6());
    ip::tcp::socket socket10(ioc_ex, ip::tcp::endpoint(ip::tcp::v4(), 0));
    ip::tcp::socket socket11(ioc_ex, ip::tcp::endpoint(ip::tcp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::tcp::socket::native_handle_type native_socket2
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    ip::tcp::socket socket12(ioc_ex, ip::tcp::v4(), native_socket2);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::tcp::socket socket13(std::move(socket5));

    // basic_stream_socket operators.

    socket1 = ip::tcp::socket(ioc);
    socket1 = std::move(socket2);

    // basic_io_object functions.

    ip::tcp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    ip::tcp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    const ip::tcp::socket& socket14 = socket1;
    const ip::tcp::socket::lowest_layer_type& lowest_layer2
      = socket14.lowest_layer();
    (void)lowest_layer2;

    socket1.open(ip::tcp::v4());
    socket1.open(ip::tcp::v6());
    socket1.open(ip::tcp::v4(), ec);
    socket1.open(ip::tcp::v6(), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::tcp::socket::native_handle_type native_socket3
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    socket1.assign(ip::tcp::v4(), native_socket3);
    ip::tcp::socket::native_handle_type native_socket4
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    socket1.assign(ip::tcp::v4(), native_socket4, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    socket1.release();
    socket1.release(ec);

    ip::tcp::socket::native_handle_type native_socket5
      = socket1.native_handle();
    (void)native_socket5;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(ip::tcp::endpoint(ip::tcp::v4(), 0));
    socket1.bind(ip::tcp::endpoint(ip::tcp::v6(), 0));
    socket1.bind(ip::tcp::endpoint(ip::tcp::v4(), 0), ec);
    socket1.bind(ip::tcp::endpoint(ip::tcp::v6(), 0), ec);

    socket1.connect(ip::tcp::endpoint(ip::tcp::v4(), 0));
    socket1.connect(ip::tcp::endpoint(ip::tcp::v6(), 0));
    socket1.connect(ip::tcp::endpoint(ip::tcp::v4(), 0), ec);
    socket1.connect(ip::tcp::endpoint(ip::tcp::v6(), 0), ec);

    socket1.async_connect(ip::tcp::endpoint(ip::tcp::v4(), 0),
        connect_handler());
    socket1.async_connect(ip::tcp::endpoint(ip::tcp::v6(), 0),
        connect_handler());
    socket1.async_connect(ip::tcp::endpoint(ip::tcp::v4(), 0), immediate);
    socket1.async_connect(ip::tcp::endpoint(ip::tcp::v6(), 0), immediate);
    int i1 = socket1.async_connect(ip::tcp::endpoint(ip::tcp::v4(), 0), lazy);
    (void)i1;
    int i2 = socket1.async_connect(ip::tcp::endpoint(ip::tcp::v6(), 0), lazy);
    (void)i2;

    socket1.set_option(settable_socket_option1);
    socket1.set_option(settable_socket_option1, ec);
    socket1.set_option(settable_socket_option2);
    socket1.set_option(settable_socket_option2, ec);
    socket1.set_option(settable_socket_option3);
    socket1.set_option(settable_socket_option3, ec);

    socket1.get_option(gettable_socket_option1);
    socket1.get_option(gettable_socket_option1, ec);
    socket1.get_option(gettable_socket_option2);
    socket1.get_option(gettable_socket_option2, ec);
    socket1.get_option(gettable_socket_option3);
    socket1.get_option(gettable_socket_option3, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    bool non_blocking1 = socket1.non_blocking();
    (void)non_blocking1;
    socket1.non_blocking(true);
    socket1.non_blocking(false, ec);

    bool non_blocking2 = socket1.native_non_blocking();
    (void)non_blocking2;
    socket1.native_non_blocking(true);
    socket1.native_non_blocking(false, ec);

    ip::tcp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    ip::tcp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    ip::tcp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    ip::tcp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    socket1.wait(socket_base::wait_read);
    socket1.wait(socket_base::wait_write, ec);

    socket1.async_wait(socket_base::wait_read, wait_handler());
    socket1.async_wait(socket_base::wait_read, immediate);
    int i3 = socket1.async_wait(socket_base::wait_write, lazy);
    (void)i3;

    // basic_stream_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(mutable_buffers);
    socket1.send(const_buffers);
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(mutable_buffers, in_flags);
    socket1.send(const_buffers, in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(mutable_buffers, in_flags, ec);
    socket1.send(const_buffers, in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler());
    socket1.async_send(buffer(const_char_buffer), send_handler());
    socket1.async_send(mutable_buffers, send_handler());
    socket1.async_send(const_buffers, send_handler());
    socket1.async_send(null_buffers(), send_handler());
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler());
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler());
    socket1.async_send(mutable_buffers, in_flags, send_handler());
    socket1.async_send(const_buffers, in_flags, send_handler());
    socket1.async_send(null_buffers(), in_flags, send_handler());
    socket1.async_send(buffer(mutable_char_buffer), immediate);
    socket1.async_send(buffer(const_char_buffer), immediate);
    socket1.async_send(mutable_buffers, immediate);
    socket1.async_send(const_buffers, immediate);
    socket1.async_send(null_buffers(), immediate);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(mutable_buffers, in_flags, immediate);
    socket1.async_send(const_buffers, in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);
    int i4 = socket1.async_send(buffer(mutable_char_buffer), lazy);
    (void)i4;
    int i5 = socket1.async_send(buffer(const_char_buffer), lazy);
    (void)i5;
    int i6 = socket1.async_send(mutable_buffers, lazy);
    (void)i6;
    int i7 = socket1.async_send(const_buffers, lazy);
    (void)i7;
    int i8 = socket1.async_send(null_buffers(), lazy);
    (void)i8;
    int i9 = socket1.async_send(buffer(mutable_char_buffer), in_flags, lazy);
    (void)i9;
    int i10 = socket1.async_send(buffer(const_char_buffer), in_flags, lazy);
    (void)i10;
    int i11 = socket1.async_send(mutable_buffers, in_flags, lazy);
    (void)i11;
    int i12 = socket1.async_send(const_buffers, in_flags, lazy);
    (void)i12;
    int i13 = socket1.async_send(null_buffers(), in_flags, lazy);
    (void)i13;

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(mutable_buffers);
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(mutable_buffers, in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(mutable_buffers, in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler());
    socket1.async_receive(mutable_buffers, receive_handler());
    socket1.async_receive(null_buffers(), receive_handler());
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler());
    socket1.async_receive(mutable_buffers, in_flags, receive_handler());
    socket1.async_receive(null_buffers(), in_flags, receive_handler());
    socket1.async_receive(buffer(mutable_char_buffer), immediate);
    socket1.async_receive(mutable_buffers, immediate);
    socket1.async_receive(null_buffers(), immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_receive(mutable_buffers, in_flags, immediate);
    socket1.async_receive(null_buffers(), in_flags, immediate);
    int i14 = socket1.async_receive(buffer(mutable_char_buffer), lazy);
    (void)i14;
    int i15 = socket1.async_receive(mutable_buffers, lazy);
    (void)i15;
    int i16 = socket1.async_receive(null_buffers(), lazy);
    (void)i16;
    int i17 = socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        lazy);
    (void)i17;
    int i18 = socket1.async_receive(mutable_buffers, in_flags, lazy);
    (void)i18;
    int i19 = socket1.async_receive(null_buffers(), in_flags, lazy);
    (void)i19;

    socket1.write_some(buffer(mutable_char_buffer));
    socket1.write_some(buffer(const_char_buffer));
    socket1.write_some(mutable_buffers);
    socket1.write_some(const_buffers);
    socket1.write_some(null_buffers());
    socket1.write_some(buffer(mutable_char_buffer), ec);
    socket1.write_some(buffer(const_char_buffer), ec);
    socket1.write_some(mutable_buffers, ec);
    socket1.write_some(const_buffers, ec);
    socket1.write_some(null_buffers(), ec);

    socket1.async_write_some(buffer(mutable_char_buffer), write_some_handler());
    socket1.async_write_some(buffer(const_char_buffer), write_some_handler());
    socket1.async_write_some(mutable_buffers, write_some_handler());
    socket1.async_write_some(const_buffers, write_some_handler());
    socket1.async_write_some(null_buffers(), write_some_handler());
    socket1.async_write_some(buffer(mutable_char_buffer), immediate);
    socket1.async_write_some(buffer(const_char_buffer), immediate);
    socket1.async_write_some(mutable_buffers, immediate);
    socket1.async_write_some(const_buffers, immediate);
    socket1.async_write_some(null_buffers(), immediate);
    int i20 = socket1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i20;
    int i21 = socket1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i21;
    int i22 = socket1.async_write_some(mutable_buffers, lazy);
    (void)i22;
    int i23 = socket1.async_write_some(const_buffers, lazy);
    (void)i23;
    int i24 = socket1.async_write_some(null_buffers(), lazy);
    (void)i24;

    socket1.read_some(buffer(mutable_char_buffer));
    socket1.read_some(mutable_buffers);
    socket1.read_some(null_buffers());
    socket1.read_some(buffer(mutable_char_buffer), ec);
    socket1.read_some(mutable_buffers, ec);
    socket1.read_some(null_buffers(), ec);

    socket1.async_read_some(buffer(mutable_char_buffer), read_some_handler());
    socket1.async_read_some(mutable_buffers, read_some_handler());
    socket1.async_read_some(null_buffers(), read_some_handler());
    socket1.async_read_some(buffer(mutable_char_buffer), immediate);
    socket1.async_read_some(mutable_buffers, immediate);
    socket1.async_read_some(null_buffers(), immediate);
    int i25 = socket1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i25;
    int i26 = socket1.async_read_some(mutable_buffers, lazy);
    (void)i26;
    int i27 = socket1.async_read_some(null_buffers(), lazy);
    (void)i27;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_tcp_socket_compile

//------------------------------------------------------------------------------

// ip_tcp_socket_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the ip::tcp::socket class.

namespace ip_tcp_socket_runtime {

static const char write_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void handle_read_noop(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!err);
  ASIO_CHECK(bytes_transferred == 0);
}

void handle_write_noop(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!err);
  ASIO_CHECK(bytes_transferred == 0);
}

void handle_read(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!err);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
}

void handle_write(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!err);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
}

void handle_read_cancel(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(err == asio::error::operation_aborted);
  ASIO_CHECK(bytes_transferred == 0);
}

void handle_read_eof(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(err == asio::error::eof);
  ASIO_CHECK(bytes_transferred == 0);
}

void test()
{
  using namespace std; // For memcmp.
  using namespace asio;
  namespace ip = asio::ip;

  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  io_context ioc;

  ip::tcp::acceptor acceptor(ioc, ip::tcp::endpoint(ip::tcp::v4(), 0));
  ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(ip::address_v4::loopback());

  ip::tcp::socket client_side_socket(ioc);
  ip::tcp::socket server_side_socket(ioc);

  client_side_socket.connect(server_endpoint);
  acceptor.accept(server_side_socket);

  // No-op read.

  bool read_noop_completed = false;
  client_side_socket.async_read_some(
      asio::mutable_buffer(0, 0),
      bindns::bind(handle_read_noop,
        _1, _2, &read_noop_completed));

  ioc.run();
  ASIO_CHECK(read_noop_completed);

  // No-op write.

  bool write_noop_completed = false;
  client_side_socket.async_write_some(
      asio::const_buffer(0, 0),
      bindns::bind(handle_write_noop,
        _1, _2, &write_noop_completed));

  ioc.restart();
  ioc.run();
  ASIO_CHECK(write_noop_completed);

  // Read and write to transfer data.

  char read_buffer[sizeof(write_data)];
  bool read_completed = false;
  asio::async_read(client_side_socket,
      asio::buffer(read_buffer),
      bindns::bind(handle_read,
        _1, _2, &read_completed));

  bool write_completed = false;
  asio::async_write(server_side_socket,
      asio::buffer(write_data),
      bindns::bind(handle_write,
        _1, _2, &write_completed));

  ioc.restart();
  ioc.run();
  ASIO_CHECK(read_completed);
  ASIO_CHECK(write_completed);
  ASIO_CHECK(memcmp(read_buffer, write_data, sizeof(write_data)) == 0);

  // Cancelled read.

  bool read_cancel_completed = false;
  asio::async_read(server_side_socket,
      asio::buffer(read_buffer),
      bindns::bind(handle_read_cancel,
        _1, _2, &read_cancel_completed));

  ioc.restart();
  ioc.poll();
  ASIO_CHECK(!read_cancel_completed);

  server_side_socket.cancel();

  ioc.restart();
  ioc.run();
  ASIO_CHECK(read_cancel_completed);

  // A read when the peer closes socket should fail with eof.

  bool read_eof_completed = false;
  asio::async_read(client_side_socket,
      asio::buffer(read_buffer),
      bindns::bind(handle_read_eof,
        _1, _2, &read_eof_completed));

  server_side_socket.close();

  ioc.restart();
  ioc.run();
  ASIO_CHECK(read_eof_completed);
}

} // namespace ip_tcp_socket_runtime

//------------------------------------------------------------------------------

// ip_tcp_acceptor_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::tcp::acceptor compile and link correctly. Runtime failures are ignored.

namespace ip_tcp_acceptor_compile {

struct wait_handler
{
  wait_handler() {}
  void operator()(const asio::error_code&) {}
  wait_handler(wait_handler&&) {}
private:
  wait_handler(const wait_handler&);
};

struct accept_handler
{
  accept_handler() {}
  void operator()(const asio::error_code&) {}
  accept_handler(accept_handler&&) {}
private:
  accept_handler(const accept_handler&);
};

struct move_accept_handler
{
  move_accept_handler() {}
  void operator()(
      const asio::error_code&, asio::ip::tcp::socket) {}
  move_accept_handler(move_accept_handler&&) {}
private:
  move_accept_handler(const move_accept_handler&) {}
};

struct move_accept_ioc_handler
{
  move_accept_ioc_handler() {}
  void operator()(const asio::error_code&,
      asio::basic_stream_socket<asio::ip::tcp,
        asio::io_context::executor_type>) {}
  move_accept_ioc_handler(move_accept_handler&&) {}
private:
  move_accept_ioc_handler(const move_accept_handler&) {}
};

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    ip::tcp::socket peer_socket1(ioc);
    asio::basic_stream_socket<ip::tcp,
        io_context::executor_type> peer_socket2(ioc);
    ip::tcp::endpoint peer_endpoint;
    archetypes::settable_socket_option<void> settable_socket_option1;
    archetypes::settable_socket_option<int> settable_socket_option2;
    archetypes::settable_socket_option<double> settable_socket_option3;
    archetypes::gettable_socket_option<void> gettable_socket_option1;
    archetypes::gettable_socket_option<int> gettable_socket_option2;
    archetypes::gettable_socket_option<double> gettable_socket_option3;
    archetypes::io_control_command io_control_command;
    archetypes::immediate_handler immediate;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_socket_acceptor constructors.

    ip::tcp::acceptor acceptor1(ioc);
    ip::tcp::acceptor acceptor2(ioc, ip::tcp::v4());
    ip::tcp::acceptor acceptor3(ioc, ip::tcp::v6());
    ip::tcp::acceptor acceptor4(ioc, ip::tcp::endpoint(ip::tcp::v4(), 0));
    ip::tcp::acceptor acceptor5(ioc, ip::tcp::endpoint(ip::tcp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::tcp::acceptor::native_handle_type native_acceptor1
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    ip::tcp::acceptor acceptor6(ioc, ip::tcp::v4(), native_acceptor1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::tcp::acceptor acceptor7(ioc_ex);
    ip::tcp::acceptor acceptor8(ioc_ex, ip::tcp::v4());
    ip::tcp::acceptor acceptor9(ioc_ex, ip::tcp::v6());
    ip::tcp::acceptor acceptor10(ioc_ex, ip::tcp::endpoint(ip::tcp::v4(), 0));
    ip::tcp::acceptor acceptor11(ioc_ex, ip::tcp::endpoint(ip::tcp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::tcp::acceptor::native_handle_type native_acceptor2
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    ip::tcp::acceptor acceptor12(ioc_ex, ip::tcp::v4(), native_acceptor2);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::tcp::acceptor acceptor13(std::move(acceptor5));

    // basic_socket_acceptor operators.

    acceptor1 = ip::tcp::acceptor(ioc);
    acceptor1 = std::move(acceptor2);

    // basic_io_object functions.

    ip::tcp::acceptor::executor_type ex = acceptor1.get_executor();
    (void)ex;

    // basic_socket_acceptor functions.

    acceptor1.open(ip::tcp::v4());
    acceptor1.open(ip::tcp::v6());
    acceptor1.open(ip::tcp::v4(), ec);
    acceptor1.open(ip::tcp::v6(), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::tcp::acceptor::native_handle_type native_acceptor3
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    acceptor1.assign(ip::tcp::v4(), native_acceptor3);
    ip::tcp::acceptor::native_handle_type native_acceptor4
      = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    acceptor1.assign(ip::tcp::v4(), native_acceptor4, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = acceptor1.is_open();
    (void)is_open;

    acceptor1.close();
    acceptor1.close(ec);

    acceptor1.release();
    acceptor1.release(ec);

    ip::tcp::acceptor::native_handle_type native_acceptor5
      = acceptor1.native_handle();
    (void)native_acceptor5;

    acceptor1.cancel();
    acceptor1.cancel(ec);

    acceptor1.bind(ip::tcp::endpoint(ip::tcp::v4(), 0));
    acceptor1.bind(ip::tcp::endpoint(ip::tcp::v6(), 0));
    acceptor1.bind(ip::tcp::endpoint(ip::tcp::v4(), 0), ec);
    acceptor1.bind(ip::tcp::endpoint(ip::tcp::v6(), 0), ec);

    acceptor1.set_option(settable_socket_option1);
    acceptor1.set_option(settable_socket_option1, ec);
    acceptor1.set_option(settable_socket_option2);
    acceptor1.set_option(settable_socket_option2, ec);
    acceptor1.set_option(settable_socket_option3);
    acceptor1.set_option(settable_socket_option3, ec);

    acceptor1.get_option(gettable_socket_option1);
    acceptor1.get_option(gettable_socket_option1, ec);
    acceptor1.get_option(gettable_socket_option2);
    acceptor1.get_option(gettable_socket_option2, ec);
    acceptor1.get_option(gettable_socket_option3);
    acceptor1.get_option(gettable_socket_option3, ec);

    acceptor1.io_control(io_control_command);
    acceptor1.io_control(io_control_command, ec);

    bool non_blocking1 = acceptor1.non_blocking();
    (void)non_blocking1;
    acceptor1.non_blocking(true);
    acceptor1.non_blocking(false, ec);

    bool non_blocking2 = acceptor1.native_non_blocking();
    (void)non_blocking2;
    acceptor1.native_non_blocking(true);
    acceptor1.native_non_blocking(false, ec);

    ip::tcp::endpoint endpoint1 = acceptor1.local_endpoint();
    (void)endpoint1;
    ip::tcp::endpoint endpoint2 = acceptor1.local_endpoint(ec);
    (void)endpoint2;

    acceptor1.wait(socket_base::wait_read);
    acceptor1.wait(socket_base::wait_write, ec);

    acceptor1.async_wait(socket_base::wait_read, wait_handler());
    acceptor1.async_wait(socket_base::wait_read, immediate);
    int i1 = acceptor1.async_wait(socket_base::wait_write, lazy);
    (void)i1;

    acceptor1.accept(peer_socket1);
    acceptor1.accept(peer_socket1, ec);
    acceptor1.accept(peer_socket1, peer_endpoint);
    acceptor1.accept(peer_socket1, peer_endpoint, ec);

    acceptor1.accept(peer_socket2);
    acceptor1.accept(peer_socket2, ec);
    acceptor1.accept(peer_socket2, peer_endpoint);
    acceptor1.accept(peer_socket2, peer_endpoint, ec);

    peer_socket1 = acceptor1.accept();
    peer_socket1 = acceptor1.accept(ioc);
    peer_socket1 = acceptor1.accept(ioc_ex);
    peer_socket1 = acceptor1.accept(peer_endpoint);
    peer_socket1 = acceptor1.accept(ioc, peer_endpoint);
    peer_socket1 = acceptor1.accept(ioc_ex, peer_endpoint);
    (void)peer_socket1;

    peer_socket2 = acceptor1.accept(ioc);
    peer_socket2 = acceptor1.accept(ioc_ex);
    peer_socket2 = acceptor1.accept(ioc, peer_endpoint);
    peer_socket2 = acceptor1.accept(ioc_ex, peer_endpoint);
    (void)peer_socket2;

    acceptor1.async_accept(peer_socket1, accept_handler());
    acceptor1.async_accept(peer_socket1, peer_endpoint, accept_handler());
    acceptor1.async_accept(peer_socket1, immediate);
    acceptor1.async_accept(peer_socket1, peer_endpoint, immediate);
    int i2 = acceptor1.async_accept(peer_socket1, lazy);
    (void)i2;
    int i3 = acceptor1.async_accept(peer_socket1, peer_endpoint, lazy);
    (void)i3;

    acceptor1.async_accept(peer_socket2, accept_handler());
    acceptor1.async_accept(peer_socket2, peer_endpoint, accept_handler());
    acceptor1.async_accept(peer_socket2, immediate);
    acceptor1.async_accept(peer_socket2, peer_endpoint, immediate);
    int i4 = acceptor1.async_accept(peer_socket2, lazy);
    (void)i4;
    int i5 = acceptor1.async_accept(peer_socket2, peer_endpoint, lazy);
    (void)i5;

    acceptor1.async_accept(move_accept_handler());
    acceptor1.async_accept(ioc, move_accept_handler());
    acceptor1.async_accept(ioc_ex, move_accept_handler());
    acceptor1.async_accept(ioc_ex, move_accept_ioc_handler());
    acceptor1.async_accept(peer_endpoint, move_accept_handler());
    acceptor1.async_accept(ioc, peer_endpoint, move_accept_handler());
    acceptor1.async_accept(ioc_ex, peer_endpoint, move_accept_handler());
    acceptor1.async_accept(ioc_ex, peer_endpoint, move_accept_ioc_handler());
    acceptor1.async_accept(immediate);
    acceptor1.async_accept(ioc, immediate);
    acceptor1.async_accept(ioc_ex, immediate);
    acceptor1.async_accept(peer_endpoint, immediate);
    acceptor1.async_accept(ioc, peer_endpoint, immediate);
    acceptor1.async_accept(ioc_ex, peer_endpoint, immediate);
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_tcp_acceptor_compile

//------------------------------------------------------------------------------

// ip_tcp_acceptor_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the ip::tcp::acceptor
// class.

namespace ip_tcp_acceptor_runtime {

void handle_accept(const asio::error_code& err)
{
  ASIO_CHECK(!err);
}

void handle_connect(const asio::error_code& err)
{
  ASIO_CHECK(!err);
}

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  io_context ioc;

  ip::tcp::acceptor acceptor(ioc, ip::tcp::endpoint(ip::tcp::v4(), 0));
  ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(ip::address_v4::loopback());

  ip::tcp::socket client_side_socket(ioc);
  ip::tcp::socket server_side_socket(ioc);

  client_side_socket.connect(server_endpoint);
  acceptor.accept(server_side_socket);

  client_side_socket.close();
  server_side_socket.close();

  client_side_socket.connect(server_endpoint);
  ip::tcp::endpoint client_endpoint;
  acceptor.accept(server_side_socket, client_endpoint);

  ip::tcp::endpoint client_side_local_endpoint
    = client_side_socket.local_endpoint();
  ASIO_CHECK(client_side_local_endpoint.port() == client_endpoint.port());

  ip::tcp::endpoint server_side_remote_endpoint
    = server_side_socket.remote_endpoint();
  ASIO_CHECK(server_side_remote_endpoint.port()
      == client_endpoint.port());

  client_side_socket.close();
  server_side_socket.close();

  acceptor.async_accept(server_side_socket, &handle_accept);
  client_side_socket.async_connect(server_endpoint, &handle_connect);

  ioc.run();

  client_side_socket.close();
  server_side_socket.close();

  acceptor.async_accept(server_side_socket, client_endpoint, &handle_accept);
  client_side_socket.async_connect(server_endpoint, &handle_connect);

  ioc.restart();
  ioc.run();

  client_side_local_endpoint = client_side_socket.local_endpoint();
  ASIO_CHECK(client_side_local_endpoint.port() == client_endpoint.port());

  server_side_remote_endpoint = server_side_socket.remote_endpoint();
  ASIO_CHECK(server_side_remote_endpoint.port()
      == client_endpoint.port());
}

} // namespace ip_tcp_acceptor_runtime

//------------------------------------------------------------------------------

// ip_tcp_resolver_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::tcp::resolver compile and link correctly. Runtime failures are ignored.

namespace ip_tcp_resolver_compile {

struct resolve_handler
{
  resolve_handler() {}
  void operator()(const asio::error_code&,
      asio::ip::tcp::resolver::results_type) {}
  resolve_handler(resolve_handler&&) {}
private:
  resolve_handler(const resolve_handler&);
};

#if !defined(ASIO_NO_DEPRECATED)
struct legacy_resolve_handler
{
  legacy_resolve_handler() {}
  void operator()(const asio::error_code&,
      asio::ip::tcp::resolver::iterator) {}
  legacy_resolve_handler(legacy_resolve_handler&&) {}
private:
  legacy_resolve_handler(const legacy_resolve_handler&);
};
#endif // !defined(ASIO_NO_DEPRECATED)

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    archetypes::lazy_handler lazy;
    asio::error_code ec;
#if !defined(ASIO_NO_DEPRECATED)
    ip::tcp::resolver::query q(ip::tcp::v4(), "localhost", "0");
#endif // !defined(ASIO_NO_DEPRECATED)
    ip::tcp::endpoint e(ip::address_v4::loopback(), 0);

    // basic_resolver constructors.

    ip::tcp::resolver resolver(ioc);
    ip::tcp::resolver resolver2(ioc_ex);

    ip::tcp::resolver resolver3(std::move(resolver));

    // basic_resolver operators.

    resolver = ip::tcp::resolver(ioc);
    resolver = std::move(resolver3);

    // basic_io_object functions.

    ip::tcp::resolver::executor_type ex = resolver.get_executor();
    (void)ex;

    // basic_resolver functions.

    resolver.cancel();

#if !defined(ASIO_NO_DEPRECATED)
    ip::tcp::resolver::results_type results1 = resolver.resolve(q);
    (void)results1;

    ip::tcp::resolver::results_type results2 = resolver.resolve(q, ec);
    (void)results2;
#endif // !defined(ASIO_NO_DEPRECATED)

    ip::tcp::resolver::results_type results3 = resolver.resolve("", "");
    (void)results3;

    ip::tcp::resolver::results_type results4 = resolver.resolve("", "", ec);
    (void)results4;

    ip::tcp::resolver::results_type results5 =
      resolver.resolve("", "", ip::tcp::resolver::flags());
    (void)results5;

    ip::tcp::resolver::results_type results6 =
      resolver.resolve("", "", ip::tcp::resolver::flags(), ec);
    (void)results6;

    ip::tcp::resolver::results_type results7 =
      resolver.resolve(ip::tcp::v4(), "", "");
    (void)results7;

    ip::tcp::resolver::results_type results8 =
      resolver.resolve(ip::tcp::v4(), "", "", ec);
    (void)results8;

    ip::tcp::resolver::results_type results9 =
      resolver.resolve(ip::tcp::v4(), "", "", ip::tcp::resolver::flags());
    (void)results9;

    ip::tcp::resolver::results_type results10 =
      resolver.resolve(ip::tcp::v4(), "", "", ip::tcp::resolver::flags(), ec);
    (void)results10;

    ip::tcp::resolver::results_type results11 = resolver.resolve(e);
    (void)results11;

    ip::tcp::resolver::results_type results12 = resolver.resolve(e, ec);
    (void)results12;

#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve(q, resolve_handler());
    resolver.async_resolve(q, legacy_resolve_handler());
    int i1 = resolver.async_resolve(q, lazy);
    (void)i1;
#endif // !defined(ASIO_NO_DEPRECATED)

    resolver.async_resolve("", "", resolve_handler());
#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve("", "", legacy_resolve_handler());
#endif // !defined(ASIO_NO_DEPRECATED)
    int i2 = resolver.async_resolve("", "", lazy);
    (void)i2;

    resolver.async_resolve("", "",
        ip::tcp::resolver::flags(), resolve_handler());
#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve("", "",
        ip::tcp::resolver::flags(), legacy_resolve_handler());
#endif // !defined(ASIO_NO_DEPRECATED)
    int i3 = resolver.async_resolve("", "",
        ip::tcp::resolver::flags(), lazy);
    (void)i3;

    resolver.async_resolve(ip::tcp::v4(), "", "", resolve_handler());
#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve(ip::tcp::v4(), "", "", legacy_resolve_handler());
#endif // !defined(ASIO_NO_DEPRECATED)
    int i4 = resolver.async_resolve(ip::tcp::v4(), "", "", lazy);
    (void)i4;

    resolver.async_resolve(ip::tcp::v4(),
        "", "", ip::tcp::resolver::flags(), resolve_handler());
#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve(ip::tcp::v4(),
        "", "", ip::tcp::resolver::flags(), legacy_resolve_handler());
#endif // !defined(ASIO_NO_DEPRECATED)
    int i5 = resolver.async_resolve(ip::tcp::v4(),
        "", "", ip::tcp::resolver::flags(), lazy);
    (void)i5;

    resolver.async_resolve(e, resolve_handler());
#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve(e, legacy_resolve_handler());
#endif // !defined(ASIO_NO_DEPRECATED)
    int i6 = resolver.async_resolve(e, lazy);
    (void)i6;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_tcp_resolver_compile

//------------------------------------------------------------------------------

// ip_tcp_resolver_entry_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::tcp::resolver::entry compile and link correctly. Runtime failures are
// ignored.

namespace ip_tcp_resolver_entry_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;
  const ip::tcp::endpoint endpoint;
  const std::string host_name;
  const std::string service_name;
  const std::allocator<char> alloc;

  try
  {
    // basic_resolver_entry constructors.

    const ip::basic_resolver_entry<ip::tcp> entry1;
    ip::basic_resolver_entry<ip::tcp> entry2(endpoint, host_name, service_name);
    ip::basic_resolver_entry<ip::tcp> entry3(entry1);
    ip::basic_resolver_entry<ip::tcp> entry4(std::move(entry2));

    // basic_resolver_entry functions.

    ip::tcp::endpoint e1 = entry1.endpoint();
    (void)e1;

    ip::tcp::endpoint e2 = entry1;
    (void)e2;

    std::string s1 = entry1.host_name();
    (void)s1;

    std::string s2 = entry1.host_name(alloc);
    (void)s2;

    std::string s3 = entry1.service_name();
    (void)s3;

    std::string s4 = entry1.service_name(alloc);
    (void)s4;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_tcp_resolver_entry_compile

//------------------------------------------------------------------------------

// ip_tcp_iostream_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public types and member functions on the
// class ip::tcp::iostream compile and link correctly. Runtime failures are
// ignored.

namespace ip_tcp_iostream_compile {

void test()
{
#if !defined(ASIO_NO_IOSTREAM)
  using namespace asio;
  namespace ip = asio::ip;

  asio::io_context ioc;
  asio::ip::tcp::socket sock(ioc);

  // basic_socket_iostream typedefs.

  (void)static_cast<ip::tcp::iostream::protocol_type*>(0);
  (void)static_cast<ip::tcp::iostream::endpoint_type*>(0);
  (void)static_cast<ip::tcp::iostream::clock_type*>(0);
  (void)static_cast<ip::tcp::iostream::time_point*>(0);
  (void)static_cast<ip::tcp::iostream::duration*>(0);
  (void)static_cast<ip::tcp::iostream::traits_type*>(0);

  // basic_socket_iostream constructors.

  ip::tcp::iostream ios1;

  ip::tcp::iostream ios2(std::move(sock));

  ip::tcp::iostream ios3("hostname", "service");

  // basic_socket_iostream operators.

  ios1 = ip::tcp::iostream();

  ios2 = std::move(ios1);

  // basic_socket_iostream members.

  ios1.connect("hostname", "service");

  ios1.close();

  (void)static_cast<std::streambuf*>(ios1.rdbuf());

  basic_socket<ip::tcp>& sref = ios1.socket();
  (void)sref;

  asio::error_code ec = ios1.error();
  (void)ec;

  ip::tcp::iostream::time_point tp = ios1.expiry();
  (void)tp;

  ios1.expires_at(tp);

  ip::tcp::iostream::duration d = ip::tcp::iostream::duration();
  ios1.expires_after(d);

  // iostream operators.

  int i = 0;
  ios1 >> i;
  ios1 << i;
#endif // !defined(ASIO_NO_IOSTREAM)
}

} // namespace ip_tcp_iostream_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/tcp",
  ASIO_COMPILE_TEST_CASE(ip_tcp_compile::test)
  ASIO_TEST_CASE(ip_tcp_runtime::test)
  ASIO_COMPILE_TEST_CASE(ip_tcp_socket_compile::test)
  ASIO_TEST_CASE(ip_tcp_socket_runtime::test)
  ASIO_COMPILE_TEST_CASE(ip_tcp_acceptor_compile::test)
  ASIO_TEST_CASE(ip_tcp_acceptor_runtime::test)
  ASIO_COMPILE_TEST_CASE(ip_tcp_resolver_compile::test)
  ASIO_COMPILE_TEST_CASE(ip_tcp_resolver_entry_compile::test)
  ASIO_COMPILE_TEST_CASE(ip_tcp_resolver_entry_compile::test)
  ASIO_COMPILE_TEST_CASE(ip_tcp_iostream_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\udp.cpp
//
// udp.cpp
// ~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/udp.hpp"

#include <cstring>
#include <functional>
#include "asio/io_context.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"
#include "../archetypes/gettable_socket_option.hpp"
#include "../archetypes/io_control_command.hpp"
#include "../archetypes/settable_socket_option.hpp"

//------------------------------------------------------------------------------

// ip_udp_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::udp::socket compile and link correctly. Runtime failures are ignored.

namespace ip_udp_socket_compile {

struct connect_handler
{
  connect_handler() {}
  void operator()(const asio::error_code&) {}
  connect_handler(connect_handler&&) {}
private:
  connect_handler(const connect_handler&);
};

struct wait_handler
{
  wait_handler() {}
  void operator()(const asio::error_code&) {}
  wait_handler(wait_handler&&) {}
private:
  wait_handler(const wait_handler&);
};

struct send_handler
{
  send_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  send_handler(send_handler&&) {}
private:
  send_handler(const send_handler&);
};

struct receive_handler
{
  receive_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  receive_handler(receive_handler&&) {}
private:
  receive_handler(const receive_handler&);
};

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    archetypes::settable_socket_option<void> settable_socket_option1;
    archetypes::settable_socket_option<int> settable_socket_option2;
    archetypes::settable_socket_option<double> settable_socket_option3;
    archetypes::gettable_socket_option<void> gettable_socket_option1;
    archetypes::gettable_socket_option<int> gettable_socket_option2;
    archetypes::gettable_socket_option<double> gettable_socket_option3;
    archetypes::io_control_command io_control_command;
    archetypes::immediate_handler immediate;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_datagram_socket constructors.

    ip::udp::socket socket1(ioc);
    ip::udp::socket socket2(ioc, ip::udp::v4());
    ip::udp::socket socket3(ioc, ip::udp::v6());
    ip::udp::socket socket4(ioc, ip::udp::endpoint(ip::udp::v4(), 0));
    ip::udp::socket socket5(ioc, ip::udp::endpoint(ip::udp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::udp::socket::native_handle_type native_socket1
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    ip::udp::socket socket6(ioc, ip::udp::v4(), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::udp::socket socket7(ioc_ex);
    ip::udp::socket socket8(ioc_ex, ip::udp::v4());
    ip::udp::socket socket9(ioc_ex, ip::udp::v6());
    ip::udp::socket socket10(ioc_ex, ip::udp::endpoint(ip::udp::v4(), 0));
    ip::udp::socket socket11(ioc_ex, ip::udp::endpoint(ip::udp::v6(), 0));
#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::udp::socket::native_handle_type native_socket2
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    ip::udp::socket socket12(ioc_ex, ip::udp::v4(), native_socket2);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    ip::udp::socket socket13(std::move(socket6));

    // basic_datagram_socket operators.

    socket1 = ip::udp::socket(ioc);
    socket1 = std::move(socket2);

    // basic_io_object functions.

    ip::udp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    ip::udp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    const ip::udp::socket& socket14 = socket1;
    const ip::udp::socket::lowest_layer_type& lowest_layer2
      = socket14.lowest_layer();
    (void)lowest_layer2;

    socket1.open(ip::udp::v4());
    socket1.open(ip::udp::v6());
    socket1.open(ip::udp::v4(), ec);
    socket1.open(ip::udp::v6(), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    ip::udp::socket::native_handle_type native_socket3
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    socket1.assign(ip::udp::v4(), native_socket3);
    ip::udp::socket::native_handle_type native_socket4
      = ::socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    socket1.assign(ip::udp::v4(), native_socket4, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    socket1.release();
    socket1.release(ec);

    ip::udp::socket::native_handle_type native_socket5
      = socket1.native_handle();
    (void)native_socket5;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(ip::udp::endpoint(ip::udp::v4(), 0));
    socket1.bind(ip::udp::endpoint(ip::udp::v6(), 0));
    socket1.bind(ip::udp::endpoint(ip::udp::v4(), 0), ec);
    socket1.bind(ip::udp::endpoint(ip::udp::v6(), 0), ec);

    socket1.connect(ip::udp::endpoint(ip::udp::v4(), 0));
    socket1.connect(ip::udp::endpoint(ip::udp::v6(), 0));
    socket1.connect(ip::udp::endpoint(ip::udp::v4(), 0), ec);
    socket1.connect(ip::udp::endpoint(ip::udp::v6(), 0), ec);

    socket1.async_connect(ip::udp::endpoint(ip::udp::v4(), 0),
        connect_handler());
    socket1.async_connect(ip::udp::endpoint(ip::udp::v6(), 0),
        connect_handler());
    socket1.async_connect(ip::udp::endpoint(ip::udp::v4(), 0), immediate);
    socket1.async_connect(ip::udp::endpoint(ip::udp::v6(), 0), immediate);
    int i1 = socket1.async_connect(ip::udp::endpoint(ip::udp::v4(), 0), lazy);
    (void)i1;
    int i2 = socket1.async_connect(ip::udp::endpoint(ip::udp::v6(), 0), lazy);
    (void)i2;

    socket1.set_option(settable_socket_option1);
    socket1.set_option(settable_socket_option1, ec);
    socket1.set_option(settable_socket_option2);
    socket1.set_option(settable_socket_option2, ec);
    socket1.set_option(settable_socket_option3);
    socket1.set_option(settable_socket_option3, ec);

    socket1.get_option(gettable_socket_option1);
    socket1.get_option(gettable_socket_option1, ec);
    socket1.get_option(gettable_socket_option2);
    socket1.get_option(gettable_socket_option2, ec);
    socket1.get_option(gettable_socket_option3);
    socket1.get_option(gettable_socket_option3, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    bool non_blocking1 = socket1.non_blocking();
    (void)non_blocking1;
    socket1.non_blocking(true);
    socket1.non_blocking(false, ec);

    bool non_blocking2 = socket1.native_non_blocking();
    (void)non_blocking2;
    socket1.native_non_blocking(true);
    socket1.native_non_blocking(false, ec);

    ip::udp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    ip::udp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    ip::udp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    ip::udp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    socket1.wait(socket_base::wait_read);
    socket1.wait(socket_base::wait_write, ec);

    socket1.async_wait(socket_base::wait_read, wait_handler());
    socket1.async_wait(socket_base::wait_read, immediate);
    int i3 = socket1.async_wait(socket_base::wait_write, lazy);
    (void)i3;

    // basic_datagram_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler());
    socket1.async_send(buffer(const_char_buffer), send_handler());
    socket1.async_send(null_buffers(), send_handler());
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler());
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler());
    socket1.async_send(null_buffers(), in_flags, send_handler());
    socket1.async_send(buffer(mutable_char_buffer), immediate);
    socket1.async_send(buffer(const_char_buffer), immediate);
    socket1.async_send(null_buffers(), immediate);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);
    int i4 = socket1.async_send(buffer(mutable_char_buffer), lazy);
    (void)i4;
    int i5 = socket1.async_send(buffer(const_char_buffer), lazy);
    (void)i5;
    int i6 = socket1.async_send(null_buffers(), lazy);
    (void)i6;
    int i7 = socket1.async_send(buffer(mutable_char_buffer), in_flags, lazy);
    (void)i7;
    int i8 = socket1.async_send(buffer(const_char_buffer), in_flags, lazy);
    (void)i8;
    int i9 = socket1.async_send(null_buffers(), in_flags, lazy);
    (void)i9;

    socket1.send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0));
    socket1.send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0));
    socket1.send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0));
    socket1.send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0));
    socket1.send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0));
    socket1.send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0));
    socket1.send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags);
    socket1.send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags);
    socket1.send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, ec);
    socket1.send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, ec);
    socket1.send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, ec);
    socket1.send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, ec);

    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), send_handler());
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), send_handler());
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, send_handler());
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, send_handler());
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, send_handler());
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), immediate);
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), immediate);
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, immediate);
    socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, immediate);
    socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, immediate);
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, immediate);
    socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, immediate);
    int i10 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), lazy);
    (void)i10;
    int i11 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), lazy);
    (void)i11;
    int i12 = socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), lazy);
    (void)i12;
    int i13 = socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), lazy);
    (void)i13;
    int i14 = socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), lazy);
    (void)i14;
    int i15 = socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), lazy);
    (void)i15;
    int i16 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, lazy);
    (void)i16;
    int i17 = socket1.async_send_to(buffer(mutable_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, lazy);
    (void)i17;
    int i18 = socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, lazy);
    (void)i18;
    int i19 = socket1.async_send_to(buffer(const_char_buffer),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, lazy);
    (void)i19;
    int i20 = socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v4(), 0), in_flags, lazy);
    (void)i20;
    int i21 = socket1.async_send_to(null_buffers(),
        ip::udp::endpoint(ip::udp::v6(), 0), in_flags, lazy);
    (void)i21;

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler());
    socket1.async_receive(null_buffers(), receive_handler());
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler());
    socket1.async_receive(null_buffers(), in_flags, receive_handler());
    socket1.async_receive(buffer(mutable_char_buffer), immediate);
    socket1.async_receive(null_buffers(), immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_receive(null_buffers(), in_flags, immediate);
    int i22 = socket1.async_receive(buffer(mutable_char_buffer), lazy);
    (void)i22;
    int i23 = socket1.async_receive(null_buffers(), lazy);
    (void)i23;
    int i24 = socket1.async_receive(buffer(mutable_char_buffer),
        in_flags, lazy);
    (void)i24;
    int i25 = socket1.async_receive(null_buffers(), in_flags, lazy);
    (void)i25;

    ip::udp::endpoint endpoint;
    socket1.receive_from(buffer(mutable_char_buffer), endpoint);
    socket1.receive_from(null_buffers(), endpoint);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags);
    socket1.receive_from(null_buffers(), endpoint, in_flags);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags, ec);
    socket1.receive_from(null_buffers(), endpoint, in_flags, ec);

    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, receive_handler());
    socket1.async_receive_from(null_buffers(),
        endpoint, receive_handler());
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, receive_handler());
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, receive_handler());
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, immediate);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, immediate);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, immediate);
    int i26 = socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, lazy);
    (void)i26;
    int i27 = socket1.async_receive_from(null_buffers(),
        endpoint, lazy);
    (void)i27;
    int i28 = socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, lazy);
    (void)i28;
    int i29 = socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, lazy);
    (void)i29;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_udp_socket_compile

//------------------------------------------------------------------------------

// ip_udp_socket_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the ip::udp::socket class.

namespace ip_udp_socket_runtime {

void handle_send(size_t expected_bytes_sent,
    const asio::error_code& err, size_t bytes_sent)
{
  ASIO_CHECK(!err);
  ASIO_CHECK(expected_bytes_sent == bytes_sent);
}

void handle_recv(size_t expected_bytes_recvd,
    const asio::error_code& err, size_t bytes_recvd)
{
  ASIO_CHECK(!err);
  ASIO_CHECK(expected_bytes_recvd == bytes_recvd);
}

void test()
{
  using namespace std; // For memcmp and memset.
  using namespace asio;
  namespace ip = asio::ip;

  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  io_context ioc;

  ip::udp::socket s1(ioc, ip::udp::endpoint(ip::udp::v4(), 0));
  ip::udp::endpoint target_endpoint = s1.local_endpoint();
  target_endpoint.address(ip::address_v4::loopback());

  ip::udp::socket s2(ioc);
  s2.open(ip::udp::v4());
  s2.bind(ip::udp::endpoint(ip::udp::v4(), 0));
  char send_msg[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  s2.send_to(buffer(send_msg, sizeof(send_msg)), target_endpoint);

  char recv_msg[sizeof(send_msg)];
  ip::udp::endpoint sender_endpoint;
  size_t bytes_recvd = s1.receive_from(buffer(recv_msg, sizeof(recv_msg)),
      sender_endpoint);

  ASIO_CHECK(bytes_recvd == sizeof(send_msg));
  ASIO_CHECK(memcmp(send_msg, recv_msg, sizeof(send_msg)) == 0);

  memset(recv_msg, 0, sizeof(recv_msg));

  target_endpoint = sender_endpoint;
  s1.async_send_to(buffer(send_msg, sizeof(send_msg)), target_endpoint,
      bindns::bind(handle_send, sizeof(send_msg), _1, _2));
  s2.async_receive_from(buffer(recv_msg, sizeof(recv_msg)), sender_endpoint,
      bindns::bind(handle_recv, sizeof(recv_msg), _1, _2));

  ioc.run();

  ASIO_CHECK(memcmp(send_msg, recv_msg, sizeof(send_msg)) == 0);
}

} // namespace ip_udp_socket_runtime

//------------------------------------------------------------------------------

// ip_udp_resolver_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ip::udp::resolver compile and link correctly. Runtime failures are ignored.

namespace ip_udp_resolver_compile {

struct resolve_handler
{
  resolve_handler() {}
  void operator()(const asio::error_code&,
      asio::ip::udp::resolver::results_type) {}
  resolve_handler(resolve_handler&&) {}
private:
  resolve_handler(const resolve_handler&);
};

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    archetypes::lazy_handler lazy;
    asio::error_code ec;
#if !defined(ASIO_NO_DEPRECATED)
    ip::udp::resolver::query q(ip::udp::v4(), "localhost", "0");
#endif // !defined(ASIO_NO_DEPRECATED)
    ip::udp::endpoint e(ip::address_v4::loopback(), 0);

    // basic_resolver constructors.

    ip::udp::resolver resolver(ioc);
    ip::udp::resolver resolver2(ioc_ex);

    ip::udp::resolver resolver3(std::move(resolver));

    // basic_resolver operators.

    resolver = ip::udp::resolver(ioc);
    resolver = std::move(resolver3);

    // basic_io_object functions.

    ip::udp::resolver::executor_type ex = resolver.get_executor();
    (void)ex;

    // basic_resolver functions.

    resolver.cancel();

#if !defined(ASIO_NO_DEPRECATED)
    ip::udp::resolver::results_type results1 = resolver.resolve(q);
    (void)results1;

    ip::udp::resolver::results_type results2 = resolver.resolve(q, ec);
    (void)results2;
#endif // !defined(ASIO_NO_DEPRECATED)

    ip::udp::resolver::results_type results3 = resolver.resolve("", "");
    (void)results3;

    ip::udp::resolver::results_type results4 = resolver.resolve("", "", ec);
    (void)results4;

    ip::udp::resolver::results_type results5 =
      resolver.resolve("", "", ip::udp::resolver::flags());
    (void)results5;

    ip::udp::resolver::results_type results6 =
      resolver.resolve("", "", ip::udp::resolver::flags(), ec);
    (void)results6;

    ip::udp::resolver::results_type results7 =
      resolver.resolve(ip::udp::v4(), "", "");
    (void)results7;

    ip::udp::resolver::results_type results8 =
      resolver.resolve(ip::udp::v4(), "", "", ec);
    (void)results8;

    ip::udp::resolver::results_type results9 =
      resolver.resolve(ip::udp::v4(), "", "", ip::udp::resolver::flags());
    (void)results9;

    ip::udp::resolver::results_type results10 =
      resolver.resolve(ip::udp::v4(), "", "", ip::udp::resolver::flags(), ec);
    (void)results10;

    ip::udp::resolver::results_type results11 = resolver.resolve(e);
    (void)results11;

    ip::udp::resolver::results_type results12 = resolver.resolve(e, ec);
    (void)results12;

#if !defined(ASIO_NO_DEPRECATED)
    resolver.async_resolve(q, resolve_handler());
    int i1 = resolver.async_resolve(q, lazy);
    (void)i1;
#endif // !defined(ASIO_NO_DEPRECATED)

    resolver.async_resolve("", "", resolve_handler());
    int i2 = resolver.async_resolve("", "", lazy);
    (void)i2;

    resolver.async_resolve("", "",
        ip::udp::resolver::flags(), resolve_handler());
    int i3 = resolver.async_resolve("", "",
        ip::udp::resolver::flags(), lazy);
    (void)i3;

    resolver.async_resolve(ip::udp::v4(), "", "", resolve_handler());
    int i4 = resolver.async_resolve(ip::udp::v4(), "", "", lazy);
    (void)i4;

    resolver.async_resolve(ip::udp::v4(),
        "", "", ip::udp::resolver::flags(), resolve_handler());
    int i5 = resolver.async_resolve(ip::udp::v4(),
        "", "", ip::udp::resolver::flags(), lazy);
    (void)i5;

    resolver.async_resolve(e, resolve_handler());
    int i6 = resolver.async_resolve(e, lazy);
    (void)i6;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_udp_resolver_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/udp",
  ASIO_COMPILE_TEST_CASE(ip_udp_socket_compile::test)
  ASIO_TEST_CASE(ip_udp_socket_runtime::test)
  ASIO_COMPILE_TEST_CASE(ip_udp_resolver_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\unicast.cpp
//
// unicast.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/unicast.hpp"

#include "asio/io_context.hpp"
#include "asio/ip/udp.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// ip_unicast_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all nested classes, enums and constants in
// ip::unicast compile and link correctly. Runtime failures are ignored.

namespace ip_unicast_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    ip::udp::socket sock(ioc);

    // hops class.

    ip::unicast::hops hops1(1024);
    sock.set_option(hops1);
    ip::unicast::hops hops2;
    sock.get_option(hops2);
    hops1 = 1;
    (void)static_cast<int>(hops1.value());
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_unicast_compile

//------------------------------------------------------------------------------

// ip_unicast_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the socket options defined
// in the ip::unicast namespace.

namespace ip_unicast_runtime {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  io_context ioc;
  asio::error_code ec;

  ip::udp::endpoint ep_v4(ip::address_v4::loopback(), 0);
  ip::udp::socket sock_v4(ioc);
  sock_v4.open(ep_v4.protocol(), ec);
  sock_v4.bind(ep_v4, ec);
  bool have_v4 = !ec;

  ip::udp::endpoint ep_v6(ip::address_v6::loopback(), 0);
  ip::udp::socket sock_v6(ioc);
  sock_v6.open(ep_v6.protocol(), ec);
  sock_v6.bind(ep_v6, ec);
  bool have_v6 = !ec;

  ASIO_CHECK(have_v4 || have_v6);

  // hops class.

  if (have_v4)
  {
    ip::unicast::hops hops1(1);
    ASIO_CHECK(hops1.value() == 1);
    sock_v4.set_option(hops1, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Option is not supported under Windows CE.
    ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
        ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK(!ec);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

    ip::unicast::hops hops2;
    sock_v4.get_option(hops2, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Option is not supported under Windows CE.
    ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
        ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK(!ec);
    ASIO_CHECK(hops2.value() == 1);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

    ip::unicast::hops hops3(255);
    ASIO_CHECK(hops3.value() == 255);
    sock_v4.set_option(hops3, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Option is not supported under Windows CE.
    ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
        ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK(!ec);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

    ip::unicast::hops hops4;
    sock_v4.get_option(hops4, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
    // Option is not supported under Windows CE.
    ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
        ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
    ASIO_CHECK(!ec);
    ASIO_CHECK(hops4.value() == 255);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  }

  if (have_v6)
  {
    ip::unicast::hops hops1(1);
    ASIO_CHECK(hops1.value() == 1);
    sock_v6.set_option(hops1, ec);
    ASIO_CHECK(!ec);

    ip::unicast::hops hops2;
    sock_v6.get_option(hops2, ec);
    ASIO_CHECK(!ec);
    ASIO_CHECK(hops2.value() == 1);

    ip::unicast::hops hops3(255);
    ASIO_CHECK(hops3.value() == 255);
    sock_v6.set_option(hops3, ec);
    ASIO_CHECK(!ec);

    ip::unicast::hops hops4;
    sock_v6.get_option(hops4, ec);
    ASIO_CHECK(!ec);
    ASIO_CHECK(hops4.value() == 255);
  }
}

} // namespace ip_unicast_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/unicast",
  ASIO_COMPILE_TEST_CASE(ip_unicast_compile::test)
  ASIO_TEST_CASE(ip_unicast_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ip\v6_only.cpp
//
// v6_only.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ip/v6_only.hpp"

#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/ip/udp.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// ip_v6_only_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that the ip::v6_only socket option compiles and
// link correctly. Runtime failures are ignored.

namespace ip_v6_only_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    ip::udp::socket sock(ioc);

    // v6_only class.

    ip::v6_only v6_only1(true);
    sock.set_option(v6_only1);
    ip::v6_only v6_only2;
    sock.get_option(v6_only2);
    v6_only1 = true;
    (void)static_cast<bool>(v6_only1);
    (void)static_cast<bool>(!v6_only1);
    (void)static_cast<bool>(v6_only1.value());
  }
  catch (std::exception&)
  {
  }
}

} // namespace ip_v6_only_compile

//------------------------------------------------------------------------------

// ip_v6_only_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the ip::v6_only socket
// option.

namespace ip_v6_only_runtime {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  io_context ioc;
  asio::error_code ec;

  ip::tcp::endpoint ep_v6(ip::address_v6::loopback(), 0);
  ip::tcp::acceptor acceptor_v6(ioc);
  acceptor_v6.open(ep_v6.protocol(), ec);
  acceptor_v6.bind(ep_v6, ec);
  bool have_v6 = !ec;
  acceptor_v6.close(ec);
  acceptor_v6.open(ep_v6.protocol(), ec);

  if (have_v6)
  {
    ip::v6_only v6_only1;
    acceptor_v6.get_option(v6_only1, ec);
    ASIO_CHECK(!ec);
    bool have_dual_stack = !v6_only1.value();

    if (have_dual_stack)
    {
      ip::v6_only v6_only2(false);
      ASIO_CHECK(!v6_only2.value());
      ASIO_CHECK(!static_cast<bool>(v6_only2));
      ASIO_CHECK(!v6_only2);
      acceptor_v6.set_option(v6_only2, ec);
      ASIO_CHECK(!ec);

      ip::v6_only v6_only3;
      acceptor_v6.get_option(v6_only3, ec);
      ASIO_CHECK(!ec);
      ASIO_CHECK(!v6_only3.value());
      ASIO_CHECK(!static_cast<bool>(v6_only3));
      ASIO_CHECK(!v6_only3);

      ip::v6_only v6_only4(true);
      ASIO_CHECK(v6_only4.value());
      ASIO_CHECK(static_cast<bool>(v6_only4));
      ASIO_CHECK(!!v6_only4);
      acceptor_v6.set_option(v6_only4, ec);
      ASIO_CHECK(!ec);

      ip::v6_only v6_only5;
      acceptor_v6.get_option(v6_only5, ec);
      ASIO_CHECK(!ec);
      ASIO_CHECK(v6_only5.value());
      ASIO_CHECK(static_cast<bool>(v6_only5));
      ASIO_CHECK(!!v6_only5);
    }
  }
}

} // namespace ip_v6_only_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ip/v6_only",
  ASIO_COMPILE_TEST_CASE(ip_v6_only_compile::test)
  ASIO_TEST_CASE(ip_v6_only_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\local\basic_endpoint.cpp
//
// basic_endpoint.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/local/basic_endpoint.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "local/basic_endpoint",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\local\connect_pair.cpp
//
// connect_pair.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/local/connect_pair.hpp"

#include "asio/io_context.hpp"
#include "asio/local/datagram_protocol.hpp"
#include "asio/local/stream_protocol.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// local_connect_pair_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all host_name functions compile and link
// correctly. Runtime failures are ignored.

namespace local_connect_pair_compile {

void test()
{
#if defined(ASIO_HAS_LOCAL_SOCKETS)
  using namespace asio;
  namespace local = asio::local;
  typedef local::datagram_protocol dp;
  typedef local::stream_protocol sp;

  try
  {
    asio::io_context io_context;
    asio::error_code ec1;

    dp::socket s1(io_context);
    dp::socket s2(io_context);
    local::connect_pair(s1, s2);

    dp::socket s3(io_context);
    dp::socket s4(io_context);
    local::connect_pair(s3, s4, ec1);

    sp::socket s5(io_context);
    sp::socket s6(io_context);
    local::connect_pair(s5, s6);

    sp::socket s7(io_context);
    sp::socket s8(io_context);
    local::connect_pair(s7, s8, ec1);
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
}

} // namespace local_connect_pair_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "local/connect_pair",
  ASIO_COMPILE_TEST_CASE(local_connect_pair_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\local\datagram_protocol.cpp
//
// datagram_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/local/datagram_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// local_datagram_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// local::datagram_socket::socket compile and link correctly. Runtime failures
// are ignored.

namespace local_datagram_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
#if defined(ASIO_HAS_LOCAL_SOCKETS)
  using namespace asio;
  namespace local = asio::local;
  typedef local::datagram_protocol dp;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    socket_base::send_buffer_size socket_option;
    socket_base::bytes_readable io_control_command;
    asio::error_code ec;

    // basic_datagram_socket constructors.

    dp::socket socket1(ioc);
    dp::socket socket2(ioc, dp());
    dp::socket socket3(ioc, dp::endpoint(""));
    int native_socket1 = ::socket(AF_UNIX, SOCK_DGRAM, 0);
    dp::socket socket4(ioc, dp(), native_socket1);

    dp::socket socket5(ioc_ex);
    dp::socket socket6(ioc_ex, dp());
    dp::socket socket7(ioc_ex, dp::endpoint(""));
    int native_socket2 = ::socket(AF_UNIX, SOCK_DGRAM, 0);
    dp::socket socket8(ioc_ex, dp(), native_socket2);

    // basic_io_object functions.

    dp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    dp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(dp());
    socket1.open(dp(), ec);

    int native_socket3 = ::socket(AF_UNIX, SOCK_DGRAM, 0);
    socket1.assign(dp(), native_socket3);
    int native_socket4 = ::socket(AF_UNIX, SOCK_DGRAM, 0);
    socket1.assign(dp(), native_socket4, ec);

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    dp::socket::native_handle_type native_socket5 = socket1.native_handle();
    (void)native_socket5;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(dp::endpoint(""));
    socket1.bind(dp::endpoint(""), ec);

    socket1.connect(dp::endpoint(""));
    socket1.connect(dp::endpoint(""), ec);

    socket1.async_connect(dp::endpoint(""), connect_handler);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    dp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    dp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    dp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    dp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_datagram_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler);
    socket1.async_send(buffer(const_char_buffer), send_handler);
    socket1.async_send(null_buffers(), send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);

    socket1.send_to(buffer(mutable_char_buffer),
        dp::endpoint(""));
    socket1.send_to(buffer(const_char_buffer),
        dp::endpoint(""));
    socket1.send_to(null_buffers(),
        dp::endpoint(""));
    socket1.send_to(buffer(mutable_char_buffer),
        dp::endpoint(""), in_flags);
    socket1.send_to(buffer(const_char_buffer),
        dp::endpoint(""), in_flags);
    socket1.send_to(null_buffers(),
        dp::endpoint(""), in_flags);
    socket1.send_to(buffer(mutable_char_buffer),
        dp::endpoint(""), in_flags, ec);
    socket1.send_to(buffer(const_char_buffer),
        dp::endpoint(""), in_flags, ec);
    socket1.send_to(null_buffers(),
        dp::endpoint(""), in_flags, ec);

    socket1.async_send_to(buffer(mutable_char_buffer),
        dp::endpoint(""), send_handler);
    socket1.async_send_to(buffer(const_char_buffer),
        dp::endpoint(""), send_handler);
    socket1.async_send_to(null_buffers(),
        dp::endpoint(""), send_handler);
    socket1.async_send_to(buffer(mutable_char_buffer),
        dp::endpoint(""), in_flags, send_handler);
    socket1.async_send_to(buffer(const_char_buffer),
        dp::endpoint(""), in_flags, send_handler);
    socket1.async_send_to(null_buffers(),
        dp::endpoint(""), in_flags, send_handler);

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler);
    socket1.async_receive(null_buffers(), receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), in_flags, receive_handler);

    dp::endpoint endpoint;
    socket1.receive_from(buffer(mutable_char_buffer), endpoint);
    socket1.receive_from(null_buffers(), endpoint);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags);
    socket1.receive_from(null_buffers(), endpoint, in_flags);
    socket1.receive_from(buffer(mutable_char_buffer), endpoint, in_flags, ec);
    socket1.receive_from(null_buffers(), endpoint, in_flags, ec);

    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, receive_handler);
    socket1.async_receive_from(null_buffers(),
        endpoint, receive_handler);
    socket1.async_receive_from(buffer(mutable_char_buffer),
        endpoint, in_flags, receive_handler);
    socket1.async_receive_from(null_buffers(),
        endpoint, in_flags, receive_handler);
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
}

} // namespace local_datagram_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "local/datagram_protocol",
  ASIO_COMPILE_TEST_CASE(local_datagram_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\local\seq_packet_protocol.cpp
//
// local/seq_packet_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/local/seq_packet_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "../unit_test.hpp"
#include "../archetypes/async_result.hpp"

#if defined(__cplusplus_cli) || defined(__cplusplus_winrt)
# define local cpp_local
#endif

//------------------------------------------------------------------------------

// local_seq_packet_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// local::seq_packet_socket::socket compile and link correctly. Runtime
// failures are ignored.

namespace local_seq_packet_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
  using namespace asio;
  namespace local = asio::local;
  typedef local::seq_packet_protocol spp;

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    const socket_base::message_flags in_flags = 0;
    socket_base::message_flags out_flags = 0;
    socket_base::send_buffer_size socket_option;
    socket_base::bytes_readable io_control_command;
    archetypes::immediate_handler immediate;
    asio::error_code ec;

    // basic_seq_packet_socket constructors.

    spp::socket socket1(ioc);
    spp::socket socket2(ioc, spp());
    spp::socket socket3(ioc, spp::endpoint());
#if !defined(ASIO_WINDOWS_RUNTIME)
    spp::socket::native_handle_type native_socket1
      = ::socket(AF_UNIX, SOCK_SEQPACKET, 0);
    spp::socket socket4(ioc, spp(), native_socket1);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    spp::socket socket5(std::move(socket4));

    // basic_seq_packet_socket operators.

    socket1 = spp::socket(ioc);
    socket1 = std::move(socket2);

    // basic_io_object functions.

    spp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    spp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(spp());
    socket1.open(spp(), ec);

#if !defined(ASIO_WINDOWS_RUNTIME)
    spp::socket::native_handle_type native_socket2
      = ::socket(AF_UNIX, SOCK_SEQPACKET, 0);
    socket1.assign(spp(), native_socket2);
    spp::socket::native_handle_type native_socket3
      = ::socket(AF_UNIX, SOCK_SEQPACKET, 0);
    socket1.assign(spp(), native_socket3, ec);
#endif // !defined(ASIO_WINDOWS_RUNTIME)

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    spp::socket::native_handle_type native_socket4 = socket1.native_handle();
    (void)native_socket4;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(spp::endpoint());
    socket1.bind(spp::endpoint(), ec);

    socket1.connect(spp::endpoint());
    socket1.connect(spp::endpoint(), ec);

    socket1.async_connect(spp::endpoint(), connect_handler);
    socket1.async_connect(spp::endpoint(), immediate);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    spp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    spp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    spp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    spp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_seq_packet_socket functions.

    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, immediate);
    socket1.async_send(buffer(const_char_buffer), in_flags, immediate);
    socket1.async_send(null_buffers(), in_flags, immediate);

    socket1.receive(buffer(mutable_char_buffer), out_flags);
    socket1.receive(null_buffers(), out_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, out_flags);
    socket1.receive(null_buffers(), in_flags, out_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, out_flags, ec);
    socket1.receive(null_buffers(), in_flags, out_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), out_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), out_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        out_flags, receive_handler);
    socket1.async_receive(null_buffers(), in_flags, out_flags, receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), out_flags, immediate);
    socket1.async_receive(null_buffers(), out_flags, immediate);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        out_flags, immediate);
    socket1.async_receive(null_buffers(), in_flags, out_flags, immediate);
  }
  catch (std::exception&)
  {
  }
}

} // namespace local_seq_packet_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "local/seq_packet_protocol",
  ASIO_COMPILE_TEST_CASE(local_seq_packet_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\local\stream_protocol.cpp
//
// stream_protocol.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/local/stream_protocol.hpp"

#include <cstring>
#include "asio/io_context.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// local_stream_protocol_socket_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// local::stream_protocol::socket compile and link correctly. Runtime failures
// are ignored.

namespace local_stream_protocol_socket_compile {

void connect_handler(const asio::error_code&)
{
}

void send_handler(const asio::error_code&, std::size_t)
{
}

void receive_handler(const asio::error_code&, std::size_t)
{
}

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
#if defined(ASIO_HAS_LOCAL_SOCKETS)
  using namespace asio;
  namespace local = asio::local;
  typedef local::stream_protocol sp;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    socket_base::message_flags in_flags = 0;
    socket_base::keep_alive socket_option;
    socket_base::bytes_readable io_control_command;
    asio::error_code ec;

    // basic_stream_socket constructors.

    sp::socket socket1(ioc);
    sp::socket socket2(ioc, sp());
    sp::socket socket3(ioc, sp::endpoint(""));
    int native_socket1 = ::socket(AF_UNIX, SOCK_STREAM, 0);
    sp::socket socket4(ioc, sp(), native_socket1);

    sp::socket socket5(ioc_ex);
    sp::socket socket6(ioc_ex, sp());
    sp::socket socket7(ioc_ex, sp::endpoint(""));
    int native_socket2 = ::socket(AF_UNIX, SOCK_STREAM, 0);
    sp::socket socket8(ioc_ex, sp(), native_socket2);

    // basic_io_object functions.

    sp::socket::executor_type ex = socket1.get_executor();
    (void)ex;

    // basic_socket functions.

    sp::socket::lowest_layer_type& lowest_layer = socket1.lowest_layer();
    (void)lowest_layer;

    socket1.open(sp());
    socket1.open(sp(), ec);

    int native_socket3 = ::socket(AF_UNIX, SOCK_STREAM, 0);
    socket1.assign(sp(), native_socket3);
    int native_socket4 = ::socket(AF_UNIX, SOCK_STREAM, 0);
    socket1.assign(sp(), native_socket4, ec);

    bool is_open = socket1.is_open();
    (void)is_open;

    socket1.close();
    socket1.close(ec);

    sp::socket::native_handle_type native_socket5 = socket1.native_handle();
    (void)native_socket5;

    socket1.cancel();
    socket1.cancel(ec);

    bool at_mark1 = socket1.at_mark();
    (void)at_mark1;
    bool at_mark2 = socket1.at_mark(ec);
    (void)at_mark2;

    std::size_t available1 = socket1.available();
    (void)available1;
    std::size_t available2 = socket1.available(ec);
    (void)available2;

    socket1.bind(sp::endpoint(""));
    socket1.bind(sp::endpoint(""), ec);

    socket1.connect(sp::endpoint(""));
    socket1.connect(sp::endpoint(""), ec);

    socket1.async_connect(sp::endpoint(""), connect_handler);

    socket1.set_option(socket_option);
    socket1.set_option(socket_option, ec);

    socket1.get_option(socket_option);
    socket1.get_option(socket_option, ec);

    socket1.io_control(io_control_command);
    socket1.io_control(io_control_command, ec);

    sp::endpoint endpoint1 = socket1.local_endpoint();
    (void)endpoint1;
    sp::endpoint endpoint2 = socket1.local_endpoint(ec);
    (void)endpoint2;

    sp::endpoint endpoint3 = socket1.remote_endpoint();
    (void)endpoint3;
    sp::endpoint endpoint4 = socket1.remote_endpoint(ec);
    (void)endpoint4;

    socket1.shutdown(socket_base::shutdown_both);
    socket1.shutdown(socket_base::shutdown_both, ec);

    // basic_stream_socket functions.

    socket1.send(buffer(mutable_char_buffer));
    socket1.send(buffer(const_char_buffer));
    socket1.send(null_buffers());
    socket1.send(buffer(mutable_char_buffer), in_flags);
    socket1.send(buffer(const_char_buffer), in_flags);
    socket1.send(null_buffers(), in_flags);
    socket1.send(buffer(mutable_char_buffer), in_flags, ec);
    socket1.send(buffer(const_char_buffer), in_flags, ec);
    socket1.send(null_buffers(), in_flags, ec);

    socket1.async_send(buffer(mutable_char_buffer), send_handler);
    socket1.async_send(buffer(const_char_buffer), send_handler);
    socket1.async_send(null_buffers(), send_handler);
    socket1.async_send(buffer(mutable_char_buffer), in_flags, send_handler);
    socket1.async_send(buffer(const_char_buffer), in_flags, send_handler);
    socket1.async_send(null_buffers(), in_flags, send_handler);

    socket1.receive(buffer(mutable_char_buffer));
    socket1.receive(null_buffers());
    socket1.receive(buffer(mutable_char_buffer), in_flags);
    socket1.receive(null_buffers(), in_flags);
    socket1.receive(buffer(mutable_char_buffer), in_flags, ec);
    socket1.receive(null_buffers(), in_flags, ec);

    socket1.async_receive(buffer(mutable_char_buffer), receive_handler);
    socket1.async_receive(null_buffers(), receive_handler);
    socket1.async_receive(buffer(mutable_char_buffer), in_flags,
        receive_handler);
    socket1.async_receive(null_buffers(), in_flags, receive_handler);

    socket1.write_some(buffer(mutable_char_buffer));
    socket1.write_some(buffer(const_char_buffer));
    socket1.write_some(null_buffers());
    socket1.write_some(buffer(mutable_char_buffer), ec);
    socket1.write_some(buffer(const_char_buffer), ec);
    socket1.write_some(null_buffers(), ec);

    socket1.async_write_some(buffer(mutable_char_buffer), write_some_handler);
    socket1.async_write_some(buffer(const_char_buffer), write_some_handler);
    socket1.async_write_some(null_buffers(), write_some_handler);

    socket1.read_some(buffer(mutable_char_buffer));
    socket1.read_some(buffer(mutable_char_buffer), ec);
    socket1.read_some(null_buffers(), ec);

    socket1.async_read_some(buffer(mutable_char_buffer), read_some_handler);
    socket1.async_read_some(null_buffers(), read_some_handler);
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_LOCAL_SOCKETS)
}

} // namespace local_stream_protocol_socket_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "local/stream_protocol",
  ASIO_COMPILE_TEST_CASE(local_stream_protocol_socket_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\posix\basic_descriptor.cpp
//
// basic_descriptor.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/posix/basic_descriptor.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "posix/basic_descriptor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\posix\basic_stream_descriptor.cpp
//
// basic_stream_descriptor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/posix/basic_stream_descriptor.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "posix/basic_stream_descriptor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\posix\descriptor_base.cpp
//
// descriptor_base.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/posix/descriptor_base.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "posix/descriptor_base",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\posix\descriptor.cpp
//
// descriptor.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/posix/descriptor.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "posix/descriptor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\posix\stream_descriptor.cpp
//
// stream_descriptor.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/posix/stream_descriptor.hpp"

#include "asio/io_context.hpp"
#include "../archetypes/async_result.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// posix_stream_descriptor_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// posix::stream_descriptor compile and link correctly. Runtime failures are
// ignored.

namespace posix_stream_descriptor_compile {

void wait_handler(const asio::error_code&)
{
}

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
#if defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
  using namespace asio;
  namespace posix = asio::posix;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    posix::descriptor_base::bytes_readable io_control_command;
    archetypes::immediate_handler immediate;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_stream_descriptor constructors.

    posix::stream_descriptor descriptor1(ioc);
    posix::stream_descriptor descriptor2(ioc_ex);
    int native_descriptor1 = -1;
    posix::stream_descriptor descriptor3(ioc, native_descriptor1);
    posix::stream_descriptor descriptor4(ioc_ex, native_descriptor1);

    posix::stream_descriptor descriptor5(std::move(descriptor2));

    posix::basic_stream_descriptor<io_context::executor_type> descriptor6(ioc);
    posix::stream_descriptor descriptor7(std::move(descriptor6));

    // basic_stream_descriptor operators.

    descriptor1 = posix::stream_descriptor(ioc);
    descriptor1 = std::move(descriptor2);
    descriptor1 = std::move(descriptor6);

    // basic_io_object functions.

    posix::stream_descriptor::executor_type ex = descriptor1.get_executor();
    (void)ex;

    // basic_descriptor functions.

    posix::stream_descriptor::lowest_layer_type& lowest_layer
      = descriptor1.lowest_layer();
    (void)lowest_layer;

    const posix::stream_descriptor& descriptor8 = descriptor1;
    const posix::stream_descriptor::lowest_layer_type& lowest_layer2
      = descriptor8.lowest_layer();
    (void)lowest_layer2;

    int native_descriptor2 = -1;
    descriptor1.assign(native_descriptor2);

    bool is_open = descriptor1.is_open();
    (void)is_open;

    descriptor1.close();
    descriptor1.close(ec);

    posix::stream_descriptor::native_handle_type native_descriptor3
      = descriptor1.native_handle();
    (void)native_descriptor3;

    posix::stream_descriptor::native_handle_type native_descriptor4
      = descriptor1.release();
    (void)native_descriptor4;

    descriptor1.cancel();
    descriptor1.cancel(ec);

    descriptor1.io_control(io_control_command);
    descriptor1.io_control(io_control_command, ec);

    bool non_blocking1 = descriptor1.non_blocking();
    (void)non_blocking1;
    descriptor1.non_blocking(true);
    descriptor1.non_blocking(false, ec);

    bool non_blocking2 = descriptor1.native_non_blocking();
    (void)non_blocking2;
    descriptor1.native_non_blocking(true);
    descriptor1.native_non_blocking(false, ec);

    descriptor1.wait(posix::descriptor_base::wait_read);
    descriptor1.wait(posix::descriptor_base::wait_write, ec);

    descriptor1.async_wait(posix::descriptor_base::wait_read, &wait_handler);
    descriptor1.async_wait(posix::descriptor_base::wait_read, immediate);
    int i1 = descriptor1.async_wait(posix::descriptor_base::wait_write, lazy);
    (void)i1;

    // basic_stream_descriptor functions.

    descriptor1.write_some(buffer(mutable_char_buffer));
    descriptor1.write_some(buffer(const_char_buffer));
    descriptor1.write_some(null_buffers());
    descriptor1.write_some(buffer(mutable_char_buffer), ec);
    descriptor1.write_some(buffer(const_char_buffer), ec);
    descriptor1.write_some(null_buffers(), ec);

    descriptor1.async_write_some(buffer(mutable_char_buffer),
        write_some_handler);
    descriptor1.async_write_some(buffer(const_char_buffer),
        write_some_handler);
    descriptor1.async_write_some(null_buffers(),
        write_some_handler);
    descriptor1.async_write_some(buffer(mutable_char_buffer), immediate);
    descriptor1.async_write_some(buffer(const_char_buffer), immediate);
    descriptor1.async_write_some(null_buffers(), immediate);
    int i2 = descriptor1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i2;
    int i3 = descriptor1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i3;
    int i4 = descriptor1.async_write_some(null_buffers(), lazy);
    (void)i4;

    descriptor1.read_some(buffer(mutable_char_buffer));
    descriptor1.read_some(buffer(mutable_char_buffer), ec);
    descriptor1.read_some(null_buffers(), ec);

    descriptor1.async_read_some(buffer(mutable_char_buffer), read_some_handler);
    descriptor1.async_read_some(null_buffers(), read_some_handler);
    descriptor1.async_read_some(buffer(mutable_char_buffer), immediate);
    descriptor1.async_read_some(null_buffers(), immediate);
    int i5 = descriptor1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i5;
    int i6 = descriptor1.async_read_some(null_buffers(), lazy);
    (void)i6;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_POSIX_STREAM_DESCRIPTOR)
}

} // namespace posix_stream_descriptor_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "posix/stream_descriptor",
  ASIO_COMPILE_TEST_CASE(posix_stream_descriptor_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\context_base.cpp
//
// context_base.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/context_base.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ssl/context_base",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\context.cpp
//
// context.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/context.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ssl/context",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\error.cpp
//
// error.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/error.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ssl/error",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\host_name_verification.cpp
//
// host_name_verification.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/host_name_verification.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ssl/host_name_verification",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\rfc2818_verification.cpp
//
// rfc2818_verification.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/rfc2818_verification.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ssl/rfc2818_verification",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\stream_base.cpp
//
// stream_base.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/stream_base.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ssl/stream_base",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ssl\stream.cpp
//
// stream.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/ssl/stream.hpp"

#include "asio.hpp"
#include "asio/ssl.hpp"
#include "../archetypes/async_result.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// ssl_stream_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// ssl::stream::socket compile and link correctly. Runtime failures are ignored.

namespace ssl_stream_compile {

bool verify_callback(bool, asio::ssl::verify_context&)
{
  return false;
}

void handshake_handler(const asio::error_code&)
{
}

void buffered_handshake_handler(const asio::error_code&, std::size_t)
{
}

void shutdown_handler(const asio::error_code&)
{
}

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    asio::ssl::context context(asio::ssl::context::sslv23);
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // ssl::stream constructors.

    ssl::stream<ip::tcp::socket> stream1(ioc, context);
    ip::tcp::socket socket1(ioc, ip::tcp::v4());
    ssl::stream<ip::tcp::socket&> stream2(socket1, context);

    ssl::stream<ip::tcp::socket> stream3
      = ssl::stream<ip::tcp::socket>(ioc, context);
    ssl::stream<ip::tcp::socket> stream4(std::move(stream3));

    // ssl::stream assignment.

    stream3 = std::move(stream4);

    // basic_io_object functions.

    ssl::stream<ip::tcp::socket>::executor_type ex = stream1.get_executor();
    (void)ex;

    // ssl::stream functions.

    SSL* ssl1 = stream1.native_handle();
    (void)ssl1;

    ssl::stream<ip::tcp::socket>::lowest_layer_type& lowest_layer
      = stream1.lowest_layer();
    (void)lowest_layer;

    const ssl::stream<ip::tcp::socket>& stream5 = stream1;
    const ssl::stream<ip::tcp::socket>::lowest_layer_type& lowest_layer2
      = stream5.lowest_layer();
    (void)lowest_layer2;

    stream1.set_verify_mode(ssl::verify_none);
    stream1.set_verify_mode(ssl::verify_none, ec);

    stream1.set_verify_depth(1);
    stream1.set_verify_depth(1, ec);

    stream1.set_verify_callback(verify_callback);
    stream1.set_verify_callback(verify_callback, ec);

    stream1.handshake(ssl::stream_base::client);
    stream1.handshake(ssl::stream_base::server);
    stream1.handshake(ssl::stream_base::client, ec);
    stream1.handshake(ssl::stream_base::server, ec);

    stream1.handshake(ssl::stream_base::client, buffer(mutable_char_buffer));
    stream1.handshake(ssl::stream_base::server, buffer(mutable_char_buffer));
    stream1.handshake(ssl::stream_base::client, buffer(const_char_buffer));
    stream1.handshake(ssl::stream_base::server, buffer(const_char_buffer));
    stream1.handshake(ssl::stream_base::client,
        buffer(mutable_char_buffer), ec);
    stream1.handshake(ssl::stream_base::server,
        buffer(mutable_char_buffer), ec);
    stream1.handshake(ssl::stream_base::client,
        buffer(const_char_buffer), ec);
    stream1.handshake(ssl::stream_base::server,
        buffer(const_char_buffer), ec);

    stream1.async_handshake(ssl::stream_base::client, handshake_handler);
    stream1.async_handshake(ssl::stream_base::server, handshake_handler);
    int i1 = stream1.async_handshake(ssl::stream_base::client, lazy);
    (void)i1;
    int i2 = stream1.async_handshake(ssl::stream_base::server, lazy);
    (void)i2;

    stream1.async_handshake(ssl::stream_base::client,
        buffer(mutable_char_buffer), buffered_handshake_handler);
    stream1.async_handshake(ssl::stream_base::server,
        buffer(mutable_char_buffer), buffered_handshake_handler);
    stream1.async_handshake(ssl::stream_base::client,
        buffer(const_char_buffer), buffered_handshake_handler);
    stream1.async_handshake(ssl::stream_base::server,
        buffer(const_char_buffer), buffered_handshake_handler);
    int i3 = stream1.async_handshake(ssl::stream_base::client,
        buffer(mutable_char_buffer), lazy);
    (void)i3;
    int i4 = stream1.async_handshake(ssl::stream_base::server,
        buffer(mutable_char_buffer), lazy);
    (void)i4;
    int i5 = stream1.async_handshake(ssl::stream_base::client,
        buffer(const_char_buffer), lazy);
    (void)i5;
    int i6 = stream1.async_handshake(ssl::stream_base::server,
        buffer(const_char_buffer), lazy);
    (void)i6;

    stream1.shutdown();
    stream1.shutdown(ec);

    stream1.async_shutdown(shutdown_handler);
    int i7 = stream1.async_shutdown(lazy);
    (void)i7;

    stream1.write_some(buffer(mutable_char_buffer));
    stream1.write_some(buffer(const_char_buffer));
    stream1.write_some(buffer(mutable_char_buffer), ec);
    stream1.write_some(buffer(const_char_buffer), ec);

    stream1.async_write_some(buffer(mutable_char_buffer), write_some_handler);
    stream1.async_write_some(buffer(const_char_buffer), write_some_handler);
    int i8 = stream1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i8;
    int i9 = stream1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i9;

    stream1.read_some(buffer(mutable_char_buffer));
    stream1.read_some(buffer(mutable_char_buffer), ec);

    stream1.async_read_some(buffer(mutable_char_buffer), read_some_handler);
    int i10 = stream1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i10;
  }
  catch (std::exception&)
  {
  }
}

} // namespace ssl_stream_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "ssl/stream",
  ASIO_COMPILE_TEST_CASE(ssl_stream_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\buffer.cpp
//
// buffer.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/buffer.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/buffer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\executor.cpp
//
// executor.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/executor.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/executor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\internet.cpp
//
// internet.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/internet.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/internet",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\io_context.cpp
//
// io_context.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/io_context.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/io_context",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\net.cpp
//
// net.cpp
// ~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/net.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/net",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\netfwd.cpp
//
// netfwd.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/netfwd.hpp"

// Test that forward declarations don't conflict with full declarations.
#include "asio/ts/net.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/netfwd",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\socket.cpp
//
// socket.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/socket.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/socket",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\ts\timer.cpp
//
// timer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/ts/timer.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "ts/timer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\basic_object_handle.cpp
//
// basic_object_handle.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/basic_object_handle.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_object_handle",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\basic_overlapped_handle.cpp
//
// basic_overlapped_handle.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/basic_overlapped_handle.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_overlapped_handle",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\basic_random_access_handle.cpp
//
// basic_random_access_handle.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/basic_random_access_handle.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_random_access_handle",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\basic_stream_handle.cpp
//
// basic_stream_handle.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/basic_stream_handle.hpp"

#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_stream_handle",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\object_handle.cpp
//
// object_handle.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/object_handle.hpp"

#include "asio/io_context.hpp"
#include "../archetypes/async_result.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// windows_object_handle_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// windows::object_handle compile and link correctly. Runtime failures are
// ignored.

namespace windows_object_handle_compile {

void wait_handler(const asio::error_code&)
{
}

void test()
{
#if defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
  using namespace asio;
  namespace win = asio::windows;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_object_handle constructors.

    win::object_handle handle1(ioc);
    HANDLE native_handle1 = INVALID_HANDLE_VALUE;
#if defined(ASIO_MSVC) && (_MSC_VER < 1910)
    // Skip this on older MSVC due to mysterious ambiguous overload errors.
#else
    win::object_handle handle2(ioc, native_handle1);
#endif

    win::object_handle handle3(ioc_ex);
    HANDLE native_handle2 = INVALID_HANDLE_VALUE;
    win::object_handle handle4(ioc_ex, native_handle2);

    win::object_handle handle5(std::move(handle4));

    win::basic_object_handle<io_context::executor_type> handle6(ioc);
    win::object_handle handle7(std::move(handle6));

    // basic_object_handle operators.

    handle1 = win::object_handle(ioc);
    handle1 = std::move(handle3);
    handle1 = std::move(handle6);

    // basic_io_object functions.

    win::object_handle::executor_type ex = handle1.get_executor();
    (void)ex;

    // basic_handle functions.

    win::object_handle::lowest_layer_type& lowest_layer
      = handle1.lowest_layer();
    (void)lowest_layer;

    const win::object_handle& handle8 = handle1;
    const win::object_handle::lowest_layer_type& lowest_layer3
      = handle8.lowest_layer();
    (void)lowest_layer3;

    HANDLE native_handle4 = INVALID_HANDLE_VALUE;
    handle1.assign(native_handle4);

    bool is_open = handle1.is_open();
    (void)is_open;

    handle1.close();
    handle1.close(ec);

    win::object_handle::native_handle_type native_handle3
      = handle1.native_handle();
    (void)native_handle3;

    handle1.cancel();
    handle1.cancel(ec);

    // basic_object_handle functions.

    handle1.wait();
    handle1.wait(ec);

    handle1.async_wait(&wait_handler);
    int i1 = handle1.async_wait(lazy);
    (void)i1;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_WINDOWS_OBJECT_HANDLE)
}

} // namespace windows_object_handle_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "windows/object_handle",
  ASIO_COMPILE_TEST_CASE(windows_object_handle_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\overlapped_handle.cpp
//
// overlapped_handle.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/overlapped_handle.hpp"

#include "asio.hpp"
#include "../unit_test.hpp"

ASIO_TEST_SUITE
(
  "windows/overlapped_handle",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\overlapped_ptr.cpp
//
// overlapped_ptr.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/overlapped_ptr.hpp"

#include "asio/any_io_executor.hpp"
#include "asio/executor.hpp"
#include "asio/io_context.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// windows_overlapped_ptr_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// windows::overlapped_ptr compile and link correctly. Runtime failures are
// ignored.

namespace windows_overlapped_ptr_compile {

void overlapped_handler_1(const asio::error_code&, std::size_t)
{
}

struct overlapped_handler_2
{
  void operator()(const asio::error_code&, std::size_t)
  {
  }
};

void test()
{
#if defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)
  using namespace asio;
  namespace win = asio::windows;

  try
  {
    io_context ioc;
    asio::any_io_executor ex1(ioc.get_executor());
#if !defined(ASIO_NO_TS_EXECUTORS)
    asio::executor ex2(ioc.get_executor());
#endif // !defined(ASIO_NO_TS_EXECUTORS)

    // basic_overlapped_ptr constructors.

    win::overlapped_ptr ptr1;

    win::overlapped_ptr ptr2(ioc, &overlapped_handler_1);
    win::overlapped_ptr ptr3(ioc, overlapped_handler_2());

    win::overlapped_ptr ptr4(ioc.get_executor(), &overlapped_handler_1);
    win::overlapped_ptr ptr5(ioc.get_executor(), overlapped_handler_2());
    win::overlapped_ptr ptr6(ex1, &overlapped_handler_1);
    win::overlapped_ptr ptr7(ex1, overlapped_handler_2());
#if !defined(ASIO_NO_TS_EXECUTORS)
    win::overlapped_ptr ptr8(ex2, &overlapped_handler_1);
    win::overlapped_ptr ptr9(ex2, overlapped_handler_2());
#endif // !defined(ASIO_NO_TS_EXECUTORS)

    // overlapped_ptr functions.

    ptr1.reset();

    ptr2.reset(ioc, &overlapped_handler_1);
    ptr3.reset(ioc, overlapped_handler_2());

    ptr2.reset(ioc.get_executor(), &overlapped_handler_1);
    ptr3.reset(ioc.get_executor(), overlapped_handler_2());
    ptr2.reset(ex1, &overlapped_handler_1);
    ptr3.reset(ex1, overlapped_handler_2());
#if !defined(ASIO_NO_TS_EXECUTORS)
    ptr3.reset(ex2, &overlapped_handler_1);
    ptr3.reset(ex2, overlapped_handler_2());
#endif // !defined(ASIO_NO_TS_EXECUTORS)

    OVERLAPPED* ov1 = ptr1.get();
    (void)ov1;

    const win::overlapped_ptr& ptr10(ptr1);
    const OVERLAPPED* ov2 = ptr10.get();
    (void)ov2;

    OVERLAPPED* ov3 = ptr1.release();
    (void)ov3;

    asio::error_code ec;
    std::size_t bytes_transferred = 0;
    ptr1.complete(ec, bytes_transferred);
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_WINDOWS_OVERLAPPED_PTR)
}

} // namespace windows_overlapped_ptr_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "windows/overlapped_ptr",
  ASIO_COMPILE_TEST_CASE(windows_overlapped_ptr_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\random_access_handle.cpp
//
// random_access_handle.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/random_access_handle.hpp"

#include "asio/io_context.hpp"
#include "../archetypes/async_result.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// windows_random_access_handle_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// windows::random_access_handle compile and link correctly. Runtime failures
// are ignored.

namespace windows_random_access_handle_compile {

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
#if defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
  using namespace asio;
  namespace win = asio::windows;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    asio::uint64_t offset = 0;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_random_access_handle constructors.

    win::random_access_handle handle1(ioc);
    HANDLE native_handle1 = INVALID_HANDLE_VALUE;
#if defined(ASIO_MSVC) && (_MSC_VER < 1910)
    // Skip this on older MSVC due to mysterious ambiguous overload errors.
#else
    win::random_access_handle handle2(ioc, native_handle1);
#endif

    win::random_access_handle handle3(ioc_ex);
    HANDLE native_handle2 = INVALID_HANDLE_VALUE;
    win::random_access_handle handle4(ioc_ex, native_handle2);

    win::random_access_handle handle5(std::move(handle4));

    win::basic_random_access_handle<io_context::executor_type> handle6(ioc);
    win::random_access_handle handle7(std::move(handle6));

    // basic_random_access_handle operators.

    handle1 = win::random_access_handle(ioc);
    handle1 = std::move(handle4);
    handle1 = std::move(handle6);

    // basic_io_object functions.

    windows::random_access_handle::executor_type ex = handle1.get_executor();
    (void)ex;

    // basic_overlapped_handle functions.

    win::random_access_handle::lowest_layer_type& lowest_layer
      = handle1.lowest_layer();
    (void)lowest_layer;

    const win::random_access_handle& handle8 = handle1;
    const win::random_access_handle::lowest_layer_type& lowest_layer2
      = handle8.lowest_layer();
    (void)lowest_layer2;

    HANDLE native_handle3 = INVALID_HANDLE_VALUE;
    handle1.assign(native_handle3);

    bool is_open = handle1.is_open();
    (void)is_open;

    handle1.close();
    handle1.close(ec);

    win::random_access_handle::native_handle_type native_handle4
      = handle1.release();
    (void)native_handle4;
    win::random_access_handle::native_handle_type native_handle5
      = handle1.release(ec);
    (void)native_handle5;

    win::random_access_handle::native_handle_type native_handle6
      = handle1.native_handle();
    (void)native_handle6;

    handle1.cancel();
    handle1.cancel(ec);

    // basic_random_access_handle functions.

    handle1.write_some_at(offset, buffer(mutable_char_buffer));
    handle1.write_some_at(offset, buffer(const_char_buffer));
    handle1.write_some_at(offset, buffer(mutable_char_buffer), ec);
    handle1.write_some_at(offset, buffer(const_char_buffer), ec);

    handle1.async_write_some_at(offset,
        buffer(mutable_char_buffer), &write_some_handler);
    handle1.async_write_some_at(offset,
        buffer(const_char_buffer), &write_some_handler);
    int i1 = handle1.async_write_some_at(offset,
        buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = handle1.async_write_some_at(offset,
        buffer(const_char_buffer), lazy);
    (void)i2;

    handle1.read_some_at(offset, buffer(mutable_char_buffer));
    handle1.read_some_at(offset, buffer(mutable_char_buffer), ec);

    handle1.async_read_some_at(offset,
        buffer(mutable_char_buffer), &read_some_handler);
    int i3 = handle1.async_read_some_at(offset,
        buffer(mutable_char_buffer), lazy);
    (void)i3;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_WINDOWS_RANDOM_ACCESS_HANDLE)
}

} // namespace windows_random_access_handle_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "windows/random_access_handle",
  ASIO_COMPILE_TEST_CASE(windows_random_access_handle_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\windows\stream_handle.cpp
//
// stream_handle.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/windows/stream_handle.hpp"

#include "asio/io_context.hpp"
#include "../archetypes/async_result.hpp"
#include "../unit_test.hpp"

//------------------------------------------------------------------------------

// windows_stream_handle_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// windows::stream_handle compile and link correctly. Runtime failures are
// ignored.

namespace windows_stream_handle_compile {

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test()
{
#if defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
  using namespace asio;
  namespace win = asio::windows;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_stream_handle constructors.

    win::stream_handle handle1(ioc);
    HANDLE native_handle1 = INVALID_HANDLE_VALUE;
#if defined(ASIO_MSVC) && (_MSC_VER < 1910)
    // Skip this on older MSVC due to mysterious ambiguous overload errors.
#else
    win::stream_handle handle2(ioc, native_handle1);
#endif

    win::stream_handle handle3(ioc_ex);
    HANDLE native_handle2 = INVALID_HANDLE_VALUE;
    win::stream_handle handle4(ioc_ex, native_handle2);

    win::stream_handle handle5(std::move(handle4));

    win::basic_stream_handle<io_context::executor_type> handle6(ioc);
    win::stream_handle handle7(std::move(handle6));

    // basic_stream_handle operators.

    handle1 = win::stream_handle(ioc);
    handle1 = std::move(handle4);
    handle1 = std::move(handle6);

    // basic_io_object functions.

    windows::stream_handle::executor_type ex = handle1.get_executor();
    (void)ex;

    // basic_overlapped_handle functions.

    win::stream_handle::lowest_layer_type& lowest_layer
      = handle1.lowest_layer();
    (void)lowest_layer;

    const win::stream_handle& handle8 = handle1;
    const win::stream_handle::lowest_layer_type& lowest_layer2
      = handle8.lowest_layer();
    (void)lowest_layer2;

    HANDLE native_handle3 = INVALID_HANDLE_VALUE;
    handle1.assign(native_handle3);

    bool is_open = handle1.is_open();
    (void)is_open;

    handle1.close();
    handle1.close(ec);

    win::stream_handle::native_handle_type native_handle4
      = handle1.release();
    (void)native_handle4;
    win::stream_handle::native_handle_type native_handle5
      = handle1.release(ec);
    (void)native_handle5;

    win::stream_handle::native_handle_type native_handle6
      = handle1.native_handle();
    (void)native_handle6;

    handle1.cancel();
    handle1.cancel(ec);

    // basic_stream_handle functions.

    handle1.write_some(buffer(mutable_char_buffer));
    handle1.write_some(buffer(const_char_buffer));
    handle1.write_some(buffer(mutable_char_buffer), ec);
    handle1.write_some(buffer(const_char_buffer), ec);

    handle1.async_write_some(buffer(mutable_char_buffer), &write_some_handler);
    handle1.async_write_some(buffer(const_char_buffer), &write_some_handler);
    int i1 = handle1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = handle1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;

    handle1.read_some(buffer(mutable_char_buffer));
    handle1.read_some(buffer(mutable_char_buffer), ec);

    handle1.async_read_some(buffer(mutable_char_buffer), &read_some_handler);
    int i3 = handle1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i3;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_WINDOWS_STREAM_HANDLE)
}

} // namespace windows_stream_handle_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "windows/stream_handle",
  ASIO_COMPILE_TEST_CASE(windows_stream_handle_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\any_completion_executor.cpp
//
// any_completion_executor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/any_completion_executor.hpp"

#include <cstring>
#include <functional>
#include "asio/system_executor.hpp"
#include "asio/thread_pool.hpp"
#include "unit_test.hpp"

using namespace asio;
namespace bindns = std;

static bool next_nothrow_new_fails = false;

void* operator new(std::size_t n,
    const std::nothrow_t&) noexcept
{
  if (next_nothrow_new_fails)
  {
    next_nothrow_new_fails = false;
    return 0;
  }
  return ::operator new(n);
}

struct fat_executor
{
  fat_executor(int id)
    : id_(id)
  {
    std::memset(data_, 0, sizeof(data_));
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  friend bool operator==(const fat_executor& a,
      const fat_executor& b) noexcept
  {
    return a.id_ == b.id_;
  }

  friend bool operator!=(const fat_executor& a,
      const fat_executor& b) noexcept
  {
    return a.id_ != b.id_;
  }

  int id_;
  unsigned char data_[1024];
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<fat_executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<fat_executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

} // namespace traits
} // namespace asio

void increment(int* count)
{
  ++(*count);
}

void any_completion_executor_construction_test()
{
  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_completion_executor ex1;

  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_completion_executor ex2(null_ptr);

  ASIO_CHECK(ex2.target<void>() == 0);
  ASIO_CHECK(ex2 == null_ptr);
  ASIO_CHECK(ex2 == ex1);

  asio::any_completion_executor ex3(pool.executor());

  ASIO_CHECK(ex3.target<void>() != 0);
  ASIO_CHECK(ex3 != null_ptr);
  ASIO_CHECK(ex3 != ex1);

  asio::any_completion_executor ex4(ex1);

  ASIO_CHECK(ex4.target<void>() == 0);
  ASIO_CHECK(ex4 == null_ptr);
  ASIO_CHECK(ex4 == ex1);

  asio::any_completion_executor ex5(ex3);

  ASIO_CHECK(ex5.target<void>() != 0);
  ASIO_CHECK(ex5 != null_ptr);
  ASIO_CHECK(ex5 == ex3);

  asio::any_completion_executor ex6 = fat_executor(1);

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);

  asio::any_completion_executor ex7 = fat_executor(1);

  ASIO_CHECK(ex7.target<void>() != 0);
  ASIO_CHECK(ex7 != null_ptr);
  ASIO_CHECK(ex7 != ex1);
  ASIO_CHECK(ex7 == ex6);

  asio::any_completion_executor ex8 = fat_executor(2);

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex8 != null_ptr);
  ASIO_CHECK(ex8 != ex1);
  ASIO_CHECK(ex8 != ex6);
  ASIO_CHECK(ex8 != ex7);

  asio::any_completion_executor ex9(ex6);

  ASIO_CHECK(ex9.target<void>() != 0);
  ASIO_CHECK(ex9 != null_ptr);
  ASIO_CHECK(ex9 != ex1);
  ASIO_CHECK(ex9 == ex6);
  ASIO_CHECK(ex9 == ex7);
  ASIO_CHECK(ex9 != ex8);

  asio::any_completion_executor ex10(std::move(ex1));

  ASIO_CHECK(ex10.target<void>() == 0);
  ASIO_CHECK(ex10 == null_ptr);
  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_completion_executor ex11(std::move(ex3));

  ASIO_CHECK(ex11.target<void>() != 0);
  ASIO_CHECK(ex11 != null_ptr);
  ASIO_CHECK(ex3.target<void>() == 0);
  ASIO_CHECK(ex3 == null_ptr);
  ASIO_CHECK(ex11 == ex5);

  asio::any_completion_executor ex12(std::move(ex7));

  ASIO_CHECK(ex12.target<void>() != 0);
  ASIO_CHECK(ex12 != null_ptr);
  ASIO_CHECK(ex7.target<void>() == 0);
  ASIO_CHECK(ex7 == null_ptr);
  ASIO_CHECK(ex12 == ex6);
  ASIO_CHECK(ex12 != ex8);
}

void any_completion_executor_nothrow_construction_test()
{
  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_completion_executor ex1;

  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_completion_executor ex2(null_ptr);

  ASIO_CHECK(ex2.target<void>() == 0);
  ASIO_CHECK(ex2 == null_ptr);
  ASIO_CHECK(ex2 == ex1);

  asio::any_completion_executor ex3(std::nothrow, pool.executor());

  ASIO_CHECK(ex3.target<void>() != 0);
  ASIO_CHECK(ex3 != null_ptr);
  ASIO_CHECK(ex3 != ex1);

  asio::any_completion_executor ex4(std::nothrow, ex1);

  ASIO_CHECK(ex4.target<void>() == 0);
  ASIO_CHECK(ex4 == null_ptr);
  ASIO_CHECK(ex4 == ex1);

  asio::any_completion_executor ex5(std::nothrow, ex3);

  ASIO_CHECK(ex5.target<void>() != 0);
  ASIO_CHECK(ex5 != null_ptr);
  ASIO_CHECK(ex5 == ex3);

  asio::any_completion_executor ex6(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);

  asio::any_completion_executor ex7(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex7.target<void>() != 0);
  ASIO_CHECK(ex7 != null_ptr);
  ASIO_CHECK(ex7 != ex1);
  ASIO_CHECK(ex7 == ex6);

  asio::any_completion_executor ex8(std::nothrow, fat_executor(2));

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex8 != null_ptr);
  ASIO_CHECK(ex8 != ex1);
  ASIO_CHECK(ex8 != ex6);
  ASIO_CHECK(ex8 != ex7);

  asio::any_completion_executor ex9(std::nothrow, ex6);

  ASIO_CHECK(ex9.target<void>() != 0);
  ASIO_CHECK(ex9 != null_ptr);
  ASIO_CHECK(ex9 != ex1);
  ASIO_CHECK(ex9 == ex6);
  ASIO_CHECK(ex9 == ex7);
  ASIO_CHECK(ex9 != ex8);

  asio::any_completion_executor ex10(std::nothrow, std::move(ex1));

  ASIO_CHECK(ex10.target<void>() == 0);
  ASIO_CHECK(ex10 == null_ptr);
  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_completion_executor ex11(std::nothrow, std::move(ex3));

  ASIO_CHECK(ex11.target<void>() != 0);
  ASIO_CHECK(ex11 != null_ptr);
  ASIO_CHECK(ex3.target<void>() == 0);
  ASIO_CHECK(ex3 == null_ptr);
  ASIO_CHECK(ex11 == ex5);

  asio::any_completion_executor ex12(std::nothrow, std::move(ex7));

  ASIO_CHECK(ex12.target<void>() != 0);
  ASIO_CHECK(ex12 != null_ptr);
  ASIO_CHECK(ex7.target<void>() == 0);
  ASIO_CHECK(ex7 == null_ptr);
  ASIO_CHECK(ex12 == ex6);
  ASIO_CHECK(ex12 != ex8);

  next_nothrow_new_fails = true;
  asio::any_completion_executor ex13(std::nothrow, fat_executor(3));

  ASIO_CHECK(ex13.target<void>() == 0);
  ASIO_CHECK(ex13 == null_ptr);
  ASIO_CHECK(ex13 == ex1);
}

void any_completion_executor_assignment_test()
{
  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_completion_executor ex1;

  asio::any_completion_executor ex2;
  ex2 = null_ptr;

  ASIO_CHECK(ex2.target<void>() == 0);

  asio::any_completion_executor ex3;
  ex3 = pool.executor();

  ASIO_CHECK(ex3.target<void>() != 0);

  asio::any_completion_executor ex4;
  ex4 = ex1;

  ASIO_CHECK(ex4.target<void>() == 0);
  ASIO_CHECK(ex4 == ex1);

  ex4 = ex3;

  ASIO_CHECK(ex4.target<void>() != 0);
  ASIO_CHECK(ex4 == ex3);

  asio::any_completion_executor ex5;
  ex5 = fat_executor(1);

  ASIO_CHECK(ex5.target<void>() != 0);
  ASIO_CHECK(ex5 != null_ptr);
  ASIO_CHECK(ex5 != ex1);

  asio::any_completion_executor ex6;
  ex6 = fat_executor(1);

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);
  ASIO_CHECK(ex6 == ex5);

  ex6 = fat_executor(2);

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);
  ASIO_CHECK(ex6 != ex5);

  asio::any_completion_executor ex7;
  ex7 = ex5;

  ASIO_CHECK(ex7.target<void>() != 0);
  ASIO_CHECK(ex7 != null_ptr);
  ASIO_CHECK(ex7 != ex1);
  ASIO_CHECK(ex7 == ex5);
  ASIO_CHECK(ex7 != ex6);

  asio::any_completion_executor ex8;
  ex8 = std::move(ex1);

  ASIO_CHECK(ex8.target<void>() == 0);
  ASIO_CHECK(ex1.target<void>() == 0);

  ex8 = std::move(ex3);

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex3.target<void>() == 0);
  ASIO_CHECK(ex8 == ex4);

  ex8 = std::move(ex5);

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex5.target<void>() == 0);
  ASIO_CHECK(ex8 == ex7);
}

void any_completion_executor_swap_test()
{
  thread_pool pool1(1);
  thread_pool pool2(1);

  asio::any_completion_executor ex1(pool1.executor());
  asio::any_completion_executor ex2(pool2.executor());

  asio::any_completion_executor ex3(ex1);
  asio::any_completion_executor ex4(ex2);

  ASIO_CHECK(ex3 == ex1);
  ASIO_CHECK(ex4 == ex2);

  ex3.swap(ex4);

  ASIO_CHECK(ex3 == ex2);
  ASIO_CHECK(ex4 == ex1);

  execution::swap(ex3, ex4);

  ASIO_CHECK(ex3 == ex1);
  ASIO_CHECK(ex4 == ex2);
}

void any_completion_executor_query_test()
{
  thread_pool pool(1);
  asio::any_completion_executor ex(pool.executor());

  ASIO_CHECK(
      asio::query(ex, asio::execution::blocking)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex, asio::execution::blocking.possibly)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex, asio::execution::outstanding_work)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ex, asio::execution::outstanding_work.untracked)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ex, asio::execution::relationship)
        == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(ex, asio::execution::relationship.fork)
        == asio::execution::relationship.fork);
}

void any_completion_executor_execute_test()
{
  int count = 0;
  thread_pool pool(1);
  asio::any_completion_executor ex(pool.executor());

  ex.execute(bindns::bind(increment, &count));

  asio::prefer(ex, asio::execution::blocking.possibly).execute(
      bindns::bind(increment, &count));

  asio::prefer(ex,
      asio::execution::blocking.possibly,
      asio::execution::outstanding_work.tracked
    ).execute(bindns::bind(increment, &count));

  asio::prefer(ex,
      asio::execution::blocking.possibly,
      asio::execution::outstanding_work.untracked
    ).execute(bindns::bind(increment, &count));

  asio::prefer(ex,
      asio::execution::blocking.possibly,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.continuation
    ).execute(bindns::bind(increment, &count));

  pool.wait();

  ASIO_CHECK(count == 5);
}

ASIO_TEST_SUITE
(
  "any_completion_executor",
  ASIO_TEST_CASE(any_completion_executor_construction_test)
  ASIO_TEST_CASE(any_completion_executor_nothrow_construction_test)
  ASIO_TEST_CASE(any_completion_executor_assignment_test)
  ASIO_TEST_CASE(any_completion_executor_swap_test)
  ASIO_TEST_CASE(any_completion_executor_query_test)
  ASIO_TEST_CASE(any_completion_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\any_completion_handler.cpp
//
// any_completion_handler.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/any_completion_handler.hpp"

#include "unit_test.hpp"

#include <functional>
#include "asio/bind_allocator.hpp"
#include "asio/bind_cancellation_slot.hpp"
#include "asio/bind_executor.hpp"
#include "asio/bind_immediate_executor.hpp"
#include "asio/error.hpp"
#include "asio/thread_pool.hpp"

namespace bindns = std;

void increment(int* count)
{
  ++(*count);
}

void any_completion_handler_construction_test()
{
  int count = 0;
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_completion_handler<void()> h1;

  ASIO_CHECK(!h1);
  ASIO_CHECK(h1 == null_ptr);

  asio::any_completion_handler<void()> h2(null_ptr);

  ASIO_CHECK(!h2);
  ASIO_CHECK(h2 == null_ptr);

  asio::any_completion_handler<void()> h3(
      bindns::bind(&increment, &count));

  ASIO_CHECK(!!h3);
  ASIO_CHECK(h3 != null_ptr);

  asio::any_completion_handler<void()> h4(std::move(h1));

  ASIO_CHECK(!h4);
  ASIO_CHECK(h4 == null_ptr);
  ASIO_CHECK(!h1);
  ASIO_CHECK(h1 == null_ptr);

  asio::any_completion_handler<void()> h5(std::move(h3));

  ASIO_CHECK(!!h5);
  ASIO_CHECK(h5 != null_ptr);
  ASIO_CHECK(!h3);
  ASIO_CHECK(h3 == null_ptr);

  asio::any_completion_handler<void()> h6(std::move(h5));

  ASIO_CHECK(!!h6);
  ASIO_CHECK(h6 != null_ptr);
  ASIO_CHECK(!h5);
  ASIO_CHECK(h5 == null_ptr);
}

void any_completion_handler_assignment_test()
{
  int count = 0;
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_completion_handler<void()> h1;

  asio::any_completion_handler<void()> h2;
  h2 = null_ptr;

  ASIO_CHECK(!h2);

  asio::any_completion_handler<void()> h3;
  h3 = bindns::bind(&increment, &count);

  ASIO_CHECK(!!h3);

  asio::any_completion_handler<void()> h4;
  h4 = std::move(h1);

  ASIO_CHECK(!h4);
  ASIO_CHECK(!h1);

  h4 = std::move(h3);

  ASIO_CHECK(!!h4);
  ASIO_CHECK(!h3);
}

template <typename T>
class handler_allocator
{
public:
  using value_type = T;

  explicit handler_allocator(int* count)
    : count_(count)
  {
  }

  template <typename U>
  handler_allocator(const handler_allocator<U>& other) noexcept
    : count_(other.count_)
  {
  }

  bool operator==(const handler_allocator& other) const noexcept
  {
    return &count_ == &other.count_;
  }

  bool operator!=(const handler_allocator& other) const noexcept
  {
    return &count_ != &other.count_;
  }

  T* allocate(std::size_t n) const
  {
    ++(*count_);
    return static_cast<T*>(::operator new(sizeof(T) * n));
  }

  void deallocate(T* p, std::size_t /*n*/) const
  {
    ::operator delete(p);
  }

private:
  template <typename> friend class handler_allocator;

  int* count_;
};

class cancel_handler
{
public:
  explicit cancel_handler(int* count)
    : count_(count)
  {
  }

  void operator()(asio::cancellation_type_t)
  {
    ++(*count_);
  }

private:
  int* count_;
};

void any_completion_handler_associator_test()
{
  typedef asio::any_completion_handler<void()> handler_type;

  int count = 0;
  int alloc_count = 0;
  int cancel_count = 0;
  asio::thread_pool pool(1);
  asio::cancellation_signal sig;

  asio::any_completion_handler<void()> h1(
      asio::bind_allocator(handler_allocator<char>(&alloc_count),
        asio::bind_cancellation_slot(sig.slot(),
          asio::bind_executor(pool.get_executor(),
            asio::bind_immediate_executor(asio::system_executor(),
              bindns::bind(&increment, &count))))));

  ASIO_CHECK(alloc_count == 1);

  ASIO_REBIND_ALLOC(asio::associated_allocator<handler_type>::type,
      char) alloc1(asio::get_associated_allocator(h1));
  alloc1.deallocate(alloc1.allocate(1), 1);

  ASIO_CHECK(alloc_count == 2);

  asio::associated_cancellation_slot<handler_type>::type slot1
    = asio::get_associated_cancellation_slot(h1);

  ASIO_CHECK(slot1.is_connected());

  slot1.emplace<cancel_handler>(&cancel_count);

  ASIO_CHECK(cancel_count == 0);

  sig.emit(asio::cancellation_type::terminal);

  ASIO_CHECK(cancel_count == 1);

  asio::associated_executor<handler_type>::type ex1
    = asio::get_associated_executor(h1);

  ASIO_CHECK(ex1 == pool.get_executor());

  asio::associated_immediate_executor<
    handler_type, asio::thread_pool::executor_type>::type ex2
      = asio::get_associated_immediate_executor(h1, pool.get_executor());

  ASIO_CHECK(ex2 == asio::system_executor());
}

void increment_with_error(asio::error_code ec,
    asio::error_code* out_ec, int* count)
{
  *out_ec = ec;
  ++(*count);
}

void any_completion_handler_invocation_test()
{
  int count = 0;
  asio::error_code ec;

  asio::any_completion_handler<void()> h1(
      bindns::bind(&increment, &count));

  ASIO_CHECK(count == 0);

  std::move(h1)();

  ASIO_CHECK(count == 1);

  asio::any_completion_handler<void(asio::error_code)> h2(
      bindns::bind(&increment_with_error,
        bindns::placeholders::_1, &ec, &count));

  ASIO_CHECK(!ec);
  ASIO_CHECK(count == 1);

  std::move(h2)(asio::error::eof);

  ASIO_CHECK(ec == asio::error::eof);
  ASIO_CHECK(count == 2);
}

ASIO_TEST_SUITE
(
  "any_completion_handler",
  ASIO_TEST_CASE(any_completion_handler_construction_test)
  ASIO_TEST_CASE(any_completion_handler_assignment_test)
  ASIO_TEST_CASE(any_completion_handler_associator_test)
  ASIO_TEST_CASE(any_completion_handler_invocation_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\any_io_executor.cpp
//
// any_io_executor.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/any_io_executor.hpp"

#include <cstring>
#include <functional>
#include "asio/system_executor.hpp"
#include "asio/thread_pool.hpp"
#include "unit_test.hpp"

using namespace asio;
namespace bindns = std;

static bool next_nothrow_new_fails = false;

void* operator new(std::size_t n,
    const std::nothrow_t&) noexcept
{
  if (next_nothrow_new_fails)
  {
    next_nothrow_new_fails = false;
    return 0;
  }
  return ::operator new(n);
}

struct fat_executor
{
  fat_executor(int id)
    : id_(id)
  {
    std::memset(data_, 0, sizeof(data_));
  }

  template <typename F>
  void execute(const F&) const
  {
  }

  execution_context& query(execution::context_t) const noexcept
  {
    return asio::query(system_executor(), execution::context);
  }

  constexpr static execution::blocking_t::never_t query(
      execution::blocking_t) noexcept
  {
    return execution::blocking.never;
  }

  friend bool operator==(const fat_executor& a,
      const fat_executor& b) noexcept
  {
    return a.id_ == b.id_;
  }

  friend bool operator!=(const fat_executor& a,
      const fat_executor& b) noexcept
  {
    return a.id_ != b.id_;
  }

  int id_;
  unsigned char data_[1024];
};

namespace asio {
namespace traits {

#if !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

template <typename F>
struct execute_member<fat_executor, F>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = false;
  typedef void result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_EXECUTE_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

template <>
struct query_member<fat_executor, execution::context_t>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef execution_context& result_type;
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

template <typename Property>
struct query_static_constexpr_member<fat_executor, Property,
    typename asio::enable_if<
      asio::is_convertible<
        Property,
        asio::execution::blocking_t
      >::value
    >::type
  >
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
  typedef execution::blocking_t::never_t result_type;

  static constexpr result_type value() noexcept
  {
    return result_type();
  }
};

#endif // !defined(ASIO_HAS_DEDUCED_QUERY_STATIC_CONSTEXPR_MEMBER_TRAIT)

#if !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

template <>
struct equality_comparable<fat_executor>
{
  static constexpr bool is_valid = true;
  static constexpr bool is_noexcept = true;
};

#endif // !defined(ASIO_HAS_DEDUCED_EQUALITY_COMPARABLE_TRAIT)

} // namespace traits
} // namespace asio

void increment(int* count)
{
  ++(*count);
}

void any_io_executor_construction_test()
{
  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_io_executor ex1;

  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_io_executor ex2(null_ptr);

  ASIO_CHECK(ex2.target<void>() == 0);
  ASIO_CHECK(ex2 == null_ptr);
  ASIO_CHECK(ex2 == ex1);

  asio::any_io_executor ex3(pool.executor());

  ASIO_CHECK(ex3.target<void>() != 0);
  ASIO_CHECK(ex3 != null_ptr);
  ASIO_CHECK(ex3 != ex1);

  asio::any_io_executor ex4(ex1);

  ASIO_CHECK(ex4.target<void>() == 0);
  ASIO_CHECK(ex4 == null_ptr);
  ASIO_CHECK(ex4 == ex1);

  asio::any_io_executor ex5(ex3);

  ASIO_CHECK(ex5.target<void>() != 0);
  ASIO_CHECK(ex5 != null_ptr);
  ASIO_CHECK(ex5 == ex3);

  asio::any_io_executor ex6 = fat_executor(1);

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);

  asio::any_io_executor ex7 = fat_executor(1);

  ASIO_CHECK(ex7.target<void>() != 0);
  ASIO_CHECK(ex7 != null_ptr);
  ASIO_CHECK(ex7 != ex1);
  ASIO_CHECK(ex7 == ex6);

  asio::any_io_executor ex8 = fat_executor(2);

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex8 != null_ptr);
  ASIO_CHECK(ex8 != ex1);
  ASIO_CHECK(ex8 != ex6);
  ASIO_CHECK(ex8 != ex7);

  asio::any_io_executor ex9(ex6);

  ASIO_CHECK(ex9.target<void>() != 0);
  ASIO_CHECK(ex9 != null_ptr);
  ASIO_CHECK(ex9 != ex1);
  ASIO_CHECK(ex9 == ex6);
  ASIO_CHECK(ex9 == ex7);
  ASIO_CHECK(ex9 != ex8);

  asio::any_io_executor ex10(std::move(ex1));

  ASIO_CHECK(ex10.target<void>() == 0);
  ASIO_CHECK(ex10 == null_ptr);
  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_io_executor ex11(std::move(ex3));

  ASIO_CHECK(ex11.target<void>() != 0);
  ASIO_CHECK(ex11 != null_ptr);
  ASIO_CHECK(ex3.target<void>() == 0);
  ASIO_CHECK(ex3 == null_ptr);
  ASIO_CHECK(ex11 == ex5);

  asio::any_io_executor ex12(std::move(ex7));

  ASIO_CHECK(ex12.target<void>() != 0);
  ASIO_CHECK(ex12 != null_ptr);
  ASIO_CHECK(ex7.target<void>() == 0);
  ASIO_CHECK(ex7 == null_ptr);
  ASIO_CHECK(ex12 == ex6);
  ASIO_CHECK(ex12 != ex8);
}

void any_io_executor_nothrow_construction_test()
{
  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_io_executor ex1;

  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_io_executor ex2(null_ptr);

  ASIO_CHECK(ex2.target<void>() == 0);
  ASIO_CHECK(ex2 == null_ptr);
  ASIO_CHECK(ex2 == ex1);

  asio::any_io_executor ex3(std::nothrow, pool.executor());

  ASIO_CHECK(ex3.target<void>() != 0);
  ASIO_CHECK(ex3 != null_ptr);
  ASIO_CHECK(ex3 != ex1);

  asio::any_io_executor ex4(std::nothrow, ex1);

  ASIO_CHECK(ex4.target<void>() == 0);
  ASIO_CHECK(ex4 == null_ptr);
  ASIO_CHECK(ex4 == ex1);

  asio::any_io_executor ex5(std::nothrow, ex3);

  ASIO_CHECK(ex5.target<void>() != 0);
  ASIO_CHECK(ex5 != null_ptr);
  ASIO_CHECK(ex5 == ex3);

  asio::any_io_executor ex6(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);

  asio::any_io_executor ex7(std::nothrow, fat_executor(1));

  ASIO_CHECK(ex7.target<void>() != 0);
  ASIO_CHECK(ex7 != null_ptr);
  ASIO_CHECK(ex7 != ex1);
  ASIO_CHECK(ex7 == ex6);

  asio::any_io_executor ex8(std::nothrow, fat_executor(2));

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex8 != null_ptr);
  ASIO_CHECK(ex8 != ex1);
  ASIO_CHECK(ex8 != ex6);
  ASIO_CHECK(ex8 != ex7);

  asio::any_io_executor ex9(std::nothrow, ex6);

  ASIO_CHECK(ex9.target<void>() != 0);
  ASIO_CHECK(ex9 != null_ptr);
  ASIO_CHECK(ex9 != ex1);
  ASIO_CHECK(ex9 == ex6);
  ASIO_CHECK(ex9 == ex7);
  ASIO_CHECK(ex9 != ex8);

  asio::any_io_executor ex10(std::nothrow, std::move(ex1));

  ASIO_CHECK(ex10.target<void>() == 0);
  ASIO_CHECK(ex10 == null_ptr);
  ASIO_CHECK(ex1.target<void>() == 0);
  ASIO_CHECK(ex1 == null_ptr);

  asio::any_io_executor ex11(std::nothrow, std::move(ex3));

  ASIO_CHECK(ex11.target<void>() != 0);
  ASIO_CHECK(ex11 != null_ptr);
  ASIO_CHECK(ex3.target<void>() == 0);
  ASIO_CHECK(ex3 == null_ptr);
  ASIO_CHECK(ex11 == ex5);

  asio::any_io_executor ex12(std::nothrow, std::move(ex7));

  ASIO_CHECK(ex12.target<void>() != 0);
  ASIO_CHECK(ex12 != null_ptr);
  ASIO_CHECK(ex7.target<void>() == 0);
  ASIO_CHECK(ex7 == null_ptr);
  ASIO_CHECK(ex12 == ex6);
  ASIO_CHECK(ex12 != ex8);

  next_nothrow_new_fails = true;
  asio::any_io_executor ex13(std::nothrow, fat_executor(3));

  ASIO_CHECK(ex13.target<void>() == 0);
  ASIO_CHECK(ex13 == null_ptr);
  ASIO_CHECK(ex13 == ex1);
}

void any_io_executor_assignment_test()
{
  thread_pool pool(1);
  asio::nullptr_t null_ptr = asio::nullptr_t();

  asio::any_io_executor ex1;

  asio::any_io_executor ex2;
  ex2 = null_ptr;

  ASIO_CHECK(ex2.target<void>() == 0);

  asio::any_io_executor ex3;
  ex3 = pool.executor();

  ASIO_CHECK(ex3.target<void>() != 0);

  asio::any_io_executor ex4;
  ex4 = ex1;

  ASIO_CHECK(ex4.target<void>() == 0);
  ASIO_CHECK(ex4 == ex1);

  ex4 = ex3;

  ASIO_CHECK(ex4.target<void>() != 0);
  ASIO_CHECK(ex4 == ex3);

  asio::any_io_executor ex5;
  ex5 = fat_executor(1);

  ASIO_CHECK(ex5.target<void>() != 0);
  ASIO_CHECK(ex5 != null_ptr);
  ASIO_CHECK(ex5 != ex1);

  asio::any_io_executor ex6;
  ex6 = fat_executor(1);

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);
  ASIO_CHECK(ex6 == ex5);

  ex6 = fat_executor(2);

  ASIO_CHECK(ex6.target<void>() != 0);
  ASIO_CHECK(ex6 != null_ptr);
  ASIO_CHECK(ex6 != ex1);
  ASIO_CHECK(ex6 != ex5);

  asio::any_io_executor ex7;
  ex7 = ex5;

  ASIO_CHECK(ex7.target<void>() != 0);
  ASIO_CHECK(ex7 != null_ptr);
  ASIO_CHECK(ex7 != ex1);
  ASIO_CHECK(ex7 == ex5);
  ASIO_CHECK(ex7 != ex6);

  asio::any_io_executor ex8;
  ex8 = std::move(ex1);

  ASIO_CHECK(ex8.target<void>() == 0);
  ASIO_CHECK(ex1.target<void>() == 0);

  ex8 = std::move(ex3);

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex3.target<void>() == 0);
  ASIO_CHECK(ex8 == ex4);

  ex8 = std::move(ex5);

  ASIO_CHECK(ex8.target<void>() != 0);
  ASIO_CHECK(ex5.target<void>() == 0);
  ASIO_CHECK(ex8 == ex7);
}

void any_io_executor_swap_test()
{
  thread_pool pool1(1);
  thread_pool pool2(1);

  asio::any_io_executor ex1(pool1.executor());
  asio::any_io_executor ex2(pool2.executor());

  asio::any_io_executor ex3(ex1);
  asio::any_io_executor ex4(ex2);

  ASIO_CHECK(ex3 == ex1);
  ASIO_CHECK(ex4 == ex2);

  ex3.swap(ex4);

  ASIO_CHECK(ex3 == ex2);
  ASIO_CHECK(ex4 == ex1);

  execution::swap(ex3, ex4);

  ASIO_CHECK(ex3 == ex1);
  ASIO_CHECK(ex4 == ex2);
}

void any_io_executor_query_test()
{
  thread_pool pool(1);
  asio::any_io_executor ex(pool.executor());

  ASIO_CHECK(
      asio::query(ex, asio::execution::blocking)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex, asio::execution::blocking.possibly)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ex, asio::execution::outstanding_work)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ex, asio::execution::outstanding_work.untracked)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ex, asio::execution::relationship)
        == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(ex, asio::execution::relationship.fork)
        == asio::execution::relationship.fork);
}

void any_io_executor_execute_test()
{
  int count = 0;
  thread_pool pool(1);
  asio::any_io_executor ex(pool.executor());

  ex.execute(bindns::bind(increment, &count));

  asio::prefer(ex, asio::execution::blocking.possibly).execute(
      bindns::bind(increment, &count));

  asio::require(ex, asio::execution::blocking.never).execute(
      bindns::bind(increment, &count));

  asio::require(
      asio::prefer(ex, asio::execution::outstanding_work.tracked),
      asio::execution::blocking.never
    ).execute(bindns::bind(increment, &count));

  asio::require(
      asio::prefer(ex,
        asio::execution::outstanding_work.untracked),
      asio::execution::blocking.never
    ).execute(bindns::bind(increment, &count));

  asio::require(
      asio::prefer(ex,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::blocking.never
    ).execute(bindns::bind(increment, &count));

  pool.wait();

  ASIO_CHECK(count == 6);
}

ASIO_TEST_SUITE
(
  "any_io_executor",
  ASIO_TEST_CASE(any_io_executor_construction_test)
  ASIO_TEST_CASE(any_io_executor_nothrow_construction_test)
  ASIO_TEST_CASE(any_io_executor_assignment_test)
  ASIO_TEST_CASE(any_io_executor_swap_test)
  ASIO_TEST_CASE(any_io_executor_query_test)
  ASIO_TEST_CASE(any_io_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\append.cpp
//
// append.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/append.hpp"

#include "asio/bind_executor.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/system_timer.hpp"
#include "unit_test.hpp"

void append_test()
{
  asio::io_context io1;
  asio::io_context io2;
  asio::system_timer timer1(io1);
  int count = 0;

  timer1.expires_after(asio::chrono::seconds(0));
  timer1.async_wait(
      asio::append(
        asio::bind_executor(io2.get_executor(),
          [&count](asio::error_code, int a, int b)
          {
            ++count;
            ASIO_CHECK(a == 123);
            ASIO_CHECK(b == 321);
          }), 123, 321));

  ASIO_CHECK(count == 0);

  io1.run();

  ASIO_CHECK(count == 0);

  io2.run();

  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "append",
  ASIO_TEST_CASE(append_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\as_tuple.cpp
//
// as_tuple.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/as_tuple.hpp"

#include "asio/bind_executor.hpp"
#include "asio/deferred.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/system_timer.hpp"
#include "asio/use_future.hpp"
#include "unit_test.hpp"

void as_tuple_test()
{
  asio::io_context io1;
  asio::io_context io2;
  asio::system_timer timer1(io1);
  int count = 0;

  timer1.expires_after(asio::chrono::seconds(0));
  timer1.async_wait(
      asio::as_tuple(
        asio::bind_executor(io2.get_executor(),
          [&count](std::tuple<asio::error_code>)
          {
            ++count;
          })));

  ASIO_CHECK(count == 0);

  io1.run();

  ASIO_CHECK(count == 0);

  io2.run();

  ASIO_CHECK(count == 1);

  timer1.async_wait(
      asio::as_tuple(
        asio::bind_executor(io2.get_executor(),
          asio::deferred)))(
            [&count](std::tuple<asio::error_code>)
            {
              ++count;
            });

  ASIO_CHECK(count == 1);

  io1.restart();
  io1.run();

  ASIO_CHECK(count == 1);

  io2.restart();
  io2.run();

  ASIO_CHECK(count == 2);

# if defined(ASIO_HAS_STD_FUTURE_CLASS)
  std::future<std::tuple<asio::error_code> > f = timer1.async_wait(
      asio::as_tuple(
        asio::bind_executor(io2.get_executor(),
          asio::use_future)));

  ASIO_CHECK(f.wait_for(std::chrono::seconds(0))
      == std::future_status::timeout);

  io1.restart();
  io1.run();

  ASIO_CHECK(f.wait_for(std::chrono::seconds(0))
      == std::future_status::timeout);

  io2.restart();
  io2.run();

  ASIO_CHECK(f.wait_for(std::chrono::seconds(0))
      == std::future_status::ready);
# endif // defined(ASIO_HAS_STD_FUTURE_CLASS)
}

void as_tuple_constness_test()
{
# if defined(ASIO_HAS_STD_FUTURE_CLASS)
  asio::io_context io1;
  asio::system_timer timer1(io1);

  auto tok1 = asio::as_tuple(asio::use_future);
  (void)timer1.async_wait(tok1);
  (void)timer1.async_wait(std::move(tok1));

  const auto tok2 = asio::as_tuple(asio::use_future);
  (void)timer1.async_wait(tok2);
  (void)timer1.async_wait(std::move(tok2));

  constexpr auto tok3 = asio::as_tuple(asio::use_future);
  (void)timer1.async_wait(tok3);
  (void)timer1.async_wait(std::move(tok3));
# endif // defined(ASIO_HAS_STD_FUTURE_CLASS)
}

ASIO_TEST_SUITE
(
  "as_tuple",
  ASIO_TEST_CASE(as_tuple_test)
  ASIO_COMPILE_TEST_CASE(as_tuple_constness_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\associated_allocator.cpp
//
// associated_allocator.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/associated_allocator.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "associated_allocator",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\associated_cancellation_slot.cpp
//
// associated_cancellation_slot.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/associated_cancellation_slot.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "associated_cancellation_slot",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\associated_executor.cpp
//
// associated_executor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/associated_executor.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "associated_executor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\associated_immediate_executor.cpp
//
// associated_immediate_executor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2022 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/associated_immediate_executor.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "associated_immediate_executor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\associator.cpp
//
// associator.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/associator.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "associator",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\async_result.cpp
//
// async_result.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/async_result.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "async_result",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\awaitable.cpp
//
// awaitable.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/awaitable.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "awaitable",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_datagram_socket.cpp
//
// basic_datagram_socket.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_datagram_socket.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_datagram_socket",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_deadline_timer.cpp
//
// basic_deadline_timer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_deadline_timer.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_deadline_timer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_file.cpp
//
// basic_file.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_file.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_file",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_random_access_file.cpp
//
// basic_random_access_file.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_random_access_file.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_random_access_file",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_raw_socket.cpp
//
// basic_raw_socket.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_raw_socket.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_raw_socket",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_readable_pipe.cpp
//
// basic_readable_pipe.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_readable_pipe.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_readable_pipe",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_seq_packet_socket.cpp
//
// basic_seq_packet_socket.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_seq_packet_socket.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_seq_packet_socket",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_serial_port.cpp
//
// basic_serial_port.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_serial_port.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_serial_port",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_signal_set.cpp
//
// basic_signal_set.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_signal_set.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_signal_set",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_socket_acceptor.cpp
//
// basic_socket_acceptor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_socket_acceptor.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_socket_acceptor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_socket.cpp
//
// basic_socket.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_socket.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_socket",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_stream_file.cpp
//
// basic_stream_file.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_stream_file.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_stream_file",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_stream_socket.cpp
//
// basic_stream_socket.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_stream_socket.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_stream_socket",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_streambuf.cpp
//
// basic_streambuf.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_streambuf.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_streambuf",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_waitable_timer.cpp
//
// basic_waitable_timer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_waitable_timer.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_waitable_timer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\basic_writable_pipe.cpp
//
// basic_writable_pipe.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/basic_writable_pipe.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "basic_writable_pipe",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\bind_allocator.cpp
//
// bind_allocator.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/bind_allocator.hpp"

#include <functional>
#include "asio/io_context.hpp"
#include "asio/steady_timer.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;
namespace bindns = std;

#if defined(ASIO_HAS_BOOST_DATE_TIME)
typedef deadline_timer timer;
namespace chronons = boost::posix_time;
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
typedef steady_timer timer;
namespace chronons = asio::chrono;
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

template <typename T>
class test_allocator
{
public:
  typedef T value_type;

  explicit test_allocator(int* allocations)
    : allocations_(allocations)
  {
  }

  template <typename U>
  test_allocator(const test_allocator<U>& other)
    : allocations_(other.allocations_)
  {
  }

  template <typename U>
  struct rebind
  {
    typedef test_allocator<U> other;
  };

  bool operator==(const test_allocator&) const
  {
    return true;
  }

  bool operator!=(const test_allocator&) const
  {
    return false;
  }

  T* allocate(std::size_t n) const
  {
    ++(*allocations_);
    return static_cast<T*>(::operator new(sizeof(T) * n));
  }

  void deallocate(T* p, std::size_t /*n*/) const
  {
    --(*allocations_);
    ::operator delete(p);
  }

//private:
  int* allocations_;
};

void increment(int* count)
{
  ++(*count);
}

void bind_allocator_to_function_object_test()
{
  io_context ioc;

  int count = 0;
  int allocations = 0;

  timer t(ioc, chronons::seconds(1));
  t.async_wait(
      bind_allocator(
        test_allocator<int>(&allocations),
        bindns::bind(&increment, &count)));

  ASIO_CHECK(count == 0);
  ASIO_CHECK(allocations == 1);

  ioc.run();

  ASIO_CHECK(count == 1);
  ASIO_CHECK(allocations == 0);

  t.async_wait(
      bind_allocator(
        test_allocator<int>(&allocations),
        bind_allocator(
          std::allocator<void>(),
          bindns::bind(&increment, &count))));

  ASIO_CHECK(count == 1);
  ASIO_CHECK(allocations == 1);

  ioc.restart();
  ioc.run();

  ASIO_CHECK(count == 2);
  ASIO_CHECK(allocations == 0);
}

struct incrementer_token_v1
{
  explicit incrementer_token_v1(int* c) : count(c) {}
  int* count;
};

struct incrementer_handler_v1
{
  explicit incrementer_handler_v1(incrementer_token_v1 t) : count(t.count) {}
  void operator()(asio::error_code){ increment(count); }
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v1, void(asio::error_code)>
{
public:
  typedef incrementer_handler_v1 completion_handler_type;
  typedef void return_type;
  explicit async_result(completion_handler_type&) {}
  return_type get() {}
};

} // namespace asio

void bind_allocator_to_completion_token_v1_test()
{
  io_context ioc;

  int count = 0;
  int allocations = 0;

  timer t(ioc, chronons::seconds(1));
  t.async_wait(
      bind_allocator(
        test_allocator<int>(&allocations),
        incrementer_token_v1(&count)));

  ASIO_CHECK(count == 0);
  ASIO_CHECK(allocations == 1);

  ioc.run();

  ASIO_CHECK(count == 1);
  ASIO_CHECK(allocations == 0);
}

struct incrementer_token_v2
{
  explicit incrementer_token_v2(int* c) : count(c) {}
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v2, void(asio::error_code)>
{
public:
#if !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)
  typedef void return_type;
#endif // !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)

  template <typename Initiation, typename... Args>
  static void initiate(Initiation initiation,
      incrementer_token_v2 token, Args&&... args)
  {
    initiation(bindns::bind(&increment, token.count),
        static_cast<Args&&>(args)...);
  }
};

} // namespace asio

void bind_allocator_to_completion_token_v2_test()
{
  io_context ioc;

  int count = 0;
  int allocations = 0;

  timer t(ioc, chronons::seconds(1));
  t.async_wait(
      bind_allocator(
        test_allocator<int>(&allocations),
        incrementer_token_v2(&count)));

  ASIO_CHECK(count == 0);
  ASIO_CHECK(allocations == 1);

  ioc.run();

  ASIO_CHECK(count == 1);
  ASIO_CHECK(allocations == 0);
}

ASIO_TEST_SUITE
(
  "bind_allocator",
  ASIO_TEST_CASE(bind_allocator_to_function_object_test)
  ASIO_TEST_CASE(bind_allocator_to_completion_token_v1_test)
  ASIO_TEST_CASE(bind_allocator_to_completion_token_v2_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\bind_cancellation_slot.cpp
//
// bind_cancellation_slot.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/bind_cancellation_slot.hpp"

#include <functional>
#include "asio/cancellation_signal.hpp"
#include "asio/io_context.hpp"
#include "asio/steady_timer.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;
namespace bindns = std;

#if defined(ASIO_HAS_BOOST_DATE_TIME)
typedef deadline_timer timer;
namespace chronons = boost::posix_time;
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
typedef steady_timer timer;
namespace chronons = asio::chrono;
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

void increment_on_cancel(int* count, const asio::error_code& error)
{
  if (error == asio::error::operation_aborted)
    ++(*count);
}

void bind_cancellation_slot_to_function_object_test()
{
  io_context ioc;
  cancellation_signal sig;

  int count = 0;

  timer t(ioc, chronons::seconds(5));
  t.async_wait(
      bind_cancellation_slot(sig.slot(),
        bindns::bind(&increment_on_cancel,
          &count, bindns::placeholders::_1)));

  ioc.poll();

  ASIO_CHECK(count == 0);

  sig.emit(asio::cancellation_type::all);

  ioc.run();

  ASIO_CHECK(count == 1);

  t.async_wait(
      bind_cancellation_slot(sig.slot(),
        bind_cancellation_slot(sig.slot(),
          bindns::bind(&increment_on_cancel,
            &count, bindns::placeholders::_1))));

  ioc.restart();
  ioc.poll();

  ASIO_CHECK(count == 1);

  sig.emit(asio::cancellation_type::all);

  ioc.run();

  ASIO_CHECK(count == 2);
}

struct incrementer_token_v1
{
  explicit incrementer_token_v1(int* c) : count(c) {}
  int* count;
};

struct incrementer_handler_v1
{
  explicit incrementer_handler_v1(incrementer_token_v1 t) : count(t.count) {}

  void operator()(asio::error_code error)
  {
    increment_on_cancel(count, error);
  }

  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v1, void(asio::error_code)>
{
public:
  typedef incrementer_handler_v1 completion_handler_type;
  typedef void return_type;
  explicit async_result(completion_handler_type&) {}
  return_type get() {}
};

} // namespace asio

void bind_cancellation_slot_to_completion_token_v1_test()
{
  io_context ioc;
  cancellation_signal sig;

  int count = 0;

  timer t(ioc, chronons::seconds(5));
  t.async_wait(
      bind_cancellation_slot(sig.slot(),
        incrementer_token_v1(&count)));

  ioc.poll();

  ASIO_CHECK(count == 0);

  sig.emit(asio::cancellation_type::all);

  ioc.run();

  ASIO_CHECK(count == 1);
}

struct incrementer_token_v2
{
  explicit incrementer_token_v2(int* c) : count(c) {}
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v2, void(asio::error_code)>
{
public:
#if !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)
  typedef void return_type;
#endif // !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)

  template <typename Initiation, typename... Args>
  static void initiate(Initiation initiation,
      incrementer_token_v2 token, Args&&... args)
  {
    initiation(
        bindns::bind(&increment_on_cancel,
          token.count, bindns::placeholders::_1),
        static_cast<Args&&>(args)...);
  }
};

} // namespace asio

void bind_cancellation_slot_to_completion_token_v2_test()
{
  io_context ioc;
  cancellation_signal sig;

  int count = 0;

  timer t(ioc, chronons::seconds(5));
  t.async_wait(
      bind_cancellation_slot(sig.slot(),
        incrementer_token_v2(&count)));

  ioc.poll();

  ASIO_CHECK(count == 0);

  sig.emit(asio::cancellation_type::all);

  ioc.run();

  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "bind_cancellation_slot",
  ASIO_TEST_CASE(bind_cancellation_slot_to_function_object_test)
  ASIO_TEST_CASE(bind_cancellation_slot_to_completion_token_v1_test)
  ASIO_TEST_CASE(bind_cancellation_slot_to_completion_token_v2_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\bind_executor.cpp
//
// bind_executor.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/bind_executor.hpp"

#include <functional>
#include "asio/io_context.hpp"
#include "asio/steady_timer.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;
namespace bindns = std;

#if defined(ASIO_HAS_BOOST_DATE_TIME)
typedef deadline_timer timer;
namespace chronons = boost::posix_time;
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
typedef steady_timer timer;
namespace chronons = asio::chrono;
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

void increment(int* count)
{
  ++(*count);
}

void bind_executor_to_function_object_test()
{
  io_context ioc1;
  io_context ioc2;

  int count = 0;

  timer t(ioc1, chronons::seconds(1));
  t.async_wait(
      bind_executor(
        ioc2.get_executor(),
        bindns::bind(&increment, &count)));

  ioc1.run();

  ASIO_CHECK(count == 0);

  ioc2.run();

  ASIO_CHECK(count == 1);

  t.async_wait(
      bind_executor(
        ioc2.get_executor(),
        bind_executor(
          asio::system_executor(),
          bindns::bind(&increment, &count))));

  ioc1.restart();
  ioc1.run();

  ASIO_CHECK(count == 1);

  ioc2.restart();
  ioc2.run();

  ASIO_CHECK(count == 2);
}

struct incrementer_token_v1
{
  explicit incrementer_token_v1(int* c) : count(c) {}
  int* count;
};

struct incrementer_handler_v1
{
  explicit incrementer_handler_v1(incrementer_token_v1 t) : count(t.count) {}
  void operator()(asio::error_code){ increment(count); }
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v1, void(asio::error_code)>
{
public:
  typedef incrementer_handler_v1 completion_handler_type;
  typedef void return_type;
  explicit async_result(completion_handler_type&) {}
  return_type get() {}
};

} // namespace asio

void bind_executor_to_completion_token_v1_test()
{
  io_context ioc1;
  io_context ioc2;

  int count = 0;

  timer t(ioc1, chronons::seconds(1));
  t.async_wait(
      bind_executor(
        ioc2.get_executor(),
        incrementer_token_v1(&count)));

  ioc1.run();

  ASIO_CHECK(count == 0);

  ioc2.run();

  ASIO_CHECK(count == 1);
}

struct incrementer_token_v2
{
  explicit incrementer_token_v2(int* c) : count(c) {}
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v2, void(asio::error_code)>
{
public:
#if !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)
  typedef void return_type;
#endif // !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)

  template <typename Initiation, typename... Args>
  static void initiate(Initiation initiation,
      incrementer_token_v2 token, Args&&... args)
  {
    initiation(bindns::bind(&increment, token.count),
        static_cast<Args&&>(args)...);
  }
};

} // namespace asio

void bind_executor_to_completion_token_v2_test()
{
  io_context ioc1;
  io_context ioc2;

  int count = 0;

  timer t(ioc1, chronons::seconds(1));
  t.async_wait(
      bind_executor(
        ioc2.get_executor(),
        incrementer_token_v2(&count)));

  ioc1.run();

  ASIO_CHECK(count == 0);

  ioc2.run();

  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "bind_executor",
  ASIO_TEST_CASE(bind_executor_to_function_object_test)
  ASIO_TEST_CASE(bind_executor_to_completion_token_v1_test)
  ASIO_TEST_CASE(bind_executor_to_completion_token_v2_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\bind_immediate_executor.cpp
//
// bind_immediate_executor.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/bind_immediate_executor.hpp"

#include <functional>
#include "asio/dispatch.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;
namespace bindns = std;

struct initiate_immediate
{
  template <typename Handler>
  void operator()(Handler&& handler, io_context* ctx) const
  {
    typename associated_immediate_executor<
      Handler, io_context::executor_type>::type ex =
        get_associated_immediate_executor(handler, ctx->get_executor());
    dispatch(ex, static_cast<Handler&&>(handler));
  }
};

template <ASIO_COMPLETION_TOKEN_FOR(void()) Token>
ASIO_INITFN_AUTO_RESULT_TYPE_PREFIX(Token, void())
async_immediate(io_context& ctx, Token&& token)
  ASIO_INITFN_AUTO_RESULT_TYPE_SUFFIX((
    async_initiate<Token, void()>(declval<initiate_immediate>(), token)))
{
  return async_initiate<Token, void()>(initiate_immediate(), token, &ctx);
}

void increment(int* count)
{
  ++(*count);
}

void bind_immediate_executor_to_function_object_test()
{
  io_context ioc1;
  io_context ioc2;

  int count = 0;

  async_immediate(ioc1,
      bind_immediate_executor(
        ioc2.get_executor(),
        bindns::bind(&increment, &count)));

  ioc1.run();

  ASIO_CHECK(count == 0);

  ioc2.run();

  ASIO_CHECK(count == 1);

  async_immediate(ioc1,
      bind_immediate_executor(
        ioc2.get_executor(),
        bind_immediate_executor(
          asio::system_executor(),
          bindns::bind(&increment, &count))));

  ioc1.restart();
  ioc1.run();

  ASIO_CHECK(count == 1);

  ioc2.restart();
  ioc2.run();

  ASIO_CHECK(count == 2);
}

struct incrementer_token_v1
{
  explicit incrementer_token_v1(int* c) : count(c) {}
  int* count;
};

struct incrementer_handler_v1
{
  explicit incrementer_handler_v1(incrementer_token_v1 t) : count(t.count) {}
  void operator()(){ increment(count); }
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v1, void()>
{
public:
  typedef incrementer_handler_v1 completion_handler_type;
  typedef void return_type;
  explicit async_result(completion_handler_type&) {}
  return_type get() {}
};

} // namespace asio

void bind_immediate_executor_to_completion_token_v1_test()
{
  io_context ioc1;
  io_context ioc2;

  int count = 0;

  async_immediate(ioc1,
      bind_immediate_executor(
        ioc2.get_executor(),
        incrementer_token_v1(&count)));

  ioc1.run();

  ASIO_CHECK(count == 0);

  ioc2.run();

  ASIO_CHECK(count == 1);
}

struct incrementer_token_v2
{
  explicit incrementer_token_v2(int* c) : count(c) {}
  int* count;
};

namespace asio {

template <>
class async_result<incrementer_token_v2, void()>
{
public:
#if !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)
  typedef void return_type;
#endif // !defined(ASIO_HAS_RETURN_TYPE_DEDUCTION)

  template <typename Initiation, typename... Args>
  static void initiate(Initiation initiation,
      incrementer_token_v2 token, Args&&... args)
  {
    initiation(bindns::bind(&increment, token.count),
        static_cast<Args&&>(args)...);
  }
};

} // namespace asio

void bind_immediate_executor_to_completion_token_v2_test()
{
  io_context ioc1;
  io_context ioc2;

  int count = 0;

  async_immediate(ioc1,
      bind_immediate_executor(
        ioc2.get_executor(),
        incrementer_token_v2(&count)));

  ioc1.run();

  ASIO_CHECK(count == 0);

  ioc2.run();

  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "bind_immediate_executor",
  ASIO_TEST_CASE(bind_immediate_executor_to_function_object_test)
  ASIO_TEST_CASE(bind_immediate_executor_to_completion_token_v1_test)
  ASIO_TEST_CASE(bind_immediate_executor_to_completion_token_v2_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\buffer_registration.cpp
//
// buffer_registration.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/buffer_registration.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "buffer_registration",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\buffer.cpp
//
// buffer.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/buffer.hpp"

#include <array>
#include <cstring>
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
# include <boost/array.hpp>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

//------------------------------------------------------------------------------

// buffer_compile test
// ~~~~~~~~~~~~~~~~~~~
// The following test checks that all overloads of the buffer function compile
// and link correctly. Runtime failures are ignored.

namespace buffer_compile {

using namespace asio;

template <typename T>
class mutable_contiguous_container
{
public:
  typedef T value_type;
  typedef T* iterator;
  typedef const T* const_iterator;
  typedef T& reference;
  typedef const T& const_reference;

  mutable_contiguous_container() {}
  std::size_t size() const { return 0; }
  iterator begin() { return 0; }
  const_iterator begin() const { return 0; }
  iterator end() { return 0; }
  const_iterator end() const { return 0; }
};

template <typename T>
class const_contiguous_container
{
public:
  typedef const T value_type;
  typedef const T* iterator;
  typedef const T* const_iterator;
  typedef const T& reference;
  typedef const T& const_reference;

  const_contiguous_container() {}
  std::size_t size() const { return 0; }
  iterator begin() { return 0; }
  const_iterator begin() const { return 0; }
  iterator end() { return 0; }
  const_iterator end() const { return 0; }
};

void test()
{
  try
  {
    char raw_data[1024];
    const char const_raw_data[1024] = "";
    void* void_ptr_data = raw_data;
    const void* const_void_ptr_data = const_raw_data;
#if defined(ASIO_HAS_BOOST_ARRAY)
    boost::array<char, 1024> array_data;
    const boost::array<char, 1024>& const_array_data_1 = array_data;
    boost::array<const char, 1024> const_array_data_2 = { { 0 } };
#endif // defined(ASIO_HAS_BOOST_ARRAY)
    std::array<char, 1024> std_array_data;
    const std::array<char, 1024>& const_std_array_data_1 = std_array_data;
    std::array<const char, 1024> const_std_array_data_2 = { { 0 } };
    std::vector<char> vector_data(1024);
    const std::vector<char>& const_vector_data = vector_data;
    std::string string_data(1024, ' ');
    const std::string const_string_data(1024, ' ');
    std::vector<mutable_buffer> mutable_buffer_sequence;
    std::vector<const_buffer> const_buffer_sequence;
#if defined(ASIO_HAS_STD_STRING_VIEW)
    std::string_view string_view_data(string_data);
#elif defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    std::experimental::string_view string_view_data(string_data);
#endif // defined(ASIO_HAS_STD_EXPERIMENTAL_STRING_VIEW)
    mutable_contiguous_container<char> mutable_contiguous_data;
    const mutable_contiguous_container<char> const_mutable_contiguous_data;
    const_contiguous_container<char> const_contiguous_data;
    const const_contiguous_container<char> const_const_contiguous_data;

    // mutable_buffer constructors.

    mutable_buffer mb1;
    mutable_buffer mb2(void_ptr_data, 1024);
    mutable_buffer mb3(mb1);
    (void)mb3;

    // mutable_buffer functions.

    void* ptr1 = mb1.data();
    (void)ptr1;

    std::size_t n1 = mb1.size();
    (void)n1;

    // mutable_buffer operators.

    mb1 += 128;
    mb1 = mb2 + 128;
    mb1 = 128 + mb2;

#if !defined(ASIO_NO_DEPRECATED)

    // mutable_buffers_1 constructors.

    mutable_buffers_1 mbc1(mb1);
    mutable_buffers_1 mbc2(mbc1);

    // mutable_buffers_1 functions.

    mutable_buffers_1::const_iterator iter1 = mbc1.begin();
    (void)iter1;
    mutable_buffers_1::const_iterator iter2 = mbc1.end();
    (void)iter2;

#endif // !defined(ASIO_NO_DEPRECATED)

    // const_buffer constructors.

    const_buffer cb1;
    const_buffer cb2(const_void_ptr_data, 1024);
    const_buffer cb3(cb1);
    (void)cb3;
    const_buffer cb4(mb1);
    (void)cb4;

    // const_buffer functions.

    const void* ptr2 = cb1.data();
    (void)ptr2;

    std::size_t n2 = cb1.size();
    (void)n2;

    // const_buffer operators.

    cb1 += 128;
    cb1 = cb2 + 128;
    cb1 = 128 + cb2;

#if !defined(ASIO_NO_DEPRECATED)

    // const_buffers_1 constructors.

    const_buffers_1 cbc1(cb1);
    const_buffers_1 cbc2(cbc1);

    // const_buffers_1 functions.

    const_buffers_1::const_iterator iter3 = cbc1.begin();
    (void)iter3;
    const_buffers_1::const_iterator iter4 = cbc1.end();
    (void)iter4;

#endif // !defined(ASIO_NO_DEPRECATED)

    // buffer_size function overloads.

    std::size_t size1 = buffer_size(mb1);
    (void)size1;
    std::size_t size2 = buffer_size(cb1);
    (void)size2;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size3 = buffer_size(mbc1);
    (void)size3;
    std::size_t size4 = buffer_size(cbc1);
    (void)size4;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size5 = buffer_size(mutable_buffer_sequence);
    (void)size5;
    std::size_t size6 = buffer_size(const_buffer_sequence);
    (void)size6;

    // buffer_cast function overloads.

#if !defined(ASIO_NO_DEPRECATED)
    void* ptr3 = buffer_cast<void*>(mb1);
    (void)ptr3;
    const void* ptr4 = buffer_cast<const void*>(cb1);
    (void)ptr4;
#endif // !defined(ASIO_NO_DEPRECATED)

    // buffer function overloads.

    mb1 = buffer(mb2);
    mb1 = buffer(mb2, 128);
    cb1 = buffer(cb2);
    cb1 = buffer(cb2, 128);
    mb1 = buffer(void_ptr_data, 1024);
    cb1 = buffer(const_void_ptr_data, 1024);
    mb1 = buffer(raw_data);
    mb1 = buffer(raw_data, 1024);
    cb1 = buffer(const_raw_data);
    cb1 = buffer(const_raw_data, 1024);
#if defined(ASIO_HAS_BOOST_ARRAY)
    mb1 = buffer(array_data);
    mb1 = buffer(array_data, 1024);
    cb1 = buffer(const_array_data_1);
    cb1 = buffer(const_array_data_1, 1024);
    cb1 = buffer(const_array_data_2);
    cb1 = buffer(const_array_data_2, 1024);
#endif // defined(ASIO_HAS_BOOST_ARRAY)
    mb1 = buffer(std_array_data);
    mb1 = buffer(std_array_data, 1024);
    cb1 = buffer(const_std_array_data_1);
    cb1 = buffer(const_std_array_data_1, 1024);
    cb1 = buffer(const_std_array_data_2);
    cb1 = buffer(const_std_array_data_2, 1024);
    mb1 = buffer(vector_data);
    mb1 = buffer(vector_data, 1024);
    cb1 = buffer(const_vector_data);
    cb1 = buffer(const_vector_data, 1024);
    mb1 = buffer(string_data);
    mb1 = buffer(string_data, 1024);
    cb1 = buffer(const_string_data);
    cb1 = buffer(const_string_data, 1024);
#if defined(ASIO_HAS_STRING_VIEW)
    cb1 = buffer(string_view_data);
    cb1 = buffer(string_view_data, 1024);
#endif // defined(ASIO_HAS_STRING_VIEW)
    mb1 = buffer(mutable_contiguous_data);
    mb1 = buffer(mutable_contiguous_data, 1024);
    cb1 = buffer(const_mutable_contiguous_data);
    cb1 = buffer(const_mutable_contiguous_data, 1024);
    cb1 = buffer(const_contiguous_data);
    cb1 = buffer(const_contiguous_data, 1024);
    cb1 = buffer(const_const_contiguous_data);
    cb1 = buffer(const_const_contiguous_data, 1024);

    // buffer_copy function overloads.

    std::size_t size7 = buffer_copy(mb1, cb2);
    (void)size7;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size8 = buffer_copy(mb1, cbc2);
    (void)size8;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size9 = buffer_copy(mb1, mb2);
    (void)size9;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size10 = buffer_copy(mb1, mbc2);
    (void)size10;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size11 = buffer_copy(mb1, const_buffer_sequence);
    (void)size11;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size12 = buffer_copy(mbc1, cb2);
    (void)size12;
    std::size_t size13 = buffer_copy(mbc1, cbc2);
    (void)size13;
    std::size_t size14 = buffer_copy(mbc1, mb2);
    (void)size14;
    std::size_t size15 = buffer_copy(mbc1, mbc2);
    (void)size15;
    std::size_t size16 = buffer_copy(mbc1, const_buffer_sequence);
    (void)size16;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size17 = buffer_copy(mutable_buffer_sequence, cb2);
    (void)size17;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size18 = buffer_copy(mutable_buffer_sequence, cbc2);
    (void)size18;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size19 = buffer_copy(mutable_buffer_sequence, mb2);
    (void)size19;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size20 = buffer_copy(mutable_buffer_sequence, mbc2);
    (void)size20;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size21 = buffer_copy(
        mutable_buffer_sequence, const_buffer_sequence);
    (void)size21;
    std::size_t size22 = buffer_copy(mb1, cb2, 128);
    (void)size22;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size23 = buffer_copy(mb1, cbc2, 128);
    (void)size23;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size24 = buffer_copy(mb1, mb2, 128);
    (void)size24;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size25 = buffer_copy(mb1, mbc2, 128);
    (void)size25;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size26 = buffer_copy(mb1, const_buffer_sequence, 128);
    (void)size26;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size27 = buffer_copy(mbc1, cb2, 128);
    (void)size27;
    std::size_t size28 = buffer_copy(mbc1, cbc2, 128);
    (void)size28;
    std::size_t size29 = buffer_copy(mbc1, mb2, 128);
    (void)size29;
    std::size_t size30 = buffer_copy(mbc1, mbc2, 128);
    (void)size30;
    std::size_t size31 = buffer_copy(mbc1, const_buffer_sequence, 128);
    (void)size31;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size32 = buffer_copy(mutable_buffer_sequence, cb2, 128);
    (void)size32;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size33 = buffer_copy(mutable_buffer_sequence, cbc2, 128);
    (void)size33;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size34 = buffer_copy(mutable_buffer_sequence, mb2, 128);
    (void)size34;
#if !defined(ASIO_NO_DEPRECATED)
    std::size_t size35 = buffer_copy(mutable_buffer_sequence, mbc2, 128);
    (void)size35;
#endif // !defined(ASIO_NO_DEPRECATED)
    std::size_t size36 = buffer_copy(
        mutable_buffer_sequence, const_buffer_sequence, 128);
    (void)size36;

    // dynamic_buffer function overloads.

    dynamic_string_buffer<char, std::string::traits_type,
      std::string::allocator_type> db1 = dynamic_buffer(string_data);
    (void)db1;
    dynamic_string_buffer<char, std::string::traits_type,
      std::string::allocator_type> db2 = dynamic_buffer(string_data, 1024);
    (void)db2;
    dynamic_vector_buffer<char, std::allocator<char> >
      db3 = dynamic_buffer(vector_data);
    (void)db3;
    dynamic_vector_buffer<char, std::allocator<char> >
      db4 = dynamic_buffer(vector_data, 1024);
    (void)db4;

    // dynamic_buffer member functions.

    std::size_t size37 = db1.size();
    (void)size37;
    std::size_t size38 = db3.size();
    (void)size38;

    std::size_t size39 = db1.max_size();
    (void)size39;
    std::size_t size40 = db3.max_size();
    (void)size40;

#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
    dynamic_string_buffer<char, std::string::traits_type,
      std::string::allocator_type>::const_buffers_type
        cb5 = db1.data();
    (void)cb5;
    dynamic_vector_buffer<char, std::allocator<char> >::const_buffers_type
      cb6 = db3.data();
    (void)cb6;

    dynamic_string_buffer<char, std::string::traits_type,
      std::string::allocator_type>::mutable_buffers_type mb5
        = db1.prepare(1024);
    (void)mb5;
    dynamic_vector_buffer<char, std::allocator<char> >::mutable_buffers_type
      mb6 = db3.prepare(1024);
    (void)mb6;

    db1.commit(1024);
    db3.commit(1024);
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)

    dynamic_string_buffer<char, std::string::traits_type,
      std::string::allocator_type>::mutable_buffers_type
        mb7 = db1.data(0, 1);
    (void)mb7;
    dynamic_vector_buffer<char, std::allocator<char> >::mutable_buffers_type
      mb8 = db3.data(0, 1);
    (void)mb8;

    dynamic_string_buffer<char, std::string::traits_type,
      std::string::allocator_type>::const_buffers_type
        cb7 = static_cast<const dynamic_string_buffer<char,
          std::string::traits_type,
            std::string::allocator_type>&>(db1).data(0, 1);
    (void)cb7;
    dynamic_vector_buffer<char, std::allocator<char> >::const_buffers_type
      cb8 = static_cast<const dynamic_vector_buffer<char,
        std::allocator<char> >&>(db3).data(0, 1);
    (void)cb8;

    db1.grow(1024);
    db3.grow(1024);

    db1.shrink(1024);
    db3.shrink(1024);

    db1.consume(0);
    db3.consume(0);
  }
  catch (std::exception&)
  {
  }
}

} // namespace buffer_compile

//------------------------------------------------------------------------------

namespace buffer_copy_runtime {

using namespace asio;
using namespace std;

void test()
{
  char dest_data[256];
  char source_data[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

  memset(dest_data, 0, sizeof(dest_data));
  mutable_buffer mb1 = asio::buffer(dest_data);
  mutable_buffer mb2 = asio::buffer(source_data);
  std::size_t n = buffer_copy(mb1, mb2);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  const_buffer cb1 = asio::buffer(source_data);
  n = buffer_copy(mb1, cb1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

#if !defined(ASIO_NO_DEPRECATED)
  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  mutable_buffers_1 mbc1 = asio::buffer(source_data);
  n = buffer_copy(mb1, mbc1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  const_buffers_1 cbc1 = const_buffers_1(asio::buffer(source_data));
  n = buffer_copy(mb1, cbc1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  mb1 = asio::buffer(source_data);
  n = buffer_copy(mbc1, mb1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  cb1 = asio::buffer(source_data);
  n = buffer_copy(mbc1, cb1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  mutable_buffers_1 mbc2 = asio::buffer(source_data);
  n = buffer_copy(mbc1, mbc2);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  cbc1 = const_buffers_1(asio::buffer(source_data));
  n = buffer_copy(mbc1, cbc1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);
#endif // !defined(ASIO_NO_DEPRECATED)

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  std::vector<mutable_buffer> mv1;
  mv1.push_back(asio::buffer(source_data, 5));
  mv1.push_back(asio::buffer(source_data) + 5);
  n = buffer_copy(mb1, mv1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  std::vector<const_buffer> cv1;
  cv1.push_back(asio::buffer(source_data, 6));
  cv1.push_back(asio::buffer(source_data) + 6);
  n = buffer_copy(mb1, cv1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mv1.clear();
  mv1.push_back(asio::buffer(dest_data, 7));
  mv1.push_back(asio::buffer(dest_data) + 7);
  cb1 = asio::buffer(source_data);
  n = buffer_copy(mv1, cb1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mv1.clear();
  mv1.push_back(asio::buffer(dest_data, 7));
  mv1.push_back(asio::buffer(dest_data) + 7);
  cv1.clear();
  cv1.push_back(asio::buffer(source_data, 8));
  cv1.push_back(asio::buffer(source_data) + 8);
  n = buffer_copy(mv1, cv1);
  ASIO_CHECK(n == sizeof(source_data));
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  mb2 = asio::buffer(source_data);
  n = buffer_copy(mb1, mb2, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  cb1 = asio::buffer(source_data);
  n = buffer_copy(mb1, cb1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

#if !defined(ASIO_NO_DEPRECATED)
  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  mbc1 = asio::buffer(source_data);
  n = buffer_copy(mb1, mbc1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  cbc1 = const_buffers_1(asio::buffer(source_data));
  n = buffer_copy(mb1, cbc1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  mb1 = asio::buffer(source_data);
  n = buffer_copy(mbc1, mb1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  cb1 = asio::buffer(source_data);
  n = buffer_copy(mbc1, cb1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  mbc2 = asio::buffer(source_data);
  n = buffer_copy(mbc1, mbc2, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mbc1 = asio::buffer(dest_data);
  cbc1 = const_buffers_1(asio::buffer(source_data));
  n = buffer_copy(mbc1, cbc1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);
#endif // !defined(ASIO_NO_DEPRECATED)

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  mv1.clear();
  mv1.push_back(asio::buffer(source_data, 5));
  mv1.push_back(asio::buffer(source_data) + 5);
  n = buffer_copy(mb1, mv1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mb1 = asio::buffer(dest_data);
  cv1.clear();
  cv1.push_back(asio::buffer(source_data, 6));
  cv1.push_back(asio::buffer(source_data) + 6);
  n = buffer_copy(mb1, cv1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mv1.clear();
  mv1.push_back(asio::buffer(dest_data, 7));
  mv1.push_back(asio::buffer(dest_data) + 7);
  cb1 = asio::buffer(source_data);
  n = buffer_copy(mv1, cb1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);

  memset(dest_data, 0, sizeof(dest_data));
  mv1.clear();
  mv1.push_back(asio::buffer(dest_data, 7));
  mv1.push_back(asio::buffer(dest_data) + 7);
  cv1.clear();
  cv1.push_back(asio::buffer(source_data, 8));
  cv1.push_back(asio::buffer(source_data) + 8);
  n = buffer_copy(mv1, cv1, 10);
  ASIO_CHECK(n == 10);
  ASIO_CHECK(memcmp(dest_data, source_data, n) == 0);
}

} // namespace buffer_copy_runtime

//------------------------------------------------------------------------------

namespace buffer_sequence {

using namespace asio;
using namespace std;

struct valid_const_a
{
  typedef const_buffer* const_iterator;
  typedef const_buffer value_type;
  const_buffer* begin() const { return 0; }
  const_buffer* end() const { return 0; }
};

struct valid_const_b
{
  const_buffer* begin() const { return 0; }
  const_buffer* end() const { return 0; }
};

struct valid_mutable_a
{
  typedef mutable_buffer* const_iterator;
  typedef mutable_buffer value_type;
  mutable_buffer* begin() const { return 0; }
  mutable_buffer* end() const { return 0; }
};

struct valid_mutable_b
{
  mutable_buffer* begin() const { return 0; }
  mutable_buffer* end() const { return 0; }
};

struct invalid_const_a
{
  typedef int value_type;
  int* begin() const { return 0; }
  const_buffer* end() const { return 0; }
};

struct invalid_const_b
{
  typedef const_buffer value_type;
  const_buffer* begin() const { return 0; }
};

struct invalid_const_c
{
  typedef const_buffer value_type;
  const_buffer* end() const { return 0; }
};

struct invalid_const_d
{
  int* begin() const { return 0; }
  const_buffer* end() const { return 0; }
};

struct invalid_const_e
{
  const_buffer* begin() const { return 0; }
};

struct invalid_const_f
{
  const_buffer* end() const { return 0; }
};

struct invalid_mutable_a
{
  typedef int value_type;
  int* begin() const { return 0; }
  mutable_buffer* end() const { return 0; }
};

struct invalid_mutable_b
{
  typedef mutable_buffer value_type;
  mutable_buffer* begin() const { return 0; }
};

struct invalid_mutable_c
{
  typedef mutable_buffer value_type;
  mutable_buffer* end() const { return 0; }
};

struct invalid_mutable_d
{
  int* begin() const { return 0; }
  mutable_buffer* end() const { return 0; }
};

struct invalid_mutable_e
{
  mutable_buffer* begin() const { return 0; }
};

struct invalid_mutable_f
{
  mutable_buffer* end() const { return 0; }
};

void test()
{
  ASIO_CHECK(is_const_buffer_sequence<const_buffer>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<const_buffer>::value);

  const_buffer b1;
  ASIO_CHECK(buffer_sequence_begin(b1) == &b1);
  ASIO_CHECK(buffer_sequence_end(b1) == &b1 + 1);

  ASIO_CHECK(is_const_buffer_sequence<mutable_buffer>::value);
  ASIO_CHECK(is_mutable_buffer_sequence<mutable_buffer>::value);

  mutable_buffer b2;
  ASIO_CHECK(buffer_sequence_begin(b2) == &b2);
  ASIO_CHECK(buffer_sequence_end(b2) == &b2 + 1);

#if !defined(ASIO_NO_DEPRECATED)
  ASIO_CHECK(is_const_buffer_sequence<const_buffers_1>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<const_buffers_1>::value);

  const_buffers_1 b3(0, 0);
  ASIO_CHECK(buffer_sequence_begin(b3) == &b3);
  ASIO_CHECK(buffer_sequence_end(b3) == &b3 + 1);

  ASIO_CHECK(is_const_buffer_sequence<mutable_buffers_1>::value);
  ASIO_CHECK(is_mutable_buffer_sequence<mutable_buffers_1>::value);

  mutable_buffers_1 b4(0, 0);
  ASIO_CHECK(buffer_sequence_begin(b4) == &b4);
  ASIO_CHECK(buffer_sequence_end(b4) == &b4 + 1);
#endif // !defined(ASIO_NO_DEPRECATED)

  ASIO_CHECK(is_const_buffer_sequence<vector<const_buffer> >::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<vector<const_buffer> >::value);

  vector<const_buffer> b5;
  ASIO_CHECK(buffer_sequence_begin(b5) == b5.begin());
  ASIO_CHECK(buffer_sequence_end(b5) == b5.end());

  ASIO_CHECK(is_const_buffer_sequence<vector<mutable_buffer> >::value);
  ASIO_CHECK(is_mutable_buffer_sequence<vector<mutable_buffer> >::value);

  vector<mutable_buffer> b6;
  ASIO_CHECK(buffer_sequence_begin(b6) == b6.begin());
  ASIO_CHECK(buffer_sequence_end(b6) == b6.end());

  ASIO_CHECK(is_const_buffer_sequence<valid_const_a>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<valid_const_a>::value);

  valid_const_a b7;
  ASIO_CHECK(buffer_sequence_begin(b7) == b7.begin());
  ASIO_CHECK(buffer_sequence_end(b7) == b7.end());

  ASIO_CHECK(is_const_buffer_sequence<valid_const_b>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<valid_const_b>::value);

  valid_const_b b8;
  ASIO_CHECK(buffer_sequence_begin(b8) == b8.begin());
  ASIO_CHECK(buffer_sequence_end(b8) == b8.end());

  ASIO_CHECK(is_const_buffer_sequence<valid_mutable_a>::value);
  ASIO_CHECK(is_mutable_buffer_sequence<valid_mutable_a>::value);

  valid_mutable_a b9;
  ASIO_CHECK(buffer_sequence_begin(b9) == b9.begin());
  ASIO_CHECK(buffer_sequence_end(b9) == b9.end());

  ASIO_CHECK(is_const_buffer_sequence<valid_mutable_b>::value);
  ASIO_CHECK(is_mutable_buffer_sequence<valid_mutable_b>::value);

  valid_mutable_b b10;
  ASIO_CHECK(buffer_sequence_begin(b10) == b10.begin());
  ASIO_CHECK(buffer_sequence_end(b10) == b10.end());

  ASIO_CHECK(!is_const_buffer_sequence<invalid_const_a>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_const_a>::value);

  ASIO_CHECK(!is_const_buffer_sequence<invalid_const_b>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_const_b>::value);

  ASIO_CHECK(!is_const_buffer_sequence<invalid_const_c>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_const_c>::value);

  ASIO_CHECK(!is_const_buffer_sequence<invalid_const_d>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_const_d>::value);

  ASIO_CHECK(!is_const_buffer_sequence<invalid_const_e>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_const_e>::value);

  ASIO_CHECK(!is_const_buffer_sequence<invalid_const_f>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_const_f>::value);

  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_a>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_a>::value);

  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_b>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_b>::value);

  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_c>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_c>::value);

  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_d>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_d>::value);

  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_e>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_e>::value);

  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_f>::value);
  ASIO_CHECK(!is_mutable_buffer_sequence<invalid_mutable_f>::value);
}

} // namespace buffer_sequence

namespace buffer_literals {

void test()
{
#if defined(ASIO_HAS_USER_DEFINED_LITERALS)
  using namespace asio::buffer_literals;
  using namespace std; // For memcmp.

  asio::const_buffer b1 = ""_buf;
  ASIO_CHECK(b1.size() == 0);

  asio::const_buffer b2 = "hello"_buf;
  ASIO_CHECK(b2.size() == 5);
  ASIO_CHECK(memcmp(b2.data(), "hello", 5) == 0);

  asio::const_buffer b3 = 0x00_buf;
  ASIO_CHECK(b3.size() == 1);
  ASIO_CHECK(memcmp(b3.data(), "\x00", 1) == 0);

  asio::const_buffer b4 = 0X01_buf;
  ASIO_CHECK(b4.size() == 1);
  ASIO_CHECK(memcmp(b4.data(), "\x01", 1) == 0);

  asio::const_buffer b5 = 0xaB_buf;
  ASIO_CHECK(b5.size() == 1);
  ASIO_CHECK(memcmp(b5.data(), "\xab", 1) == 0);

  asio::const_buffer b6 = 0xABcd_buf;
  ASIO_CHECK(b6.size() == 2);
  ASIO_CHECK(memcmp(b6.data(), "\xab\xcd", 2) == 0);

  asio::const_buffer b7 = 0x01ab01cd01ef01ba01dc01fe_buf;
  ASIO_CHECK(b7.size() == 12);
  ASIO_CHECK(memcmp(b7.data(),
        "\x01\xab\x01\xcd\x01\xef\x01\xba\x01\xdc\x01\xfe", 12) == 0);

  asio::const_buffer b8 = 0b00000000_buf;
  ASIO_CHECK(b8.size() == 1);
  ASIO_CHECK(memcmp(b8.data(), "\x00", 1) == 0);

  asio::const_buffer b9 = 0B00000001_buf;
  ASIO_CHECK(b9.size() == 1);
  ASIO_CHECK(memcmp(b9.data(), "\x01", 1) == 0);

  asio::const_buffer b10 = 0B11111111_buf;
  ASIO_CHECK(b10.size() == 1);
  ASIO_CHECK(memcmp(b10.data(), "\xFF", 1) == 0);

  asio::const_buffer b11 = 0b1111000000001111_buf;
  ASIO_CHECK(b11.size() == 2);
  ASIO_CHECK(memcmp(b11.data(), "\xF0\x0F", 2) == 0);
#endif // (defined(ASIO_HAS_USER_DEFINED_LITERALS)
}

} // namespace buffer_literals

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "buffer",
  ASIO_COMPILE_TEST_CASE(buffer_compile::test)
  ASIO_TEST_CASE(buffer_copy_runtime::test)
  ASIO_TEST_CASE(buffer_sequence::test)
  ASIO_TEST_CASE(buffer_literals::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\buffered_read_stream.cpp
//
// buffered_read_stream.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/buffered_read_stream.hpp"

#include <cstring>
#include <functional>
#include "archetypes/async_result.hpp"
#include "asio/buffer.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/system_error.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
# include <boost/array.hpp>
#else // defined(ASIO_HAS_BOOST_ARRAY)
# include <array>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

typedef asio::buffered_read_stream<
    asio::ip::tcp::socket> stream_type;

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void fill_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test_compile()
{
#if defined(ASIO_HAS_BOOST_ARRAY)
  using boost::array;
#else // defined(ASIO_HAS_BOOST_ARRAY)
  using std::array;
#endif // defined(ASIO_HAS_BOOST_ARRAY)

  using namespace asio;

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    array<asio::mutable_buffer, 2> mutable_buffers = {{
        asio::buffer(mutable_char_buffer, 10),
        asio::buffer(mutable_char_buffer + 10, 10) }};
    array<asio::const_buffer, 2> const_buffers = {{
        asio::buffer(const_char_buffer, 10),
        asio::buffer(const_char_buffer + 10, 10) }};
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    stream_type stream1(ioc);
    stream_type stream2(ioc, 1024);

    stream_type::executor_type ex = stream1.get_executor();
    (void)ex;

    stream_type::lowest_layer_type& lowest_layer = stream1.lowest_layer();
    (void)lowest_layer;

    stream1.write_some(buffer(mutable_char_buffer));
    stream1.write_some(buffer(const_char_buffer));
    stream1.write_some(mutable_buffers);
    stream1.write_some(const_buffers);
    stream1.write_some(null_buffers());
    stream1.write_some(buffer(mutable_char_buffer), ec);
    stream1.write_some(buffer(const_char_buffer), ec);
    stream1.write_some(mutable_buffers, ec);
    stream1.write_some(const_buffers, ec);
    stream1.write_some(null_buffers(), ec);

    stream1.async_write_some(buffer(mutable_char_buffer), &write_some_handler);
    stream1.async_write_some(buffer(const_char_buffer), &write_some_handler);
    stream1.async_write_some(mutable_buffers, &write_some_handler);
    stream1.async_write_some(const_buffers, &write_some_handler);
    stream1.async_write_some(null_buffers(), &write_some_handler);
    int i1 = stream1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = stream1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;
    int i3 = stream1.async_write_some(mutable_buffers, lazy);
    (void)i3;
    int i4 = stream1.async_write_some(const_buffers, lazy);
    (void)i4;
    int i5 = stream1.async_write_some(null_buffers(), lazy);
    (void)i5;

    stream1.fill();
    stream1.fill(ec);

    stream1.async_fill(&fill_handler);
    int i6 = stream1.async_fill(lazy);
    (void)i6;

    stream1.read_some(buffer(mutable_char_buffer));
    stream1.read_some(mutable_buffers);
    stream1.read_some(null_buffers());
    stream1.read_some(buffer(mutable_char_buffer), ec);
    stream1.read_some(mutable_buffers, ec);
    stream1.read_some(null_buffers(), ec);

    stream1.async_read_some(buffer(mutable_char_buffer), &read_some_handler);
    stream1.async_read_some(mutable_buffers, &read_some_handler);
    stream1.async_read_some(null_buffers(), &read_some_handler);
    int i7 = stream1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i7;
    int i8 = stream1.async_read_some(mutable_buffers, lazy);
    (void)i8;
    int i9 = stream1.async_read_some(null_buffers(), lazy);
    (void)i9;
  }
  catch (std::exception&)
  {
  }
}

void test_sync_operations()
{
  using namespace std; // For memcmp.

  asio::io_context io_context;

  asio::ip::tcp::acceptor acceptor(io_context,
      asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 0));
  asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(asio::ip::address_v4::loopback());

  stream_type client_socket(io_context);
  client_socket.lowest_layer().connect(server_endpoint);

  stream_type server_socket(io_context);
  acceptor.accept(server_socket.lowest_layer());

  const char write_data[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const asio::const_buffer write_buf = asio::buffer(write_data);

  std::size_t bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    bytes_written += client_socket.write_some(
        asio::buffer(write_buf + bytes_written));
  }

  char read_data[sizeof(write_data)];
  const asio::mutable_buffer read_buf = asio::buffer(read_data);

  std::size_t bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    bytes_read += server_socket.read_some(
        asio::buffer(read_buf + bytes_read));
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    bytes_written += server_socket.write_some(
        asio::buffer(write_buf + bytes_written));
  }

  bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    bytes_read += client_socket.read_some(
        asio::buffer(read_buf + bytes_read));
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  server_socket.close();
  asio::error_code error;
  bytes_read = client_socket.read_some(
      asio::buffer(read_buf), error);

  ASIO_CHECK(bytes_read == 0);
  ASIO_CHECK(error == asio::error::eof);

  client_socket.close(error);
}

void handle_accept(const asio::error_code& e)
{
  ASIO_CHECK(!e);
}

void handle_write(const asio::error_code& e,
    std::size_t bytes_transferred,
    std::size_t* total_bytes_written)
{
  ASIO_CHECK(!e);
  if (e)
    throw asio::system_error(e); // Terminate test.
  *total_bytes_written += bytes_transferred;
}

void handle_read(const asio::error_code& e,
    std::size_t bytes_transferred,
    std::size_t* total_bytes_read)
{
  ASIO_CHECK(!e);
  if (e)
    throw asio::system_error(e); // Terminate test.
  *total_bytes_read += bytes_transferred;
}

void handle_read_eof(const asio::error_code& e,
    std::size_t bytes_transferred)
{
  ASIO_CHECK(e == asio::error::eof);
  ASIO_CHECK(bytes_transferred == 0);
}

void test_async_operations()
{
  using namespace std; // For memcmp.

  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context io_context;

  asio::ip::tcp::acceptor acceptor(io_context,
      asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 0));
  asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(asio::ip::address_v4::loopback());

  stream_type client_socket(io_context);
  client_socket.lowest_layer().connect(server_endpoint);

  stream_type server_socket(io_context);
  acceptor.async_accept(server_socket.lowest_layer(), &handle_accept);
  io_context.run();
  io_context.restart();

  const char write_data[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const asio::const_buffer write_buf = asio::buffer(write_data);

  std::size_t bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    client_socket.async_write_some(
        asio::buffer(write_buf + bytes_written),
        bindns::bind(handle_write, _1, _2, &bytes_written));
    io_context.run();
    io_context.restart();
  }

  char read_data[sizeof(write_data)];
  const asio::mutable_buffer read_buf = asio::buffer(read_data);

  std::size_t bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    server_socket.async_read_some(
        asio::buffer(read_buf + bytes_read),
        bindns::bind(handle_read, _1, _2, &bytes_read));
    io_context.run();
    io_context.restart();
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    server_socket.async_write_some(
        asio::buffer(write_buf + bytes_written),
        bindns::bind(handle_write, _1, _2, &bytes_written));
    io_context.run();
    io_context.restart();
  }

  bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    client_socket.async_read_some(
        asio::buffer(read_buf + bytes_read),
        bindns::bind(handle_read, _1, _2, &bytes_read));
    io_context.run();
    io_context.restart();
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  server_socket.close();
  client_socket.async_read_some(asio::buffer(read_buf), handle_read_eof);
}

ASIO_TEST_SUITE
(
  "buffered_read_stream",
  ASIO_COMPILE_TEST_CASE(test_compile)
  ASIO_TEST_CASE(test_sync_operations)
  ASIO_TEST_CASE(test_async_operations)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\buffered_stream.cpp
//
// buffered_stream.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/buffered_stream.hpp"

#include <cstring>
#include <functional>
#include "archetypes/async_result.hpp"
#include "asio/buffer.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/system_error.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
# include <boost/array.hpp>
#else // defined(ASIO_HAS_BOOST_ARRAY)
# include <array>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

typedef asio::buffered_stream<
    asio::ip::tcp::socket> stream_type;

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void flush_handler(const asio::error_code&, std::size_t)
{
}

void fill_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test_compile()
{
#if defined(ASIO_HAS_BOOST_ARRAY)
  using boost::array;
#else // defined(ASIO_HAS_BOOST_ARRAY)
  using std::array;
#endif // defined(ASIO_HAS_BOOST_ARRAY)

  using namespace asio;

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    array<asio::mutable_buffer, 2> mutable_buffers = {{
        asio::buffer(mutable_char_buffer, 10),
        asio::buffer(mutable_char_buffer + 10, 10) }};
    array<asio::const_buffer, 2> const_buffers = {{
        asio::buffer(const_char_buffer, 10),
        asio::buffer(const_char_buffer + 10, 10) }};
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    stream_type stream1(ioc);
    stream_type stream2(ioc, 1024, 1024);

    stream_type::executor_type ex = stream1.get_executor();
    (void)ex;

    stream_type::lowest_layer_type& lowest_layer = stream1.lowest_layer();
    (void)lowest_layer;

    stream1.write_some(buffer(mutable_char_buffer));
    stream1.write_some(buffer(const_char_buffer));
    stream1.write_some(mutable_buffers);
    stream1.write_some(const_buffers);
    stream1.write_some(null_buffers());
    stream1.write_some(buffer(mutable_char_buffer), ec);
    stream1.write_some(buffer(const_char_buffer), ec);
    stream1.write_some(mutable_buffers, ec);
    stream1.write_some(const_buffers, ec);
    stream1.write_some(null_buffers(), ec);

    stream1.async_write_some(buffer(mutable_char_buffer), &write_some_handler);
    stream1.async_write_some(buffer(const_char_buffer), &write_some_handler);
    stream1.async_write_some(mutable_buffers, &write_some_handler);
    stream1.async_write_some(const_buffers, &write_some_handler);
    stream1.async_write_some(null_buffers(), &write_some_handler);
    int i1 = stream1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = stream1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;
    int i3 = stream1.async_write_some(mutable_buffers, lazy);
    (void)i3;
    int i4 = stream1.async_write_some(const_buffers, lazy);
    (void)i4;
    int i5 = stream1.async_write_some(null_buffers(), lazy);
    (void)i5;

    stream1.flush();
    stream1.flush(ec);

    stream1.async_flush(&flush_handler);
    int i6 = stream1.async_flush(lazy);
    (void)i6;

    stream1.fill();
    stream1.fill(ec);

    stream1.async_fill(&fill_handler);
    int i7 = stream1.async_fill(lazy);
    (void)i7;

    stream1.read_some(buffer(mutable_char_buffer));
    stream1.read_some(mutable_buffers);
    stream1.read_some(null_buffers());
    stream1.read_some(buffer(mutable_char_buffer), ec);
    stream1.read_some(mutable_buffers, ec);
    stream1.read_some(null_buffers(), ec);

    stream1.async_read_some(buffer(mutable_char_buffer), &read_some_handler);
    stream1.async_read_some(mutable_buffers, &read_some_handler);
    stream1.async_read_some(null_buffers(), &read_some_handler);
    int i8 = stream1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i8;
    int i9 = stream1.async_read_some(mutable_buffers, lazy);
    (void)i9;
    int i10 = stream1.async_read_some(null_buffers(), lazy);
    (void)i10;
  }
  catch (std::exception&)
  {
  }
}

void test_sync_operations()
{
  using namespace std; // For memcmp.

  asio::io_context io_context;

  asio::ip::tcp::acceptor acceptor(io_context,
      asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 0));
  asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(asio::ip::address_v4::loopback());

  stream_type client_socket(io_context);
  client_socket.lowest_layer().connect(server_endpoint);

  stream_type server_socket(io_context);
  acceptor.accept(server_socket.lowest_layer());

  const char write_data[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const asio::const_buffer write_buf = asio::buffer(write_data);

  std::size_t bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    bytes_written += client_socket.write_some(
        asio::buffer(write_buf + bytes_written));
    client_socket.flush();
  }

  char read_data[sizeof(write_data)];
  const asio::mutable_buffer read_buf = asio::buffer(read_data);

  std::size_t bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    bytes_read += server_socket.read_some(
        asio::buffer(read_buf + bytes_read));
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    bytes_written += server_socket.write_some(
        asio::buffer(write_buf + bytes_written));
    server_socket.flush();
  }

  bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    bytes_read += client_socket.read_some(
        asio::buffer(read_buf + bytes_read));
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  server_socket.close();
  asio::error_code error;
  bytes_read = client_socket.read_some(
      asio::buffer(read_buf), error);

  ASIO_CHECK(bytes_read == 0);
  ASIO_CHECK(error == asio::error::eof);

  client_socket.close(error);
}

void handle_accept(const asio::error_code& e)
{
  ASIO_CHECK(!e);
}

void handle_write(const asio::error_code& e,
    std::size_t bytes_transferred,
    std::size_t* total_bytes_written)
{
  ASIO_CHECK(!e);
  if (e)
    throw asio::system_error(e); // Terminate test.
  *total_bytes_written += bytes_transferred;
}

void handle_flush(const asio::error_code& e)
{
  ASIO_CHECK(!e);
}

void handle_read(const asio::error_code& e,
    std::size_t bytes_transferred,
    std::size_t* total_bytes_read)
{
  ASIO_CHECK(!e);
  if (e)
    throw asio::system_error(e); // Terminate test.
  *total_bytes_read += bytes_transferred;
}

void handle_read_eof(const asio::error_code& e,
    std::size_t bytes_transferred)
{
  ASIO_CHECK(e == asio::error::eof);
  ASIO_CHECK(bytes_transferred == 0);
}

void test_async_operations()
{
  using namespace std; // For memcmp.

  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context io_context;

  asio::ip::tcp::acceptor acceptor(io_context,
      asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 0));
  asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(asio::ip::address_v4::loopback());

  stream_type client_socket(io_context);
  client_socket.lowest_layer().connect(server_endpoint);

  stream_type server_socket(io_context);
  acceptor.async_accept(server_socket.lowest_layer(), &handle_accept);
  io_context.run();
  io_context.restart();

  const char write_data[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const asio::const_buffer write_buf = asio::buffer(write_data);

  std::size_t bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    client_socket.async_write_some(
        asio::buffer(write_buf + bytes_written),
        bindns::bind(handle_write, _1, _2, &bytes_written));
    io_context.run();
    io_context.restart();
    client_socket.async_flush(
        bindns::bind(handle_flush, _1));
    io_context.run();
    io_context.restart();
  }

  char read_data[sizeof(write_data)];
  const asio::mutable_buffer read_buf = asio::buffer(read_data);

  std::size_t bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    server_socket.async_read_some(
        asio::buffer(read_buf + bytes_read),
        bindns::bind(handle_read, _1, _2, &bytes_read));
    io_context.run();
    io_context.restart();
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    server_socket.async_write_some(
        asio::buffer(write_buf + bytes_written),
        bindns::bind(handle_write, _1, _2, &bytes_written));
    io_context.run();
    io_context.restart();
    server_socket.async_flush(
        bindns::bind(handle_flush, _1));
    io_context.run();
    io_context.restart();
  }

  bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    client_socket.async_read_some(
        asio::buffer(read_buf + bytes_read),
        bindns::bind(handle_read, _1, _2, &bytes_read));
    io_context.run();
    io_context.restart();
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  server_socket.close();
  client_socket.async_read_some(asio::buffer(read_buf), handle_read_eof);
}

ASIO_TEST_SUITE
(
  "buffered_stream",
  ASIO_COMPILE_TEST_CASE(test_compile)
  ASIO_TEST_CASE(test_sync_operations)
  ASIO_TEST_CASE(test_async_operations)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\buffered_write_stream.cpp
//
// buffered_write_stream.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/buffered_write_stream.hpp"

#include <cstring>
#include <functional>
#include "archetypes/async_result.hpp"
#include "asio/buffer.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/system_error.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
# include <boost/array.hpp>
#else // defined(ASIO_HAS_BOOST_ARRAY)
# include <array>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

typedef asio::buffered_write_stream<
    asio::ip::tcp::socket> stream_type;

void write_some_handler(const asio::error_code&, std::size_t)
{
}

void flush_handler(const asio::error_code&, std::size_t)
{
}

void read_some_handler(const asio::error_code&, std::size_t)
{
}

void test_compile()
{
#if defined(ASIO_HAS_BOOST_ARRAY)
  using boost::array;
#else // defined(ASIO_HAS_BOOST_ARRAY)
  using std::array;
#endif // defined(ASIO_HAS_BOOST_ARRAY)

  using namespace asio;

  try
  {
    io_context ioc;
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    array<asio::mutable_buffer, 2> mutable_buffers = {{
        asio::buffer(mutable_char_buffer, 10),
        asio::buffer(mutable_char_buffer + 10, 10) }};
    array<asio::const_buffer, 2> const_buffers = {{
        asio::buffer(const_char_buffer, 10),
        asio::buffer(const_char_buffer + 10, 10) }};
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    stream_type stream1(ioc);
    stream_type stream2(ioc, 1024);

    stream_type::executor_type ex = stream1.get_executor();
    (void)ex;

    stream_type::lowest_layer_type& lowest_layer = stream1.lowest_layer();
    (void)lowest_layer;

    stream1.write_some(buffer(mutable_char_buffer));
    stream1.write_some(buffer(const_char_buffer));
    stream1.write_some(mutable_buffers);
    stream1.write_some(const_buffers);
    stream1.write_some(null_buffers());
    stream1.write_some(buffer(mutable_char_buffer), ec);
    stream1.write_some(buffer(const_char_buffer), ec);
    stream1.write_some(mutable_buffers, ec);
    stream1.write_some(const_buffers, ec);
    stream1.write_some(null_buffers(), ec);

    stream1.async_write_some(buffer(mutable_char_buffer), &write_some_handler);
    stream1.async_write_some(buffer(const_char_buffer), &write_some_handler);
    stream1.async_write_some(mutable_buffers, &write_some_handler);
    stream1.async_write_some(const_buffers, &write_some_handler);
    stream1.async_write_some(null_buffers(), &write_some_handler);
    int i1 = stream1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = stream1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;
    int i3 = stream1.async_write_some(mutable_buffers, lazy);
    (void)i3;
    int i4 = stream1.async_write_some(const_buffers, lazy);
    (void)i4;
    int i5 = stream1.async_write_some(null_buffers(), lazy);
    (void)i5;

    stream1.flush();
    stream1.flush(ec);

    stream1.async_flush(&flush_handler);
    int i6 = stream1.async_flush(lazy);
    (void)i6;

    stream1.read_some(buffer(mutable_char_buffer));
    stream1.read_some(mutable_buffers);
    stream1.read_some(null_buffers());
    stream1.read_some(buffer(mutable_char_buffer), ec);
    stream1.read_some(mutable_buffers, ec);
    stream1.read_some(null_buffers(), ec);

    stream1.async_read_some(buffer(mutable_char_buffer), &read_some_handler);
    stream1.async_read_some(mutable_buffers, &read_some_handler);
    stream1.async_read_some(null_buffers(), &read_some_handler);
    int i7 = stream1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i7;
    int i8 = stream1.async_read_some(mutable_buffers, lazy);
    (void)i8;
    int i9 = stream1.async_read_some(null_buffers(), lazy);
    (void)i9;
  }
  catch (std::exception&)
  {
  }
}

void test_sync_operations()
{
  using namespace std; // For memcmp.

  asio::io_context io_context;

  asio::ip::tcp::acceptor acceptor(io_context,
      asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 0));
  asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(asio::ip::address_v4::loopback());

  stream_type client_socket(io_context);
  client_socket.lowest_layer().connect(server_endpoint);

  stream_type server_socket(io_context);
  acceptor.accept(server_socket.lowest_layer());

  const char write_data[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const asio::const_buffer write_buf = asio::buffer(write_data);

  std::size_t bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    bytes_written += client_socket.write_some(
        asio::buffer(write_buf + bytes_written));
    client_socket.flush();
  }

  char read_data[sizeof(write_data)];
  const asio::mutable_buffer read_buf = asio::buffer(read_data);

  std::size_t bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    bytes_read += server_socket.read_some(
        asio::buffer(read_buf + bytes_read));
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    bytes_written += server_socket.write_some(
        asio::buffer(write_buf + bytes_written));
    server_socket.flush();
  }

  bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    bytes_read += client_socket.read_some(
        asio::buffer(read_buf + bytes_read));
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  server_socket.close();
  asio::error_code error;
  bytes_read = client_socket.read_some(
      asio::buffer(read_buf), error);

  ASIO_CHECK(bytes_read == 0);
  ASIO_CHECK(error == asio::error::eof);

  client_socket.close(error);
}

void handle_accept(const asio::error_code& e)
{
  ASIO_CHECK(!e);
}

void handle_write(const asio::error_code& e,
    std::size_t bytes_transferred,
    std::size_t* total_bytes_written)
{
  ASIO_CHECK(!e);
  if (e)
    throw asio::system_error(e); // Terminate test.
  *total_bytes_written += bytes_transferred;
}

void handle_flush(const asio::error_code& e)
{
  ASIO_CHECK(!e);
}

void handle_read(const asio::error_code& e,
    std::size_t bytes_transferred,
    std::size_t* total_bytes_read)
{
  ASIO_CHECK(!e);
  if (e)
    throw asio::system_error(e); // Terminate test.
  *total_bytes_read += bytes_transferred;
}

void handle_read_eof(const asio::error_code& e,
    std::size_t bytes_transferred)
{
  ASIO_CHECK(e == asio::error::eof);
  ASIO_CHECK(bytes_transferred == 0);
}

void test_async_operations()
{
  using namespace std; // For memcmp.

  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context io_context;

  asio::ip::tcp::acceptor acceptor(io_context,
      asio::ip::tcp::endpoint(asio::ip::tcp::v4(), 0));
  asio::ip::tcp::endpoint server_endpoint = acceptor.local_endpoint();
  server_endpoint.address(asio::ip::address_v4::loopback());

  stream_type client_socket(io_context);
  client_socket.lowest_layer().connect(server_endpoint);

  stream_type server_socket(io_context);
  acceptor.async_accept(server_socket.lowest_layer(), &handle_accept);
  io_context.run();
  io_context.restart();

  const char write_data[]
    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  const asio::const_buffer write_buf = asio::buffer(write_data);

  std::size_t bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    client_socket.async_write_some(
        asio::buffer(write_buf + bytes_written),
        bindns::bind(handle_write, _1, _2, &bytes_written));
    io_context.run();
    io_context.restart();
    client_socket.async_flush(
        bindns::bind(handle_flush, _1));
    io_context.run();
    io_context.restart();
  }

  char read_data[sizeof(write_data)];
  const asio::mutable_buffer read_buf = asio::buffer(read_data);

  std::size_t bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    server_socket.async_read_some(
        asio::buffer(read_buf + bytes_read),
        bindns::bind(handle_read, _1, _2, &bytes_read));
    io_context.run();
    io_context.restart();
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  bytes_written = 0;
  while (bytes_written < sizeof(write_data))
  {
    server_socket.async_write_some(
        asio::buffer(write_buf + bytes_written),
        bindns::bind(handle_write, _1, _2, &bytes_written));
    io_context.run();
    io_context.restart();
    server_socket.async_flush(
        bindns::bind(handle_flush, _1));
    io_context.run();
    io_context.restart();
  }

  bytes_read = 0;
  while (bytes_read < sizeof(read_data))
  {
    client_socket.async_read_some(
        asio::buffer(read_buf + bytes_read),
        bindns::bind(handle_read, _1, _2, &bytes_read));
    io_context.run();
    io_context.restart();
  }

  ASIO_CHECK(bytes_written == sizeof(write_data));
  ASIO_CHECK(bytes_read == sizeof(read_data));
  ASIO_CHECK(memcmp(write_data, read_data, sizeof(write_data)) == 0);

  server_socket.close();
  client_socket.async_read_some(asio::buffer(read_buf), handle_read_eof);
}

ASIO_TEST_SUITE
(
  "buffered_write_stream",
  ASIO_COMPILE_TEST_CASE(test_compile)
  ASIO_TEST_CASE(test_sync_operations)
  ASIO_TEST_CASE(test_async_operations)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\buffers_iterator.cpp
//
// buffers_iterator.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/buffers_iterator.hpp"

#include <array>
#include "asio/buffer.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

// buffers_iterator_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all operations on the buffers_iterator compile
// and link correctly. Runtime failures are ignored.

namespace buffers_iterator_compile {

using std::array;
using std::vector;
using namespace asio;

void test()
{
  try
  {
    char data1[16], data2[16];
    const char cdata1[16] = "", cdata2[16] = "";
    mutable_buffer mb1 = buffer(data1);
    array<mutable_buffer, 2> mb2 = {{ buffer(data1), buffer(data2) }};
    std::vector<mutable_buffer> mb3;
    mb3.push_back(buffer(data1));
    const_buffer cb1 = buffer(cdata1);
    array<const_buffer, 2> cb2 = {{ buffer(cdata1), buffer(cdata2) }};
    vector<const_buffer> cb3;
    cb3.push_back(buffer(cdata1));


    // buffers_iterator constructors.

    buffers_iterator<mutable_buffer, char> bi1;
    buffers_iterator<mutable_buffer, const char> bi2;
    buffers_iterator<array<mutable_buffer, 2>, char> bi3;
    buffers_iterator<array<mutable_buffer, 2>, const char> bi4;
    buffers_iterator<vector<mutable_buffer>, char> bi5;
    buffers_iterator<vector<mutable_buffer>, const char> bi6;
    buffers_iterator<const_buffer, char> bi7;
    buffers_iterator<const_buffer, const char> bi8;
    buffers_iterator<array<const_buffer, 2>, char> bi9;
    buffers_iterator<array<const_buffer, 2>, const char> bi10;
    buffers_iterator<vector<const_buffer>, char> bi11;
    buffers_iterator<vector<const_buffer>, const char> bi12;

    buffers_iterator<mutable_buffer, char> bi13(
        buffers_iterator<mutable_buffer, char>::begin(mb1));
    buffers_iterator<mutable_buffer, const char> bi14(
        buffers_iterator<mutable_buffer, const char>::begin(mb1));
    buffers_iterator<array<mutable_buffer, 2>, char> bi15(
        buffers_iterator<array<mutable_buffer, 2>, char>::begin(mb2));
    buffers_iterator<array<mutable_buffer, 2>, const char> bi16(
        buffers_iterator<array<mutable_buffer, 2>, const char>::begin(mb2));
    buffers_iterator<vector<mutable_buffer>, char> bi17(
        buffers_iterator<vector<mutable_buffer>, char>::begin(mb3));
    buffers_iterator<vector<mutable_buffer>, const char> bi18(
        buffers_iterator<vector<mutable_buffer>, const char>::begin(mb3));
    buffers_iterator<const_buffer, char> bi19(
        buffers_iterator<const_buffer, char>::begin(cb1));
    buffers_iterator<const_buffer, const char> bi20(
        buffers_iterator<const_buffer, const char>::begin(cb1));
    buffers_iterator<array<const_buffer, 2>, char> bi21(
        buffers_iterator<array<const_buffer, 2>, char>::begin(cb2));
    buffers_iterator<array<const_buffer, 2>, const char> bi22(
        buffers_iterator<array<const_buffer, 2>, const char>::begin(cb2));
    buffers_iterator<vector<const_buffer>, char> bi23(
        buffers_iterator<vector<const_buffer>, char>::begin(cb3));
    buffers_iterator<vector<const_buffer>, const char> bi24(
        buffers_iterator<vector<const_buffer>, const char>::begin(cb3));

    // buffers_iterator member functions.

    bi1 = buffers_iterator<mutable_buffer, char>::begin(mb1);
    bi2 = buffers_iterator<mutable_buffer, const char>::begin(mb1);
    bi3 = buffers_iterator<array<mutable_buffer, 2>, char>::begin(mb2);
    bi4 = buffers_iterator<array<mutable_buffer, 2>, const char>::begin(mb2);
    bi5 = buffers_iterator<vector<mutable_buffer>, char>::begin(mb3);
    bi6 = buffers_iterator<vector<mutable_buffer>, const char>::begin(mb3);
    bi7 = buffers_iterator<const_buffer, char>::begin(cb1);
    bi8 = buffers_iterator<const_buffer, const char>::begin(cb1);
    bi9 = buffers_iterator<array<const_buffer, 2>, char>::begin(cb2);
    bi10 = buffers_iterator<array<const_buffer, 2>, const char>::begin(cb2);
    bi11 = buffers_iterator<vector<const_buffer>, char>::begin(cb3);
    bi12 = buffers_iterator<vector<const_buffer>, const char>::begin(cb3);

    bi1 = buffers_iterator<mutable_buffer, char>::end(mb1);
    bi2 = buffers_iterator<mutable_buffer, const char>::end(mb1);
    bi3 = buffers_iterator<array<mutable_buffer, 2>, char>::end(mb2);
    bi4 = buffers_iterator<array<mutable_buffer, 2>, const char>::end(mb2);
    bi5 = buffers_iterator<vector<mutable_buffer>, char>::end(mb3);
    bi6 = buffers_iterator<vector<mutable_buffer>, const char>::end(mb3);
    bi7 = buffers_iterator<const_buffer, char>::end(cb1);
    bi8 = buffers_iterator<const_buffer, const char>::end(cb1);
    bi9 = buffers_iterator<array<const_buffer, 2>, char>::end(cb2);
    bi10 = buffers_iterator<array<const_buffer, 2>, const char>::end(cb2);
    bi11 = buffers_iterator<vector<const_buffer>, char>::end(cb3);
    bi12 = buffers_iterator<vector<const_buffer>, const char>::end(cb3);

    // buffers_iterator related functions.

    bi1 = buffers_begin(mb1);
    bi3 = buffers_begin(mb2);
    bi5 = buffers_begin(mb3);
    bi7 = buffers_begin(cb1);
    bi9 = buffers_begin(cb2);
    bi11 = buffers_begin(cb3);

    bi1 = buffers_end(mb1);
    bi3 = buffers_end(mb2);
    bi5 = buffers_end(mb3);
    bi7 = buffers_end(cb1);
    bi9 = buffers_end(cb2);
    bi11 = buffers_end(cb3);

    // RandomAccessIterator operations.

    --bi1;
    --bi2;
    --bi3;
    --bi4;
    --bi5;
    --bi6;
    --bi7;
    --bi8;
    --bi9;
    --bi10;
    --bi11;
    --bi12;

    ++bi1;
    ++bi2;
    ++bi3;
    ++bi4;
    ++bi5;
    ++bi6;
    ++bi7;
    ++bi8;
    ++bi9;
    ++bi10;
    ++bi11;
    ++bi12;

    bi1--;
    bi2--;
    bi3--;
    bi4--;
    bi5--;
    bi6--;
    bi7--;
    bi8--;
    bi9--;
    bi10--;
    bi11--;
    bi12--;

    bi1++;
    bi2++;
    bi3++;
    bi4++;
    bi5++;
    bi6++;
    bi7++;
    bi8++;
    bi9++;
    bi10++;
    bi11++;
    bi12++;

    bi1 -= 1;
    bi2 -= 1;
    bi3 -= 1;
    bi4 -= 1;
    bi5 -= 1;
    bi6 -= 1;
    bi7 -= 1;
    bi8 -= 1;
    bi9 -= 1;
    bi10 -= 1;
    bi11 -= 1;
    bi12 -= 1;

    bi1 += 1;
    bi2 += 1;
    bi3 += 1;
    bi4 += 1;
    bi5 += 1;
    bi6 += 1;
    bi7 += 1;
    bi8 += 1;
    bi9 += 1;
    bi10 += 1;
    bi11 += 1;
    bi12 += 1;

    bi1 = bi1 - 1;
    bi2 = bi2 - 1;
    bi3 = bi3 - 1;
    bi4 = bi4 - 1;
    bi5 = bi5 - 1;
    bi6 = bi6 - 1;
    bi7 = bi7 - 1;
    bi8 = bi8 - 1;
    bi9 = bi9 - 1;
    bi10 = bi10 - 1;
    bi11 = bi11 - 1;
    bi12 = bi12 - 1;

    bi1 = bi1 + 1;
    bi2 = bi2 + 1;
    bi3 = bi3 + 1;
    bi4 = bi4 + 1;
    bi5 = bi5 + 1;
    bi6 = bi6 + 1;
    bi7 = bi7 + 1;
    bi8 = bi8 + 1;
    bi9 = bi9 + 1;
    bi10 = bi10 + 1;
    bi11 = bi11 + 1;
    bi12 = bi12 + 1;

    bi1 = (-1) + bi1;
    bi2 = (-1) + bi2;
    bi3 = (-1) + bi3;
    bi4 = (-1) + bi4;
    bi5 = (-1) + bi5;
    bi6 = (-1) + bi6;
    bi7 = (-1) + bi7;
    bi8 = (-1) + bi8;
    bi9 = (-1) + bi9;
    bi10 = (-1) + bi10;
    bi11 = (-1) + bi11;
    bi12 = (-1) + bi12;

    (void)static_cast<std::ptrdiff_t>(bi13 - bi1);
    (void)static_cast<std::ptrdiff_t>(bi14 - bi2);
    (void)static_cast<std::ptrdiff_t>(bi15 - bi3);
    (void)static_cast<std::ptrdiff_t>(bi16 - bi4);
    (void)static_cast<std::ptrdiff_t>(bi17 - bi5);
    (void)static_cast<std::ptrdiff_t>(bi18 - bi6);
    (void)static_cast<std::ptrdiff_t>(bi19 - bi7);
    (void)static_cast<std::ptrdiff_t>(bi20 - bi8);
    (void)static_cast<std::ptrdiff_t>(bi21 - bi9);
    (void)static_cast<std::ptrdiff_t>(bi22 - bi10);
    (void)static_cast<std::ptrdiff_t>(bi23 - bi11);
    (void)static_cast<std::ptrdiff_t>(bi24 - bi12);
  }
  catch (std::exception&)
  {
  }
}

} // namespace buffers_iterator_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "buffers_iterator",
  ASIO_COMPILE_TEST_CASE(buffers_iterator_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\cancellation_signal.cpp
//
// cancellation_signal.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/cancellation_signal.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "cancellation_signal",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\cancellation_state.cpp
//
// cancellation_state.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/cancellation_state.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "cancellation_state",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\cancellation_type.cpp
//
// cancellation_type.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/cancellation_type.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "cancellation_type",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\co_spawn.cpp
//
// co_spawn.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/co_spawn.hpp"

#include "unit_test.hpp"

#if defined(ASIO_HAS_CO_AWAIT)

#include <stdexcept>
#include "asio/any_completion_handler.hpp"
#include "asio/bind_cancellation_slot.hpp"
#include "asio/io_context.hpp"

asio::awaitable<void> void_returning_coroutine()
{
  co_return;
}

asio::awaitable<int> int_returning_coroutine()
{
  co_return 42;
}

void test_co_spawn_with_any_completion_handler()
{
  asio::io_context ctx;

  bool called = false;
  asio::co_spawn(ctx, void_returning_coroutine(),
      asio::any_completion_handler<void(std::exception_ptr)>(
        [&](std::exception_ptr)
        {
          called = true;
        }));

  ASIO_CHECK(!called);

  ctx.run();

  ASIO_CHECK(called);

  int result = 0;
  asio::co_spawn(ctx, int_returning_coroutine(),
      asio::any_completion_handler<void(std::exception_ptr, int)>(
        [&](std::exception_ptr, int i)
        {
          result = i;
        }));

  ASIO_CHECK(result == 0);

  ctx.restart();
  ctx.run();

  ASIO_CHECK(result == 42);
}

void test_co_spawn_immediate_cancel()
{
  asio::cancellation_signal sig;
  asio::io_context ctx;

  std::exception_ptr result = nullptr;
  bool called = false;
  asio::co_spawn(ctx, void_returning_coroutine(),
      asio::bind_cancellation_slot(sig.slot(),
        [&](std::exception_ptr e)
        {
          result = e;
          called = true;
        }));

  ASIO_CHECK(!called);
  ASIO_CHECK(result == nullptr);

  sig.emit(asio::cancellation_type::all);
  ctx.run();

  ASIO_CHECK(called);
  ASIO_CHECK(result != nullptr);

  result = nullptr;
  called = false;
  asio::co_spawn(ctx, int_returning_coroutine(),
      asio::bind_cancellation_slot(sig.slot(),
        [&](std::exception_ptr e, int i)
        {
          ASIO_CHECK(i != 42);
          result = e;
          called = true;
        }));

  ASIO_CHECK(!called);
  ASIO_CHECK(result == nullptr);

  sig.emit(asio::cancellation_type::all);
  ctx.restart();
  ctx.run();

  ASIO_CHECK(called);
  ASIO_CHECK(result != nullptr);
}

ASIO_TEST_SUITE
(
  "co_spawn",
  ASIO_TEST_CASE(test_co_spawn_with_any_completion_handler)
  ASIO_TEST_CASE(test_co_spawn_immediate_cancel)
)

#else // defined(ASIO_HAS_CO_AWAIT)

ASIO_TEST_SUITE
(
  "co_spawn",
  ASIO_TEST_CASE(null_test)
)

#endif // defined(ASIO_HAS_CO_AWAIT)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\completion_condition.cpp
//
// completion_condition.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/completion_condition.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "completion_condition",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\compose.cpp
//
// compose.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/compose.hpp"

#include <functional>
#include "asio/bind_cancellation_slot.hpp"
#include "asio/cancellation_signal.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/system_timer.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

class impl_0_completion_args
{
public:
  explicit impl_0_completion_args(asio::io_context& ioc)
    : ioc_(ioc),
      state_(starting)
  {
  }

  template <typename Self>
  void operator()(Self& self)
  {
    switch (state_)
    {
    case starting:
      state_ = posting;
      asio::post(ioc_, static_cast<Self&&>(self));
      break;
    case posting:
      self.complete();
      break;
    default:
      break;
    }
  }

private:
  asio::io_context& ioc_;
  enum { starting, posting } state_;
};

template <typename CompletionToken>
ASIO_INITFN_RESULT_TYPE(CompletionToken, void())
async_0_completion_args(asio::io_context& ioc,
    CompletionToken&& token)
{
  return asio::async_compose<CompletionToken, void()>(
      impl_0_completion_args(ioc), token);
}

void compose_0_args_handler(int* count)
{
  ++(*count);
}

struct compose_0_args_lvalue_handler
{
  int* count_;

  void operator()()
  {
    ++(*count_);
  }
};

void compose_0_completion_args_test()
{
  namespace bindns = std;

  asio::io_context ioc;
  int count = 0;

  async_0_completion_args(ioc, bindns::bind(&compose_0_args_handler, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  ioc.restart();
  count = 0;

  compose_0_args_lvalue_handler lvalue_handler = { &count };
  async_0_completion_args(ioc, lvalue_handler);

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
}

//------------------------------------------------------------------------------

class impl_1_completion_arg
{
public:
  explicit impl_1_completion_arg(asio::io_context& ioc)
    : ioc_(ioc),
      state_(starting)
  {
  }

  template <typename Self>
  void operator()(Self& self)
  {
    switch (state_)
    {
    case starting:
      state_ = posting;
      asio::post(ioc_, static_cast<Self&&>(self));
      break;
    case posting:
      self.complete(42);
      break;
    default:
      break;
    }
  }

private:
  asio::io_context& ioc_;
  enum { starting, posting } state_;
};

template <typename CompletionToken>
ASIO_INITFN_RESULT_TYPE(CompletionToken, void(int))
async_1_completion_arg(asio::io_context& ioc,
    CompletionToken&& token)
{
  return asio::async_compose<CompletionToken, void(int)>(
      impl_1_completion_arg(ioc), token);
}

void compose_1_arg_handler(int* count, int* result_out, int result)
{
  ++(*count);
  *result_out = result;
}

struct compose_1_arg_lvalue_handler
{
  int* count_;
  int* result_out_;

  void operator()(int result)
  {
    ++(*count_);
    *result_out_ = result;
  }
};

void compose_1_completion_arg_test()
{
  namespace bindns = std;
  using bindns::placeholders::_1;

  asio::io_context ioc;
  int count = 0;
  int result = 0;

  async_1_completion_arg(ioc,
      bindns::bind(&compose_1_arg_handler, &count, &result, _1));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);
  ASIO_CHECK(result == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == 42);

  ioc.restart();
  count = 0;
  result = 0;

  compose_1_arg_lvalue_handler lvalue_handler = { &count, &result };
  async_1_completion_arg(ioc, lvalue_handler);

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);
  ASIO_CHECK(result == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == 42);
}

//------------------------------------------------------------------------------

typedef asio::enable_terminal_cancellation default_filter;

template <typename CancellationFilter>
class impl_cancellable
{
public:
  explicit impl_cancellable(CancellationFilter cancellation_filter,
      asio::system_timer& timer)
    : cancellation_filter_(cancellation_filter),
      timer_(timer),
      state_(starting)
  {
  }

  template <typename Self>
  void operator()(Self& self,
      const asio::error_code& ec = asio::error_code())
  {
    switch (state_)
    {
    case starting:
      if (!asio::is_same<CancellationFilter, default_filter>::value)
        self.reset_cancellation_state(cancellation_filter_);
      state_ = waiting;
      timer_.expires_after(asio::chrono::milliseconds(100));
      timer_.async_wait(static_cast<Self&&>(self));
      break;
    case waiting:
      self.complete(!ec);
      break;
    default:
      break;
    }
  }

private:
  CancellationFilter cancellation_filter_;
  asio::system_timer& timer_;
  enum { starting, waiting } state_;
};

template <typename CancellationFilter, typename CompletionToken>
ASIO_INITFN_RESULT_TYPE(CompletionToken, void(bool))
async_cancellable(CancellationFilter cancellation_filter,
    asio::system_timer& timer,
    CompletionToken&& token)
{
  return asio::async_compose<CompletionToken, void(bool)>(
      impl_cancellable<CancellationFilter>(cancellation_filter, timer), token);
}

void compose_partial_cancellation_handler(
    int* count, bool* result_out, bool result)
{
  ++(*count);
  *result_out = result;
}

void compose_default_cancellation_test()
{
  namespace bindns = std;
  using bindns::placeholders::_1;

  asio::io_context ioc;
  asio::system_timer timer(ioc);
  asio::cancellation_signal signal;
  int count = 0;
  bool result = false;

  async_cancellable(default_filter(), timer,
      bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1));

  ioc.run();

  // No cancellation, operation completes successfully.

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == true);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(default_filter(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Total cancellation unsupported. Operation completes successfully.
  signal.emit(asio::cancellation_type::total);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == true);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(default_filter(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Partial cancellation unsupported. Operation completes successfully.
  signal.emit(asio::cancellation_type::partial);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == true);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(default_filter(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Terminal cancellation works. Operation completes with failure.
  signal.emit(asio::cancellation_type::terminal);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == false);
}

void compose_partial_cancellation_test()
{
  namespace bindns = std;
  using bindns::placeholders::_1;

  asio::io_context ioc;
  asio::system_timer timer(ioc);
  asio::cancellation_signal signal;
  int count = 0;
  bool result = false;

  async_cancellable(asio::enable_partial_cancellation(), timer,
      bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1));

  ioc.run();

  // No cancellation, operation completes successfully.

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == true);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(asio::enable_partial_cancellation(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Total cancellation unsupported. Operation completes successfully.
  signal.emit(asio::cancellation_type::total);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == true);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(asio::enable_partial_cancellation(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Partial cancellation works. Operation completes with failure.
  signal.emit(asio::cancellation_type::partial);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == false);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(asio::enable_partial_cancellation(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Terminal cancellation works. Operation completes with failure.
  signal.emit(asio::cancellation_type::terminal);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == false);
}

void compose_total_cancellation_test()
{
  namespace bindns = std;
  using bindns::placeholders::_1;

  asio::io_context ioc;
  asio::system_timer timer(ioc);
  asio::cancellation_signal signal;
  int count = 0;
  bool result = false;

  async_cancellable(asio::enable_total_cancellation(), timer,
      bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1));

  ioc.run();

  // No cancellation, operation completes successfully.

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == true);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(asio::enable_total_cancellation(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Total cancellation works. Operation completes with failure.
  signal.emit(asio::cancellation_type::total);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == false);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(asio::enable_total_cancellation(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Partial cancellation works. Operation completes with failure.
  signal.emit(asio::cancellation_type::partial);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == false);

  ioc.restart();
  count = 0;
  result = 0;

  async_cancellable(asio::enable_total_cancellation(), timer,
      asio::bind_cancellation_slot(signal.slot(),
        bindns::bind(&compose_partial_cancellation_handler,
        &count, &result, _1)));

  // Terminal cancellation works. Operation completes with failure.
  signal.emit(asio::cancellation_type::terminal);

  ioc.run();

  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
  ASIO_CHECK(result == false);
}

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "compose",
  ASIO_TEST_CASE(compose_0_completion_args_test)
  ASIO_TEST_CASE(compose_1_completion_arg_test)
  ASIO_TEST_CASE(compose_default_cancellation_test)
  ASIO_TEST_CASE(compose_partial_cancellation_test)
  ASIO_TEST_CASE(compose_total_cancellation_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\connect_pipe.cpp
//
// connect_pipe.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/connect_pipe.hpp"

#include <functional>
#include <string>
#include "asio/io_context.hpp"
#include "asio/read.hpp"
#include "asio/readable_pipe.hpp"
#include "asio/writable_pipe.hpp"
#include "asio/write.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

// connect_pipe_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all connect_pipe functions compile and link
// correctly. Runtime failures are ignored.

namespace connect_pipe_compile {

void test()
{
#if defined(ASIO_HAS_PIPE)
  using namespace asio;

  try
  {
    asio::io_context io_context;
    asio::error_code ec1;

    readable_pipe p1(io_context);
    writable_pipe p2(io_context);
    connect_pipe(p1, p2);

    readable_pipe p3(io_context);
    writable_pipe p4(io_context);
    connect_pipe(p3, p4, ec1);
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_PIPE)
}

} // namespace connect_pipe_compile

//------------------------------------------------------------------------------

// connect_pipe_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that connect_pipe operates correctly at runtime.

namespace connect_pipe_runtime {

static const char write_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void handle_read(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!err);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
}

void handle_write(const asio::error_code& err,
    size_t bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!err);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
}

void test()
{
#if defined(ASIO_HAS_PIPE)
  using namespace std; // For memcmp.
  using namespace asio;

  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  try
  {
    asio::io_context io_context;
    asio::error_code ec1;
    asio::error_code ec2;

    readable_pipe p1(io_context);
    writable_pipe p2(io_context);
    connect_pipe(p1, p2);

    std::string data1 = write_data;
    asio::write(p2, asio::buffer(data1));

    std::string data2;
    data2.resize(data1.size());
    asio::read(p1, asio::buffer(data2));

    ASIO_CHECK(data1 == data2);

    char read_buffer[sizeof(write_data)];
    bool read_completed = false;
    asio::async_read(p1,
        asio::buffer(read_buffer),
        bindns::bind(handle_read,
          _1, _2, &read_completed));

    bool write_completed = false;
    asio::async_write(p2,
        asio::buffer(write_data),
        bindns::bind(handle_write,
          _1, _2, &write_completed));

    io_context.run();

    ASIO_CHECK(read_completed);
    ASIO_CHECK(write_completed);
    ASIO_CHECK(memcmp(read_buffer, write_data, sizeof(write_data)) == 0);
  }
  catch (std::exception&)
  {
    ASIO_CHECK(false);
  }
#endif // defined(ASIO_HAS_PIPE)
}

} // namespace connect_pipe_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "connect_pipe",
  ASIO_COMPILE_TEST_CASE(connect_pipe_compile::test)
  ASIO_TEST_CASE(connect_pipe_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\connect.cpp
//
// connect.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/connect.hpp"

#include <functional>
#include <vector>
#include "asio/detail/thread.hpp"
#include "asio/ip/tcp.hpp"
#include "unit_test.hpp"

namespace bindns = std;
using bindns::placeholders::_1;
using bindns::placeholders::_2;

class connection_sink
{
public:
  connection_sink()
    : acceptor_(io_context_,
        asio::ip::tcp::endpoint(
          asio::ip::address_v4::loopback(), 0)),
      target_endpoint_(acceptor_.local_endpoint()),
      socket_(io_context_),
      thread_(bindns::bind(&connection_sink::run, this))
  {
  }

  ~connection_sink()
  {
    io_context_.stop();
    thread_.join();
  }

  asio::ip::tcp::endpoint target_endpoint()
  {
    return target_endpoint_;
  }

private:
  void run()
  {
    io_context_.run();
  }

  void handle_accept()
  {
    socket_.close();
    acceptor_.async_accept(socket_,
        bindns::bind(&connection_sink::handle_accept, this));
  }

  asio::io_context io_context_;
  asio::ip::tcp::acceptor acceptor_;
  asio::ip::tcp::endpoint target_endpoint_;
  asio::ip::tcp::socket socket_;
  asio::detail::thread thread_;
};

bool true_cond_1(const asio::error_code& /*ec*/,
    const asio::ip::tcp::endpoint& /*endpoint*/)
{
  return true;
}

struct true_cond_2
{
  template <typename Endpoint>
  bool operator()(const asio::error_code& /*ec*/,
      const Endpoint& /*endpoint*/)
  {
    return true;
  }
};

std::vector<asio::ip::tcp::endpoint>::const_iterator legacy_true_cond_1(
    const asio::error_code& /*ec*/,
    std::vector<asio::ip::tcp::endpoint>::const_iterator next)
{
  return next;
}

struct legacy_true_cond_2
{
  template <typename Iterator>
  Iterator operator()(const asio::error_code& /*ec*/, Iterator next)
  {
    return next;
  }
};

bool false_cond(const asio::error_code& /*ec*/,
    const asio::ip::tcp::endpoint& /*endpoint*/)
{
  return false;
}

void range_handler(const asio::error_code& ec,
    const asio::ip::tcp::endpoint& endpoint,
    asio::error_code* out_ec,
    asio::ip::tcp::endpoint* out_endpoint)
{
  *out_ec = ec;
  *out_endpoint = endpoint;
}

void iter_handler(const asio::error_code& ec,
    std::vector<asio::ip::tcp::endpoint>::const_iterator iter,
    asio::error_code* out_ec,
    std::vector<asio::ip::tcp::endpoint>::const_iterator* out_iter)
{
  *out_ec = ec;
  *out_iter = iter;
}

void test_connect_range()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  asio::ip::tcp::endpoint result;

  try
  {
    result = asio::connect(socket, endpoints);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints);
  ASIO_CHECK(result == endpoints[0]);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints);
  ASIO_CHECK(result == endpoints[0]);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, endpoints);
  ASIO_CHECK(result == endpoints[1]);
}

void test_connect_range_ec()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  asio::ip::tcp::endpoint result;
  asio::error_code ec;

  result = asio::connect(socket, endpoints, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints, ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints, ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, endpoints, ec);
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);
}

void test_connect_range_cond()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  asio::ip::tcp::endpoint result;

  try
  {
    result = asio::connect(socket, endpoints, true_cond_1);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, endpoints, true_cond_2());
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, endpoints, legacy_true_cond_1);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, endpoints, legacy_true_cond_2());
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, endpoints, false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints, true_cond_1);
  ASIO_CHECK(result == endpoints[0]);

  result = asio::connect(socket, endpoints, true_cond_2());
  ASIO_CHECK(result == endpoints[0]);

  result = asio::connect(socket, endpoints, legacy_true_cond_1);
  ASIO_CHECK(result == endpoints[0]);

  result = asio::connect(socket, endpoints, legacy_true_cond_2());
  ASIO_CHECK(result == endpoints[0]);

  try
  {
    result = asio::connect(socket, endpoints, false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints, true_cond_1);
  ASIO_CHECK(result == endpoints[0]);

  result = asio::connect(socket, endpoints, true_cond_2());
  ASIO_CHECK(result == endpoints[0]);

  result = asio::connect(socket, endpoints, legacy_true_cond_1);
  ASIO_CHECK(result == endpoints[0]);

  result = asio::connect(socket, endpoints, legacy_true_cond_2());
  ASIO_CHECK(result == endpoints[0]);

  try
  {
    result = asio::connect(socket, endpoints, false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, endpoints, true_cond_1);
  ASIO_CHECK(result == endpoints[1]);

  result = asio::connect(socket, endpoints, true_cond_2());
  ASIO_CHECK(result == endpoints[1]);

  result = asio::connect(socket, endpoints, legacy_true_cond_1);
  ASIO_CHECK(result == endpoints[1]);

  result = asio::connect(socket, endpoints, legacy_true_cond_2());
  ASIO_CHECK(result == endpoints[1]);

  try
  {
    result = asio::connect(socket, endpoints, false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }
}

void test_connect_range_cond_ec()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  asio::ip::tcp::endpoint result;
  asio::error_code ec;

  result = asio::connect(socket, endpoints, true_cond_1, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, endpoints, true_cond_2(), ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, endpoints, legacy_true_cond_1, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, endpoints, false_cond, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints, true_cond_1, ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, true_cond_2(), ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, legacy_true_cond_1, ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, false_cond, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, endpoints, true_cond_1, ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, true_cond_2(), ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, legacy_true_cond_1, ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, false_cond, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, endpoints, true_cond_1, ec);
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, true_cond_2(), ec);
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, legacy_true_cond_1, ec);
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, legacy_true_cond_2(), ec);
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, endpoints, false_cond, ec);
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);
}

void test_connect_iter()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  const std::vector<asio::ip::tcp::endpoint>& cendpoints = endpoints;
  std::vector<asio::ip::tcp::endpoint>::const_iterator result;

  try
  {
    result = asio::connect(socket, cendpoints.begin(), cendpoints.end());
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, cendpoints.begin(), cendpoints.end());
  ASIO_CHECK(result == cendpoints.begin());

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, cendpoints.begin(), cendpoints.end());
  ASIO_CHECK(result == cendpoints.begin());

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, cendpoints.begin(), cendpoints.end());
  ASIO_CHECK(result == cendpoints.begin() + 1);
}

void test_connect_iter_ec()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  const std::vector<asio::ip::tcp::endpoint>& cendpoints = endpoints;
  std::vector<asio::ip::tcp::endpoint>::const_iterator result;
  asio::error_code ec;

  result = asio::connect(socket,
      cendpoints.begin(), cendpoints.end(), ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket,
      cendpoints.begin(), cendpoints.end(), ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket,
      cendpoints.begin(), cendpoints.end(), ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket,
      cendpoints.begin(), cendpoints.end(), ec);
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);
}

void test_connect_iter_cond()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  const std::vector<asio::ip::tcp::endpoint>& cendpoints = endpoints;
  std::vector<asio::ip::tcp::endpoint>::const_iterator result;

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), true_cond_1);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), true_cond_2());
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), legacy_true_cond_1);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), legacy_true_cond_2());
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1);
  ASIO_CHECK(result == cendpoints.begin());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2());
  ASIO_CHECK(result == cendpoints.begin());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1);
  ASIO_CHECK(result == cendpoints.begin());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2());
  ASIO_CHECK(result == cendpoints.begin());

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1);
  ASIO_CHECK(result == cendpoints.begin());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2());
  ASIO_CHECK(result == cendpoints.begin());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1);
  ASIO_CHECK(result == cendpoints.begin());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2());
  ASIO_CHECK(result == cendpoints.begin());

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1);
  ASIO_CHECK(result == cendpoints.begin() + 1);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2());
  ASIO_CHECK(result == cendpoints.begin() + 1);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1);
  ASIO_CHECK(result == cendpoints.begin() + 1);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2());
  ASIO_CHECK(result == cendpoints.begin() + 1);

  try
  {
    result = asio::connect(socket, cendpoints.begin(),
        cendpoints.end(), false_cond);
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::not_found);
  }
}

void test_connect_iter_cond_ec()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  const std::vector<asio::ip::tcp::endpoint>& cendpoints = endpoints;
  std::vector<asio::ip::tcp::endpoint>::const_iterator result;
  asio::error_code ec;

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), false_cond, ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), false_cond, ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), false_cond, ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_1, ec);
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), legacy_true_cond_2(), ec);
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  result = asio::connect(socket, cendpoints.begin(),
      cendpoints.end(), false_cond, ec);
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);
}

void test_async_connect_range()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  asio::ip::tcp::endpoint result;
  asio::error_code ec;

  asio::async_connect(socket, endpoints,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, endpoints,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, endpoints,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  asio::async_connect(socket, endpoints,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);
}

void test_async_connect_range_cond()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  asio::ip::tcp::endpoint result;
  asio::error_code ec;

  asio::async_connect(socket, endpoints, true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, endpoints, true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, endpoints, legacy_true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, endpoints, legacy_true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, endpoints, false_cond,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, endpoints, true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, legacy_true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, legacy_true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, false_cond,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, endpoints, true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, legacy_true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, legacy_true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[0]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, false_cond,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  asio::async_connect(socket, endpoints, true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, legacy_true_cond_1,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, legacy_true_cond_2(),
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == endpoints[1]);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, endpoints, false_cond,
      bindns::bind(range_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == asio::ip::tcp::endpoint());
  ASIO_CHECK(ec == asio::error::not_found);
}

void test_async_connect_iter()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  const std::vector<asio::ip::tcp::endpoint>& cendpoints = endpoints;
  std::vector<asio::ip::tcp::endpoint>::const_iterator result;
  asio::error_code ec;

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);
}

void test_async_connect_iter_cond()
{
  connection_sink sink;
  asio::io_context io_context;
  asio::ip::tcp::socket socket(io_context);
  std::vector<asio::ip::tcp::endpoint> endpoints;
  const std::vector<asio::ip::tcp::endpoint>& cendpoints = endpoints;
  std::vector<asio::ip::tcp::endpoint>::const_iterator result;
  asio::error_code ec;

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      false_cond, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      false_cond, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.push_back(sink.target_endpoint());

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin());
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      false_cond, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);

  endpoints.insert(endpoints.begin(), asio::ip::tcp::endpoint());

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_1, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      legacy_true_cond_2(), bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.begin() + 1);
  ASIO_CHECK(!ec);

  asio::async_connect(socket, cendpoints.begin(), cendpoints.end(),
      false_cond, bindns::bind(iter_handler, _1, _2, &ec, &result));
  io_context.restart();
  io_context.run();
  ASIO_CHECK(result == cendpoints.end());
  ASIO_CHECK(ec == asio::error::not_found);
}

ASIO_TEST_SUITE
(
  "connect",
  ASIO_TEST_CASE(test_connect_range)
  ASIO_TEST_CASE(test_connect_range_ec)
  ASIO_TEST_CASE(test_connect_range_cond)
  ASIO_TEST_CASE(test_connect_range_cond_ec)
  ASIO_TEST_CASE(test_connect_iter)
  ASIO_TEST_CASE(test_connect_iter_ec)
  ASIO_TEST_CASE(test_connect_iter_cond)
  ASIO_TEST_CASE(test_connect_iter_cond_ec)
  ASIO_TEST_CASE(test_async_connect_range)
  ASIO_TEST_CASE(test_async_connect_range_cond)
  ASIO_TEST_CASE(test_async_connect_iter)
  ASIO_TEST_CASE(test_async_connect_iter_cond)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\consign.cpp
//
// consign.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/consign.hpp"

#include "asio/bind_executor.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/system_timer.hpp"
#include "unit_test.hpp"

void consign_test()
{
  asio::io_context io1;
  asio::io_context io2;
  asio::system_timer timer1(io1);
  int count = 0;

  timer1.expires_after(asio::chrono::seconds(0));
  timer1.async_wait(
      asio::consign(
        asio::bind_executor(io2.get_executor(),
          [&count](asio::error_code)
          {
            ++count;
          }), 123, 321));

  ASIO_CHECK(count == 0);

  io1.run();

  ASIO_CHECK(count == 0);

  io2.run();

  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "consign",
  ASIO_TEST_CASE(consign_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\coroutine.cpp
//
// coroutine.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/coroutine.hpp"

#include "unit_test.hpp"

// Must come after all other headers.
#include "asio/yield.hpp"

//------------------------------------------------------------------------------

// Coroutine completes via yield break.

void yield_break_coro(asio::coroutine& coro)
{
  reenter (coro)
  {
    yield return;
    yield break;
  }
}

void yield_break_test()
{
  asio::coroutine coro;
  ASIO_CHECK(!coro.is_complete());
  yield_break_coro(coro);
  ASIO_CHECK(!coro.is_complete());
  yield_break_coro(coro);
  ASIO_CHECK(coro.is_complete());
}

//------------------------------------------------------------------------------

// Coroutine completes via return.

void return_coro(asio::coroutine& coro)
{
  reenter (coro)
  {
    return;
  }
}

void return_test()
{
  asio::coroutine coro;
  return_coro(coro);
  ASIO_CHECK(coro.is_complete());
}

//------------------------------------------------------------------------------

// Coroutine completes via exception.

void exception_coro(asio::coroutine& coro)
{
  reenter (coro)
  {
    throw 1;
  }
}

void exception_test()
{
  asio::coroutine coro;
  try { exception_coro(coro); } catch (int) {}
  ASIO_CHECK(coro.is_complete());
}

//------------------------------------------------------------------------------

// Coroutine completes by falling off the end.

void fall_off_end_coro(asio::coroutine& coro)
{
  reenter (coro)
  {
  }
}

void fall_off_end_test()
{
  asio::coroutine coro;
  fall_off_end_coro(coro);
  ASIO_CHECK(coro.is_complete());
}

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "coroutine",
  ASIO_TEST_CASE(yield_break_test)
  ASIO_TEST_CASE(return_test)
  ASIO_TEST_CASE(exception_test)
  ASIO_TEST_CASE(fall_off_end_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\deadline_timer.cpp
//
// deadline_timer.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/deadline_timer.hpp"

#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)

#include <boost/bind/bind.hpp>
#include "archetypes/async_result.hpp"
#include "asio/executor_work_guard.hpp"
#include "asio/io_context.hpp"
#include "asio/placeholders.hpp"
#include "asio/thread.hpp"

using namespace boost::posix_time;

void increment(int* count)
{
  ++(*count);
}

void decrement_to_zero(asio::deadline_timer* t, int* count)
{
  if (*count > 0)
  {
    --(*count);

    int before_value = *count;

    t->expires_at(t->expires_at() + seconds(1));
    t->async_wait(boost::bind(decrement_to_zero, t, count));

    // Completion cannot nest, so count value should remain unchanged.
    ASIO_CHECK(*count == before_value);
  }
}

void increment_if_not_cancelled(int* count,
    const asio::error_code& ec)
{
  if (!ec)
    ++(*count);
}

void cancel_timer(asio::deadline_timer* t)
{
  std::size_t num_cancelled = t->cancel();
  ASIO_CHECK(num_cancelled == 1);
}

void cancel_one_timer(asio::deadline_timer* t)
{
  std::size_t num_cancelled = t->cancel_one();
  ASIO_CHECK(num_cancelled == 1);
}

ptime now()
{
#if defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)
  return microsec_clock::universal_time();
#else // defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)
  return second_clock::universal_time();
#endif // defined(BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK)
}

void deadline_timer_test()
{
  asio::io_context ioc;
  int count = 0;

  ptime start = now();

  asio::deadline_timer t1(ioc, seconds(1));
  t1.wait();

  // The timer must block until after its expiry time.
  ptime end = now();
  ptime expected_end = start + seconds(1);
  ASIO_CHECK(expected_end < end || expected_end == end);

  start = now();

  asio::deadline_timer t2(ioc, seconds(1) + microseconds(500000));
  t2.wait();

  // The timer must block until after its expiry time.
  end = now();
  expected_end = start + seconds(1) + microseconds(500000);
  ASIO_CHECK(expected_end < end || expected_end == end);

  t2.expires_at(t2.expires_at() + seconds(1));
  t2.wait();

  // The timer must block until after its expiry time.
  end = now();
  expected_end += seconds(1);
  ASIO_CHECK(expected_end < end || expected_end == end);

  start = now();

  t2.expires_from_now(seconds(1) + microseconds(200000));
  t2.wait();

  // The timer must block until after its expiry time.
  end = now();
  expected_end = start + seconds(1) + microseconds(200000);
  ASIO_CHECK(expected_end < end || expected_end == end);

  start = now();

  asio::deadline_timer t3(ioc, seconds(5));
  t3.async_wait(boost::bind(increment, &count));

  // No completions can be delivered until run() is called.
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all operations have finished, and
  // this should not be until after the timer's expiry time.
  ASIO_CHECK(count == 1);
  end = now();
  expected_end = start + seconds(1);
  ASIO_CHECK(expected_end < end || expected_end == end);

  count = 3;
  start = now();

  asio::deadline_timer t4(ioc, seconds(1));
  t4.async_wait(boost::bind(decrement_to_zero, &t4, &count));

  // No completions can be delivered until run() is called.
  ASIO_CHECK(count == 3);

  ioc.restart();
  ioc.run();

  // The run() call will not return until all operations have finished, and
  // this should not be until after the timer's final expiry time.
  ASIO_CHECK(count == 0);
  end = now();
  expected_end = start + seconds(3);
  ASIO_CHECK(expected_end < end || expected_end == end);

  count = 0;
  start = now();

  asio::deadline_timer t5(ioc, seconds(10));
  t5.async_wait(boost::bind(increment_if_not_cancelled, &count,
        asio::placeholders::error));
  asio::deadline_timer t6(ioc, seconds(1));
  t6.async_wait(boost::bind(cancel_timer, &t5));

  // No completions can be delivered until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The timer should have been cancelled, so count should not have changed.
  // The total run time should not have been much more than 1 second (and
  // certainly far less than 10 seconds).
  ASIO_CHECK(count == 0);
  end = now();
  expected_end = start + seconds(2);
  ASIO_CHECK(end < expected_end);

  // Wait on the timer again without cancelling it. This time the asynchronous
  // wait should run to completion and increment the counter.
  t5.async_wait(boost::bind(increment_if_not_cancelled, &count,
        asio::placeholders::error));

  ioc.restart();
  ioc.run();

  // The timer should not have been cancelled, so count should have changed.
  // The total time since the timer was created should be more than 10 seconds.
  ASIO_CHECK(count == 1);
  end = now();
  expected_end = start + seconds(10);
  ASIO_CHECK(expected_end < end || expected_end == end);

  count = 0;
  start = now();

  // Start two waits on a timer, one of which will be cancelled. The one
  // which is not cancelled should still run to completion and increment the
  // counter.
  asio::deadline_timer t7(ioc, seconds(3));
  t7.async_wait(boost::bind(increment_if_not_cancelled, &count,
        asio::placeholders::error));
  t7.async_wait(boost::bind(increment_if_not_cancelled, &count,
        asio::placeholders::error));
  asio::deadline_timer t8(ioc, seconds(1));
  t8.async_wait(boost::bind(cancel_one_timer, &t7));

  ioc.restart();
  ioc.run();

  // One of the waits should not have been cancelled, so count should have
  // changed. The total time since the timer was created should be more than 3
  // seconds.
  ASIO_CHECK(count == 1);
  end = now();
  expected_end = start + seconds(3);
  ASIO_CHECK(expected_end < end || expected_end == end);
}

void timer_handler(const asio::error_code&)
{
}

void deadline_timer_cancel_test()
{
  static asio::io_context io_context;
  struct timer
  {
    asio::deadline_timer t;
    timer() : t(io_context) { t.expires_at(boost::posix_time::pos_infin); }
  } timers[50];

  timers[2].t.async_wait(&timer_handler);
  timers[41].t.async_wait(&timer_handler);
  for (int i = 10; i < 20; ++i)
    timers[i].t.async_wait(&timer_handler);

  ASIO_CHECK(timers[2].t.cancel() == 1);
  ASIO_CHECK(timers[41].t.cancel() == 1);
  for (int i = 10; i < 20; ++i)
    ASIO_CHECK(timers[i].t.cancel() == 1);
}

struct custom_allocation_timer_handler
{
  custom_allocation_timer_handler(int* count) : count_(count) {}
  void operator()(const asio::error_code&) {}
  int* count_;

  template <typename T>
  struct allocator
  {
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    template <typename U>
    struct rebind
    {
      typedef allocator<U> other;
    };

    explicit allocator(int* count) noexcept
      : count_(count)
    {
    }

    allocator(const allocator& other) noexcept
      : count_(other.count_)
    {
    }

    template <typename U>
    allocator(const allocator<U>& other) noexcept
      : count_(other.count_)
    {
    }

    pointer allocate(size_type n, const void* = 0)
    {
      ++(*count_);
      return static_cast<T*>(::operator new(sizeof(T) * n));
    }

    void deallocate(pointer p, size_type)
    {
      --(*count_);
      ::operator delete(p);
    }

    size_type max_size() const
    {
      return ~size_type(0);
    }

    void construct(pointer p, const T& v)
    {
      new (p) T(v);
    }

    void destroy(pointer p)
    {
      p->~T();
    }

    int* count_;
  };

  typedef allocator<int> allocator_type;

  allocator_type get_allocator() const noexcept
  {
    return allocator_type(count_);
  }
};

void deadline_timer_custom_allocation_test()
{
  static asio::io_context io_context;
  struct timer
  {
    asio::deadline_timer t;
    timer() : t(io_context) {}
  } timers[100];

  int allocation_count = 0;

  for (int i = 0; i < 50; ++i)
  {
    timers[i].t.expires_at(boost::posix_time::pos_infin);
    timers[i].t.async_wait(custom_allocation_timer_handler(&allocation_count));
  }

  for (int i = 50; i < 100; ++i)
  {
    timers[i].t.expires_at(boost::posix_time::neg_infin);
    timers[i].t.async_wait(custom_allocation_timer_handler(&allocation_count));
  }

  for (int i = 0; i < 50; ++i)
    timers[i].t.cancel();

  io_context.run();

  ASIO_CHECK(allocation_count == 0);
}

void io_context_run(asio::io_context* ioc)
{
  ioc->run();
}

void deadline_timer_thread_test()
{
  asio::io_context ioc;
  asio::executor_work_guard<asio::io_context::executor_type> work
    = asio::make_work_guard(ioc);
  asio::deadline_timer t1(ioc);
  asio::deadline_timer t2(ioc);
  int count = 0;

  asio::thread th(boost::bind(io_context_run, &ioc));

  t2.expires_from_now(boost::posix_time::seconds(2));
  t2.wait();

  t1.expires_from_now(boost::posix_time::seconds(2));
  t1.async_wait(boost::bind(increment, &count));

  t2.expires_from_now(boost::posix_time::seconds(4));
  t2.wait();

  ioc.stop();
  th.join();

  ASIO_CHECK(count == 1);
}

void deadline_timer_async_result_test()
{
  asio::io_context ioc;
  asio::deadline_timer t1(ioc);

  t1.expires_from_now(boost::posix_time::seconds(1));
  int i = t1.async_wait(archetypes::lazy_handler());
  ASIO_CHECK(i == 42);

  ioc.run();
}

asio::deadline_timer make_timer(asio::io_context& ioc, int* count)
{
  asio::deadline_timer t(ioc);
  t.expires_from_now(boost::posix_time::seconds(1));
  t.async_wait(boost::bind(increment, count));
  return t;
}

void deadline_timer_move_test()
{
  asio::io_context io_context1;
  asio::io_context io_context2;
  int count = 0;

  asio::deadline_timer t1 = make_timer(io_context1, &count);
  asio::deadline_timer t2 = make_timer(io_context2, &count);
  asio::deadline_timer t3 = std::move(t1);

  t2 = std::move(t1);

  io_context2.run();

  ASIO_CHECK(count == 1);

  io_context1.run();

  ASIO_CHECK(count == 2);
}

ASIO_TEST_SUITE
(
  "deadline_timer",
  ASIO_TEST_CASE(deadline_timer_test)
  ASIO_TEST_CASE(deadline_timer_cancel_test)
  ASIO_TEST_CASE(deadline_timer_custom_allocation_test)
  ASIO_TEST_CASE(deadline_timer_thread_test)
  ASIO_TEST_CASE(deadline_timer_async_result_test)
  ASIO_TEST_CASE(deadline_timer_move_test)
)
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
ASIO_TEST_SUITE
(
  "deadline_timer",
  ASIO_TEST_CASE(null_test)
)
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\defer.cpp
//
// defer.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/defer.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "defer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\deferred.cpp
//
// deferred.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/deferred.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "experimental/deferred",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\detached.cpp
//
// detached.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/detached.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "detached",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\dispatch.cpp
//
// dispatch.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/dispatch.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "dispatch",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\error.cpp
//
// error.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/error.hpp"

#include <sstream>
#include "unit_test.hpp"

void test_error_code(const asio::error_code& code)
{
  asio::error_code error(code);
  ASIO_CHECK(code == error);

  ASIO_CHECK(!code || error);
  ASIO_CHECK(!code || !!error);

  asio::error_code error2(error);
  ASIO_CHECK(error == error2);
  ASIO_CHECK(!(error != error2));

  asio::error_code error3;
  error3 = error;
  ASIO_CHECK(error == error3);
  ASIO_CHECK(!(error != error3));

  std::ostringstream os;
  os << error;
  ASIO_CHECK(!os.str().empty());
}

void error_test()
{
  test_error_code(asio::error::access_denied);
  test_error_code(asio::error::address_family_not_supported);
  test_error_code(asio::error::address_in_use);
  test_error_code(asio::error::already_connected);
  test_error_code(asio::error::already_started);
  test_error_code(asio::error::connection_aborted);
  test_error_code(asio::error::connection_refused);
  test_error_code(asio::error::connection_reset);
  test_error_code(asio::error::bad_descriptor);
  test_error_code(asio::error::eof);
  test_error_code(asio::error::fault);
  test_error_code(asio::error::host_not_found);
  test_error_code(asio::error::host_not_found_try_again);
  test_error_code(asio::error::host_unreachable);
  test_error_code(asio::error::in_progress);
  test_error_code(asio::error::interrupted);
  test_error_code(asio::error::invalid_argument);
  test_error_code(asio::error::message_size);
  test_error_code(asio::error::network_down);
  test_error_code(asio::error::network_reset);
  test_error_code(asio::error::network_unreachable);
  test_error_code(asio::error::no_descriptors);
  test_error_code(asio::error::no_buffer_space);
  test_error_code(asio::error::no_data);
  test_error_code(asio::error::no_memory);
  test_error_code(asio::error::no_permission);
  test_error_code(asio::error::no_protocol_option);
  test_error_code(asio::error::no_recovery);
  test_error_code(asio::error::not_connected);
  test_error_code(asio::error::not_socket);
  test_error_code(asio::error::operation_aborted);
  test_error_code(asio::error::operation_not_supported);
  test_error_code(asio::error::service_not_found);
  test_error_code(asio::error::shut_down);
  test_error_code(asio::error::timed_out);
  test_error_code(asio::error::try_again);
  test_error_code(asio::error::would_block);
}

ASIO_TEST_SUITE
(
  "error",
  ASIO_TEST_CASE(error_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\execution_context.cpp
//
// execution_context.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/execution_context.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "execution_context",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\executor_work_guard.cpp
//
// executor_work_guard.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/executor_work_guard.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "executor_work_guard",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\executor.cpp
//
// executor.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/executor.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "executor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\file_base.cpp
//
// file_base.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/post.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "file_base",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\high_resolution_timer.cpp
//
// high_resolution_timer.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/high_resolution_timer.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "high_resolution_timer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\io_context_strand.cpp
//
// io_context_strand.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/io_context_strand.hpp"

#include <functional>
#include <sstream>
#include "asio/io_context.hpp"
#include "asio/dispatch.hpp"
#include "asio/post.hpp"
#include "asio/thread.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;

namespace bindns = std;

#if defined(ASIO_HAS_BOOST_DATE_TIME)
typedef deadline_timer timer;
namespace chronons = boost::posix_time;
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
typedef steady_timer timer;
namespace chronons = asio::chrono;
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

void increment(int* count)
{
  ++(*count);
}

void increment_without_lock(io_context::strand* s, int* count)
{
  ASIO_CHECK(!s->running_in_this_thread());

  int original_count = *count;

  dispatch(*s, bindns::bind(increment, count));

  // No other functions are currently executing through the locking dispatcher,
  // so the previous call to dispatch should have successfully nested.
  ASIO_CHECK(*count == original_count + 1);
}

void increment_with_lock(io_context::strand* s, int* count)
{
  ASIO_CHECK(s->running_in_this_thread());

  int original_count = *count;

  dispatch(*s, bindns::bind(increment, count));

  // The current function already holds the strand's lock, so the
  // previous call to dispatch should have successfully nested.
  ASIO_CHECK(*count == original_count + 1);
}

void sleep_increment(io_context* ioc, int* count)
{
  timer t(*ioc, chronons::seconds(2));
  t.wait();

  ++(*count);
}

void increment_by_a(int* count, int a)
{
  (*count) += a;
}

void increment_by_a_b(int* count, int a, int b)
{
  (*count) += a + b;
}

void increment_by_a_b_c(int* count, int a, int b, int c)
{
  (*count) += a + b + c;
}

void increment_by_a_b_c_d(int* count, int a, int b, int c, int d)
{
  (*count) += a + b + c + d;
}

void start_sleep_increments(io_context* ioc, io_context::strand* s, int* count)
{
  // Give all threads a chance to start.
  timer t(*ioc, chronons::seconds(2));
  t.wait();

  // Start three increments.
  post(*s, bindns::bind(sleep_increment, ioc, count));
  post(*s, bindns::bind(sleep_increment, ioc, count));
  post(*s, bindns::bind(sleep_increment, ioc, count));
}

void throw_exception()
{
  throw 1;
}

void io_context_run(io_context* ioc)
{
  ioc->run();
}

void strand_test()
{
  io_context ioc;
  io_context::strand s(ioc);
  int count = 0;

  post(ioc, bindns::bind(increment_without_lock, &s, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  post(s, bindns::bind(increment_with_lock, &s, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  post(ioc, bindns::bind(start_sleep_increments, &ioc, &s, &count));
  thread thread1(bindns::bind(io_context_run, &ioc));
  thread thread2(bindns::bind(io_context_run, &ioc));

  // Check all events run one after another even though there are two threads.
  timer timer1(ioc, chronons::seconds(3));
  timer1.wait();
  ASIO_CHECK(count == 0);
#if defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expires_at() + chronons::seconds(2));
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expiry() + chronons::seconds(2));
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.wait();
  ASIO_CHECK(count == 1);
#if defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expires_at() + chronons::seconds(2));
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expiry() + chronons::seconds(2));
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.wait();
  ASIO_CHECK(count == 2);

  thread1.join();
  thread2.join();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 3);

  count = 0;
  int exception_count = 0;
  ioc.restart();
  post(s, throw_exception);
  post(s, bindns::bind(increment, &count));
  post(s, bindns::bind(increment, &count));
  post(s, throw_exception);
  post(s, bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);
  ASIO_CHECK(exception_count == 0);

  for (;;)
  {
    try
    {
      ioc.run();
      break;
    }
    catch (int)
    {
      ++exception_count;
    }
  }

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 3);
  ASIO_CHECK(exception_count == 2);

  count = 0;
  ioc.restart();

  // Check for clean shutdown when handlers posted through an orphaned strand
  // are abandoned.
  {
    io_context::strand s2(ioc);
    post(s2, bindns::bind(increment, &count));
    post(s2, bindns::bind(increment, &count));
    post(s2, bindns::bind(increment, &count));
  }

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);
}

void strand_wrap_test()
{
#if !defined(ASIO_NO_DEPRECATED)
  io_context ioc;
  io_context::strand s(ioc);
  int count = 0;

  s.wrap(bindns::bind(increment, &count))();

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  s.wrap(increment)(&count);

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  s.wrap(increment_by_a)(&count, 1);

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  s.wrap(increment_by_a_b)(&count, 1, 2);

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 3);

  count = 0;
  s.wrap(increment_by_a_b_c)(&count, 1, 2, 3);

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 6);

  count = 0;
  s.wrap(increment_by_a_b_c_d)(&count, 1, 2, 3, 4);

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 10);
#endif // !defined(ASIO_NO_DEPRECATED)
}

ASIO_TEST_SUITE
(
  "strand",
  ASIO_TEST_CASE(strand_test)
  ASIO_TEST_CASE(strand_wrap_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\io_context.cpp
//
// io_context.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/io_context.hpp"

#include <functional>
#include <sstream>
#include "asio/bind_executor.hpp"
#include "asio/dispatch.hpp"
#include "asio/post.hpp"
#include "asio/thread.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;
namespace bindns = std;

#if defined(ASIO_HAS_BOOST_DATE_TIME)
typedef deadline_timer timer;
namespace chronons = boost::posix_time;
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
typedef steady_timer timer;
namespace chronons = asio::chrono;
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

void increment(int* count)
{
  ++(*count);
}

void decrement_to_zero(io_context* ioc, int* count)
{
  if (*count > 0)
  {
    --(*count);

    int before_value = *count;
    asio::post(*ioc, bindns::bind(decrement_to_zero, ioc, count));

    // Handler execution cannot nest, so count value should remain unchanged.
    ASIO_CHECK(*count == before_value);
  }
}

void nested_decrement_to_zero(io_context* ioc, int* count)
{
  if (*count > 0)
  {
    --(*count);

    asio::dispatch(*ioc,
        bindns::bind(nested_decrement_to_zero, ioc, count));

    // Handler execution is nested, so count value should now be zero.
    ASIO_CHECK(*count == 0);
  }
}

void sleep_increment(io_context* ioc, int* count)
{
  timer t(*ioc, chronons::seconds(2));
  t.wait();

  if (++(*count) < 3)
    asio::post(*ioc, bindns::bind(sleep_increment, ioc, count));
}

void start_sleep_increments(io_context* ioc, int* count)
{
  // Give all threads a chance to start.
  timer t(*ioc, chronons::seconds(2));
  t.wait();

  // Start the first of three increments.
  asio::post(*ioc, bindns::bind(sleep_increment, ioc, count));
}

void throw_exception()
{
  throw 1;
}

void io_context_run(io_context* ioc)
{
  ioc->run();
}

void io_context_test()
{
  io_context ioc;
  int count = 0;

  asio::post(ioc, bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::post(ioc, bindns::bind(increment, &count));
  asio::post(ioc, bindns::bind(increment, &count));
  asio::post(ioc, bindns::bind(increment, &count));
  asio::post(ioc, bindns::bind(increment, &count));
  asio::post(ioc, bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 5);

  count = 0;
  ioc.restart();
  executor_work_guard<io_context::executor_type> w = make_work_guard(ioc);
  asio::post(ioc, bindns::bind(&io_context::stop, &ioc));
  ASIO_CHECK(!ioc.stopped());
  ioc.run();

  // The only operation executed should have been to stop run().
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.restart();
  asio::post(ioc, bindns::bind(increment, &count));
  w.reset();

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 10;
  ioc.restart();
  asio::post(ioc, bindns::bind(decrement_to_zero, &ioc, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 10);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 0);

  count = 10;
  ioc.restart();
  asio::post(ioc, bindns::bind(nested_decrement_to_zero, &ioc, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 10);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 0);

  count = 10;
  ioc.restart();
  asio::dispatch(ioc,
      bindns::bind(nested_decrement_to_zero, &ioc, &count));

  // No handlers can be called until run() is called, even though nested
  // delivery was specifically allowed in the previous call.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 10);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 0);

  count = 0;
  int count2 = 0;
  ioc.restart();
  ASIO_CHECK(!ioc.stopped());
  asio::post(ioc, bindns::bind(start_sleep_increments, &ioc, &count));
  asio::post(ioc, bindns::bind(start_sleep_increments, &ioc, &count2));
  thread thread1(bindns::bind(io_context_run, &ioc));
  thread thread2(bindns::bind(io_context_run, &ioc));
  thread1.join();
  thread2.join();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 3);
  ASIO_CHECK(count2 == 3);

  count = 10;
  io_context ioc2;
  asio::dispatch(ioc, asio::bind_executor(ioc2,
        bindns::bind(decrement_to_zero, &ioc2, &count)));
  ioc.restart();
  ASIO_CHECK(!ioc.stopped());
  ioc.run();

  // No decrement_to_zero handlers can be called until run() is called on the
  // second io_context object.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 10);

  ioc2.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(count == 0);

  count = 0;
  int exception_count = 0;
  ioc.restart();
  asio::post(ioc, &throw_exception);
  asio::post(ioc, bindns::bind(increment, &count));
  asio::post(ioc, bindns::bind(increment, &count));
  asio::post(ioc, &throw_exception);
  asio::post(ioc, bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);
  ASIO_CHECK(exception_count == 0);

  for (;;)
  {
    try
    {
      ioc.run();
      break;
    }
    catch (int)
    {
      ++exception_count;
    }
  }

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 3);
  ASIO_CHECK(exception_count == 2);
}

class test_service : public asio::io_context::service
{
public:
  static asio::io_context::id id;
  test_service(asio::io_context& s)
    : asio::io_context::service(s) {}
private:
  virtual void shutdown_service() {}
};

asio::io_context::id test_service::id;

void io_context_service_test()
{
  asio::io_context ioc1;
  asio::io_context ioc2;
  asio::io_context ioc3;

  // Implicit service registration.

  asio::use_service<test_service>(ioc1);

  ASIO_CHECK(asio::has_service<test_service>(ioc1));

  test_service* svc1 = new test_service(ioc1);
  try
  {
    asio::add_service(ioc1, svc1);
    ASIO_ERROR("add_service did not throw");
  }
  catch (asio::service_already_exists&)
  {
  }
  delete svc1;

  // Explicit service registration.

  test_service* svc2 = new test_service(ioc2);
  asio::add_service(ioc2, svc2);

  ASIO_CHECK(asio::has_service<test_service>(ioc2));
  ASIO_CHECK(&asio::use_service<test_service>(ioc2) == svc2);

  test_service* svc3 = new test_service(ioc2);
  try
  {
    asio::add_service(ioc2, svc3);
    ASIO_ERROR("add_service did not throw");
  }
  catch (asio::service_already_exists&)
  {
  }
  delete svc3;

  // Explicit registration with invalid owner.

  test_service* svc4 = new test_service(ioc2);
  try
  {
    asio::add_service(ioc3, svc4);
    ASIO_ERROR("add_service did not throw");
  }
  catch (asio::invalid_service_owner&)
  {
  }
  delete svc4;

  ASIO_CHECK(!asio::has_service<test_service>(ioc3));
}

void io_context_executor_query_test()
{
  io_context ioc;

  ASIO_CHECK(
      &asio::query(ioc.get_executor(),
        asio::execution::context)
      == &ioc);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::blocking)
      == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::blocking.possibly)
      == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::outstanding_work)
      == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::outstanding_work.untracked)
      == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::relationship)
      == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::relationship.fork)
      == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::mapping)
      == asio::execution::mapping.thread);

  ASIO_CHECK(
      asio::query(ioc.get_executor(),
        asio::execution::allocator)
      == std::allocator<void>());
}

void io_context_executor_execute_test()
{
  io_context ioc;
  int count = 0;

  ioc.get_executor().execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(ioc.get_executor(),
      asio::execution::blocking.possibly
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(ioc.get_executor(),
      asio::execution::blocking.never
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  ASIO_CHECK(!ioc.stopped());

  asio::require(ioc.get_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.tracked
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(ioc.get_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(ioc.get_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.fork
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(ioc.get_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.continuation
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::prefer(
      asio::require(ioc.get_executor(),
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator(std::allocator<void>())
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::prefer(
      asio::require(ioc.get_executor(),
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "io_context",
  ASIO_TEST_CASE(io_context_test)
  ASIO_TEST_CASE(io_context_service_test)
  ASIO_TEST_CASE(io_context_executor_query_test)
  ASIO_TEST_CASE(io_context_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\is_read_buffered.cpp
//
// is_read_buffered.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/is_read_buffered.hpp"

#include "asio/buffered_read_stream.hpp"
#include "asio/buffered_write_stream.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "unit_test.hpp"

using namespace std; // For memcmp, memcpy and memset.

class test_stream
{
public:
  typedef asio::io_context io_context_type;

  typedef test_stream lowest_layer_type;

  typedef io_context_type::executor_type executor_type;

  test_stream(asio::io_context& io_context)
    : io_context_(io_context)
  {
  }

  io_context_type& io_context()
  {
    return io_context_;
  }

  lowest_layer_type& lowest_layer()
  {
    return *this;
  }

  template <typename Const_Buffers>
  size_t write(const Const_Buffers&)
  {
    return 0;
  }

  template <typename Const_Buffers>
  size_t write(const Const_Buffers&, asio::error_code& ec)
  {
    ec = asio::error_code();
    return 0;
  }

  template <typename Const_Buffers, typename Handler>
  void async_write(const Const_Buffers&, Handler handler)
  {
    asio::error_code error;
    asio::post(io_context_,
        asio::detail::bind_handler(handler, error, 0));
  }

  template <typename Mutable_Buffers>
  size_t read(const Mutable_Buffers&)
  {
    return 0;
  }

  template <typename Mutable_Buffers>
  size_t read(const Mutable_Buffers&, asio::error_code& ec)
  {
    ec = asio::error_code();
    return 0;
  }

  template <typename Mutable_Buffers, typename Handler>
  void async_read(const Mutable_Buffers&, Handler handler)
  {
    asio::error_code error;
    asio::post(io_context_,
        asio::detail::bind_handler(handler, error, 0));
  }

private:
  io_context_type& io_context_;
};

void is_read_buffered_test()
{
  ASIO_CHECK(!asio::is_read_buffered<
      asio::ip::tcp::socket>::value);

  ASIO_CHECK(!!asio::is_read_buffered<
      asio::buffered_read_stream<
        asio::ip::tcp::socket> >::value);

  ASIO_CHECK(!asio::is_read_buffered<
      asio::buffered_write_stream<
        asio::ip::tcp::socket> >::value);

  ASIO_CHECK(!!asio::is_read_buffered<
      asio::buffered_stream<asio::ip::tcp::socket> >::value);

  ASIO_CHECK(!asio::is_read_buffered<test_stream>::value);

  ASIO_CHECK(!!asio::is_read_buffered<
      asio::buffered_read_stream<test_stream> >::value);

  ASIO_CHECK(!asio::is_read_buffered<
      asio::buffered_write_stream<test_stream> >::value);

  ASIO_CHECK(!!asio::is_read_buffered<
      asio::buffered_stream<test_stream> >::value);
}

ASIO_TEST_SUITE
(
  "is_read_buffered",
  ASIO_TEST_CASE(is_read_buffered_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\is_write_buffered.cpp
//
// is_write_buffered.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/is_write_buffered.hpp"

#include "asio/buffered_read_stream.hpp"
#include "asio/buffered_write_stream.hpp"
#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "unit_test.hpp"

using namespace std; // For memcmp, memcpy and memset.

class test_stream
{
public:
  typedef asio::io_context io_context_type;

  typedef test_stream lowest_layer_type;

  typedef io_context_type::executor_type executor_type;

  test_stream(asio::io_context& io_context)
    : io_context_(io_context)
  {
  }

  io_context_type& io_context()
  {
    return io_context_;
  }

  lowest_layer_type& lowest_layer()
  {
    return *this;
  }

  template <typename Const_Buffers>
  size_t write(const Const_Buffers&)
  {
    return 0;
  }

  template <typename Const_Buffers>
  size_t write(const Const_Buffers&, asio::error_code& ec)
  {
    ec = asio::error_code();
    return 0;
  }

  template <typename Const_Buffers, typename Handler>
  void async_write(const Const_Buffers&, Handler handler)
  {
    asio::error_code error;
    asio::post(io_context_,
        asio::detail::bind_handler(handler, error, 0));
  }

  template <typename Mutable_Buffers>
  size_t read(const Mutable_Buffers&)
  {
    return 0;
  }

  template <typename Mutable_Buffers>
  size_t read(const Mutable_Buffers&, asio::error_code& ec)
  {
    ec = asio::error_code();
    return 0;
  }

  template <typename Mutable_Buffers, typename Handler>
  void async_read(const Mutable_Buffers&, Handler handler)
  {
    asio::error_code error;
    asio::post(io_context_,
        asio::detail::bind_handler(handler, error, 0));
  }

private:
  io_context_type& io_context_;
};

void is_write_buffered_test()
{
  ASIO_CHECK(!asio::is_write_buffered<
      asio::ip::tcp::socket>::value);

  ASIO_CHECK(!asio::is_write_buffered<
      asio::buffered_read_stream<
        asio::ip::tcp::socket> >::value);

  ASIO_CHECK(!!asio::is_write_buffered<
      asio::buffered_write_stream<
        asio::ip::tcp::socket> >::value);

  ASIO_CHECK(!!asio::is_write_buffered<
      asio::buffered_stream<asio::ip::tcp::socket> >::value);

  ASIO_CHECK(!asio::is_write_buffered<test_stream>::value);

  ASIO_CHECK(!asio::is_write_buffered<
      asio::buffered_read_stream<test_stream> >::value);

  ASIO_CHECK(!!asio::is_write_buffered<
      asio::buffered_write_stream<test_stream> >::value);

  ASIO_CHECK(!!asio::is_write_buffered<
      asio::buffered_stream<test_stream> >::value);
}

ASIO_TEST_SUITE
(
  "is_write_buffered",
  ASIO_TEST_CASE(is_write_buffered_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\packaged_task.cpp
//
// packaged_task.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/packaged_task.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "packaged_task",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\placeholders.cpp
//
// placeholders.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/placeholders.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "placeholders",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\post.cpp
//
// post.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/post.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "post",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\prepend.cpp
//
// prepend.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/prepend.hpp"

#include "asio/bind_executor.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/system_timer.hpp"
#include "unit_test.hpp"

void prepend_test()
{
  asio::io_context io1;
  asio::io_context io2;
  asio::system_timer timer1(io1);
  int count = 0;

  timer1.expires_after(asio::chrono::seconds(0));
  timer1.async_wait(
      asio::prepend(
        asio::bind_executor(io2.get_executor(),
          [&count](int a, int b, asio::error_code)
          {
            ++count;
            ASIO_CHECK(a == 123);
            ASIO_CHECK(b == 321);
          }), 123, 321));

  ASIO_CHECK(count == 0);

  io1.run();

  ASIO_CHECK(count == 0);

  io2.run();

  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "prepend",
  ASIO_TEST_CASE(prepend_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\random_access_file.cpp
//
// random_access_file.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/random_access_file.hpp"

#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

// random_access_file_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// random_access_file compile and link correctly. Runtime failures are ignored.

namespace random_access_file_compile {

struct write_some_at_handler
{
  write_some_at_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  write_some_at_handler(write_some_at_handler&&) {}
private:
  write_some_at_handler(const write_some_at_handler&);
};

struct read_some_at_handler
{
  read_some_at_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  read_some_at_handler(read_some_at_handler&&) {}
private:
  read_some_at_handler(const read_some_at_handler&);
};

void test()
{
#if defined(ASIO_HAS_FILE)
  using namespace asio;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    archetypes::lazy_handler lazy;
    asio::error_code ec;
    const std::string path;

    // basic_random_access_file constructors.

    random_access_file file1(ioc);
    random_access_file file2(ioc, "", random_access_file::read_only);
    random_access_file file3(ioc, path, random_access_file::read_only);
    random_access_file::native_handle_type native_file1 = file1.native_handle();
    random_access_file file4(ioc, native_file1);

    random_access_file file5(ioc_ex);
    random_access_file file6(ioc_ex, "", random_access_file::read_only);
    random_access_file file7(ioc_ex, path, random_access_file::read_only);
    random_access_file::native_handle_type native_file2 = file1.native_handle();
    random_access_file file8(ioc_ex, native_file2);

    random_access_file file9(std::move(file8));

    basic_random_access_file<io_context::executor_type> file10(ioc);
    random_access_file file11(std::move(file10));

    // basic_random_access_file operators.

    file1 = random_access_file(ioc);
    file1 = std::move(file2);
    file1 = std::move(file10);

    // basic_io_object functions.

    random_access_file::executor_type ex = file1.get_executor();
    (void)ex;

    // basic_random_access_file functions.

    file1.open("", random_access_file::read_only);
    file1.open("", random_access_file::read_only, ec);

    file1.open(path, random_access_file::read_only);
    file1.open(path, random_access_file::read_only, ec);

    random_access_file::native_handle_type native_file3 = file1.native_handle();
    file1.assign(native_file3);
    random_access_file::native_handle_type native_file4 = file1.native_handle();
    file1.assign(native_file4, ec);

    bool is_open = file1.is_open();
    (void)is_open;

    file1.close();
    file1.close(ec);

    random_access_file::native_handle_type native_file5 = file1.native_handle();
    (void)native_file5;

    random_access_file::native_handle_type native_file6 = file1.release();
    (void)native_file6;
    random_access_file::native_handle_type native_file7 = file1.release(ec);
    (void)native_file7;

    file1.cancel();
    file1.cancel(ec);

    asio::uint64_t s1 = file1.size();
    (void)s1;
    asio::uint64_t s2 = file1.size(ec);
    (void)s2;

    file1.resize(asio::uint64_t(0));
    file1.resize(asio::uint64_t(0), ec);

    file1.sync_all();
    file1.sync_all(ec);

    file1.sync_data();
    file1.sync_data(ec);

    file1.write_some_at(0, buffer(mutable_char_buffer));
    file1.write_some_at(0, buffer(const_char_buffer));
    file1.write_some_at(0, buffer(mutable_char_buffer), ec);
    file1.write_some_at(0, buffer(const_char_buffer), ec);

    file1.async_write_some_at(0, buffer(mutable_char_buffer),
        write_some_at_handler());
    file1.async_write_some_at(0, buffer(const_char_buffer),
        write_some_at_handler());
    int i1 = file1.async_write_some_at(0, buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = file1.async_write_some_at(0, buffer(const_char_buffer), lazy);
    (void)i2;

    file1.read_some_at(0, buffer(mutable_char_buffer));
    file1.read_some_at(0, buffer(mutable_char_buffer), ec);

    file1.async_read_some_at(0, buffer(mutable_char_buffer),
        read_some_at_handler());
    int i3 = file1.async_read_some_at(0, buffer(mutable_char_buffer), lazy);
    (void)i3;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_FILE)
}

} // namespace random_access_file_compile

ASIO_TEST_SUITE
(
  "random_access_file",
  ASIO_COMPILE_TEST_CASE(random_access_file_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\read_at.cpp
//
// read_at.cpp
// ~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/read_at.hpp"

#include <array>
#include <cstring>
#include <functional>
#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/streambuf.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
#include <boost/array.hpp>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

using namespace std; // For memcmp, memcpy and memset.

class test_random_access_device
{
public:
  typedef asio::io_context::executor_type executor_type;

  test_random_access_device(asio::io_context& io_context)
    : io_context_(io_context),
      length_(0),
      next_read_length_(0)
  {
  }

  executor_type get_executor() noexcept
  {
    return io_context_.get_executor();
  }

  void reset(const void* data, size_t length)
  {
    ASIO_CHECK(length <= max_length);

    length_ = 0;
    while (length_ + length < max_length)
    {
      memcpy(data_ + length_, data, length);
      length_ += length;
    }

    next_read_length_ = length;
  }

  void next_read_length(size_t length)
  {
    next_read_length_ = length;
  }

  template <typename Iterator>
  bool check_buffers(asio::uint64_t offset,
      Iterator begin, Iterator end, size_t length)
  {
    if (offset + length > max_length)
      return false;

    Iterator iter = begin;
    size_t checked_length = 0;
    for (; iter != end && checked_length < length; ++iter)
    {
      size_t buffer_length = asio::buffer_size(*iter);
      if (buffer_length > length - checked_length)
        buffer_length = length - checked_length;
      if (memcmp(data_ + offset + checked_length,
            iter->data(), buffer_length) != 0)
        return false;
      checked_length += buffer_length;
    }

    return true;
  }

  template <typename Const_Buffers>
  bool check_buffers(asio::uint64_t offset,
      const Const_Buffers& buffers, size_t length)
  {
    return check_buffers(offset, asio::buffer_sequence_begin(buffers),
        asio::buffer_sequence_end(buffers), length);
  }

  template <typename Mutable_Buffers>
  size_t read_some_at(asio::uint64_t offset,
      const Mutable_Buffers& buffers)
  {
    return asio::buffer_copy(buffers,
        asio::buffer(data_, length_) + offset,
        next_read_length_);
  }

  template <typename Mutable_Buffers>
  size_t read_some_at(asio::uint64_t offset,
      const Mutable_Buffers& buffers, asio::error_code& ec)
  {
    ec = asio::error_code();
    return read_some_at(offset, buffers);
  }

  template <typename Mutable_Buffers, typename Handler>
  void async_read_some_at(asio::uint64_t offset,
      const Mutable_Buffers& buffers, Handler&& handler)
  {
    size_t bytes_transferred = read_some_at(offset, buffers);
    asio::post(get_executor(),
        asio::detail::bind_handler(
          static_cast<Handler&&>(handler),
          asio::error_code(), bytes_transferred));
  }

private:
  asio::io_context& io_context_;
  enum { max_length = 8192 };
  char data_[max_length];
  size_t length_;
  size_t next_read_length_;
};

static const char read_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void test_3_arg_mutable_buffer_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_3_arg_vector_buffers_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf) + 32);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_3_arg_streambuf_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  size_t bytes_transferred = asio::read_at(s, 0, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
}

void test_4_arg_nothrow_mutable_buffer_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_nothrow_vector_buffers_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf) + 32);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_nothrow_streambuf_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  asio::error_code error;
  size_t bytes_transferred = asio::read_at(s, 0, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);
}

bool old_style_transfer_all(const asio::error_code& ec,
    size_t /*bytes_transferred*/)
{
  return !!ec;
}

struct short_transfer
{
  short_transfer() {}
  short_transfer(short_transfer&&) {}
  size_t operator()(const asio::error_code& ec,
      size_t /*bytes_transferred*/)
  {
    return !!ec ? 0 : 3;
  }
};

void test_4_arg_mutable_buffer_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_4_arg_vector_buffers_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf) + 32);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_4_arg_streambuf_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  size_t bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 50));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
}

void test_5_arg_mutable_buffer_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_5_arg_vector_buffers_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf) + 32);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_5_arg_streambuf_read_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  asio::error_code error;
  size_t bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 0, sb,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read_at(s, 1234, sb,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 0, sb,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read_at(s, 1234, sb,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);
}

void async_read_handler(const asio::error_code& e,
    size_t bytes_transferred, size_t expected_bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!e);
  ASIO_CHECK(bytes_transferred == expected_bytes_transferred);
}

void test_4_arg_mutable_buffer_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_4_arg_boost_array_buffers_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  boost::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_4_arg_std_array_buffers_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_4_arg_vector_buffers_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf) + 32);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_4_arg_streambuf_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bool called = false;
  asio::async_read_at(s, 0, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  int i = asio::async_read_at(s, 1234, sb,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
}

void test_5_arg_mutable_buffer_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_5_arg_boost_array_buffers_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  boost::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_5_arg_std_array_buffers_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_5_arg_vector_buffers_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf) + 32);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read_at(s, 1234, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(read_data)));
}

void test_5_arg_streambuf_async_read_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bool called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 50));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 50));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(0, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(1234, sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 0, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(0, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read_at(s, 1234, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  int i = asio::async_read_at(s, 1234, sb,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(1234, sb.data(), sizeof(read_data)));
}

ASIO_TEST_SUITE
(
  "read_at",
  ASIO_TEST_CASE(test_3_arg_mutable_buffer_read_at)
  ASIO_TEST_CASE(test_3_arg_vector_buffers_read_at)
  ASIO_TEST_CASE(test_3_arg_streambuf_read_at)
  ASIO_TEST_CASE(test_4_arg_nothrow_mutable_buffer_read_at)
  ASIO_TEST_CASE(test_4_arg_nothrow_vector_buffers_read_at)
  ASIO_TEST_CASE(test_4_arg_nothrow_streambuf_read_at)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_read_at)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_read_at)
  ASIO_TEST_CASE(test_4_arg_streambuf_read_at)
  ASIO_TEST_CASE(test_5_arg_mutable_buffer_read_at)
  ASIO_TEST_CASE(test_5_arg_vector_buffers_read_at)
  ASIO_TEST_CASE(test_5_arg_streambuf_read_at)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_async_read_at)
  ASIO_TEST_CASE(test_4_arg_boost_array_buffers_async_read_at)
  ASIO_TEST_CASE(test_4_arg_std_array_buffers_async_read_at)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_async_read_at)
  ASIO_TEST_CASE(test_4_arg_streambuf_async_read_at)
  ASIO_TEST_CASE(test_5_arg_mutable_buffer_async_read_at)
  ASIO_TEST_CASE(test_5_arg_boost_array_buffers_async_read_at)
  ASIO_TEST_CASE(test_5_arg_std_array_buffers_async_read_at)
  ASIO_TEST_CASE(test_5_arg_vector_buffers_async_read_at)
  ASIO_TEST_CASE(test_5_arg_streambuf_async_read_at)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\read_until.cpp
//
// read_until.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/read_until.hpp"

#include <cstring>
#include <functional>
#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/streambuf.hpp"
#include "unit_test.hpp"

class test_stream
{
public:
  typedef asio::io_context::executor_type executor_type;

  test_stream(asio::io_context& io_context)
    : io_context_(io_context),
      length_(0),
      position_(0),
      next_read_length_(0)
  {
  }

  executor_type get_executor() noexcept
  {
    return io_context_.get_executor();
  }

  void reset(const void* data, size_t length)
  {
    using namespace std; // For memcpy.

    ASIO_CHECK(length <= max_length);

    memcpy(data_, data, length);
    length_ = length;
    position_ = 0;
    next_read_length_ = length;
  }

  void next_read_length(size_t length)
  {
    next_read_length_ = length;
  }

  template <typename Mutable_Buffers>
  size_t read_some(const Mutable_Buffers& buffers)
  {
    size_t n = asio::buffer_copy(buffers,
        asio::buffer(data_, length_) + position_,
        next_read_length_);
    position_ += n;
    return n;
  }

  template <typename Mutable_Buffers>
  size_t read_some(const Mutable_Buffers& buffers,
      asio::error_code& ec)
  {
    ec = asio::error_code();
    return read_some(buffers);
  }

  template <typename Mutable_Buffers, typename Handler>
  void async_read_some(const Mutable_Buffers& buffers, Handler handler)
  {
    size_t bytes_transferred = read_some(buffers);
    asio::post(get_executor(),
        asio::detail::bind_handler(
          static_cast<Handler&&>(handler),
          asio::error_code(), bytes_transferred));
  }

private:
  asio::io_context& io_context_;
  enum { max_length = 8192 };
  char data_[max_length];
  size_t length_;
  size_t position_;
  size_t next_read_length_;
};

static const char read_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void test_dynamic_string_read_until_char()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data1, data2;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb1 = asio::dynamic_buffer(data1);
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb2 = asio::dynamic_buffer(data2, 25);
  asio::error_code ec;

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  std::size_t length = asio::read_until(s, sb1, 'Z');
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z');
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z');
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Z', ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Z', ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Z', ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Y', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Y', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Y', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);
}

void test_streambuf_read_until_char()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb1;
  asio::streambuf sb2(25);
  asio::error_code ec;

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  std::size_t length = asio::read_until(s, sb1, 'Z');
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z');
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z');
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, 'Z', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Z', ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Z', ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Z', ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Y', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Y', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, 'Y', ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_dynamic_string_read_until_string()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data1, data2;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb1 = asio::dynamic_buffer(data1);
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb2 = asio::dynamic_buffer(data2, 25);
  asio::error_code ec;

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  std::size_t length = asio::read_until(s, sb1, "XYZ");
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ");
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ");
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "XYZ", ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "XYZ", ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "XYZ", ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "WXY", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "WXY", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "WXY", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);
}

void test_streambuf_read_until_string()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb1;
  asio::streambuf sb2(25);
  asio::error_code ec;

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  std::size_t length = asio::read_until(s, sb1, "XYZ");
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ");
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ");
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, "XYZ", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "XYZ", ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "XYZ", ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "XYZ", ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "WXY", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "WXY", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, "WXY", ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

class match_char
{
public:
  explicit match_char(char c) : c_(c) {}

  template <typename Iterator>
  std::pair<Iterator, bool> operator()(
      Iterator begin, Iterator end) const
  {
    Iterator i = begin;
    while (i != end)
      if (c_ == *i++)
        return std::make_pair(i, true);
    return std::make_pair(i, false);
  }

private:
  char c_;
};

namespace asio {
  template <> struct is_match_condition<match_char>
  {
    enum { value = true };
  };
} // namespace asio

void test_dynamic_string_read_until_match_condition()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data1, data2;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb1 = asio::dynamic_buffer(data1);
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb2 = asio::dynamic_buffer(data2, 25);
  asio::error_code ec;

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  std::size_t length = asio::read_until(s, sb1, match_char('Z'));
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'));
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'));
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Z'), ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Z'), ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Z'), ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Y'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Y'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Y'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);
}

void test_streambuf_read_until_match_condition()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb1;
  asio::streambuf sb2(25);
  asio::error_code ec;

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  std::size_t length = asio::read_until(s, sb1, match_char('Z'));
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'));
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'));
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb1.consume(sb1.size());
  length = asio::read_until(s, sb1, match_char('Z'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Z'), ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Z'), ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Z'), ec);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Y'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Y'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb2.consume(sb2.size());
  length = asio::read_until(s, sb2, match_char('Y'), ec);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void async_read_handler(
    const asio::error_code& err, asio::error_code* err_out,
    std::size_t bytes_transferred, std::size_t* bytes_out, bool* called)
{
  *err_out = err;
  *bytes_out = bytes_transferred;
  *called = true;
}

void test_dynamic_string_async_read_until_char()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data1, data2;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb1 = asio::dynamic_buffer(data1);
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb2 = asio::dynamic_buffer(data2, 25);
  asio::error_code ec;
  std::size_t length;
  bool called;

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Y',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Y',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Y',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  int i = asio::async_read_until(s, sb2, 'Y',
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
}

void test_streambuf_async_read_until_char()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb1;
  asio::streambuf sb2(25);
  asio::error_code ec;
  std::size_t length;
  bool called;

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Z',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Y',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Y',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, 'Y',
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  int i = asio::async_read_until(s, sb2, 'Y',
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_dynamic_string_async_read_until_string()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data1, data2;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb1 = asio::dynamic_buffer(data1);
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb2 = asio::dynamic_buffer(data2, 25);
  asio::error_code ec;
  std::size_t length;
  bool called;

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "WXY",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "WXY",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "WXY",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  int i = asio::async_read_until(s, sb2, "WXY",
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
}

void test_streambuf_async_read_until_string()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb1;
  asio::streambuf sb2(25);
  asio::error_code ec;
  std::size_t length;
  bool called;

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "XYZ",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "WXY",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "WXY",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, "WXY",
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  int i = asio::async_read_until(s, sb2, "WXY",
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_dynamic_string_async_read_until_match_condition()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data1, data2;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb1 = asio::dynamic_buffer(data1);
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb2 = asio::dynamic_buffer(data2, 25);
  asio::error_code ec;
  std::size_t length;
  bool called;

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Y'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Y'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Y'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  int i = asio::async_read_until(s, sb2, match_char('Y'),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
}

void test_streambuf_async_read_until_match_condition()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb1;
  asio::streambuf sb2(25);
  asio::error_code ec;
  std::size_t length;
  bool called;

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb1.consume(sb1.size());
  asio::async_read_until(s, sb1, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 26);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Z'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(ec == asio::error::not_found);
  ASIO_CHECK(length == 0);

  s.reset(read_data, sizeof(read_data));
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Y'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Y'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  ec = asio::error_code();
  length = 0;
  called = false;
  sb2.consume(sb2.size());
  asio::async_read_until(s, sb2, match_char('Y'),
      bindns::bind(async_read_handler, _1, &ec,
        _2, &length, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(!ec);
  ASIO_CHECK(length == 25);

  s.reset(read_data, sizeof(read_data));
  sb2.consume(sb2.size());
  int i = asio::async_read_until(s, sb2, match_char('Y'),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

ASIO_TEST_SUITE
(
  "read_until",
  ASIO_TEST_CASE(test_dynamic_string_read_until_char)
  ASIO_TEST_CASE(test_streambuf_read_until_char)
  ASIO_TEST_CASE(test_dynamic_string_read_until_string)
  ASIO_TEST_CASE(test_streambuf_read_until_string)
  ASIO_TEST_CASE(test_dynamic_string_read_until_match_condition)
  ASIO_TEST_CASE(test_streambuf_read_until_match_condition)
  ASIO_TEST_CASE(test_dynamic_string_async_read_until_char)
  ASIO_TEST_CASE(test_streambuf_async_read_until_char)
  ASIO_TEST_CASE(test_dynamic_string_async_read_until_string)
  ASIO_TEST_CASE(test_streambuf_async_read_until_string)
  ASIO_TEST_CASE(test_dynamic_string_async_read_until_match_condition)
  ASIO_TEST_CASE(test_streambuf_async_read_until_match_condition)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\read.cpp
//
// read.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/read.hpp"

#include <array>
#include <cstring>
#include <functional>
#include <vector>
#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/streambuf.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
#include <boost/array.hpp>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

using namespace std; // For memcmp, memcpy and memset.

class test_stream
{
public:
  typedef asio::io_context::executor_type executor_type;

  test_stream(asio::io_context& io_context)
    : io_context_(io_context),
      length_(0),
      position_(0),
      next_read_length_(0)
  {
  }

  executor_type get_executor() noexcept
  {
    return io_context_.get_executor();
  }

  void reset(const void* data, size_t length)
  {
    ASIO_CHECK(length <= max_length);

    memcpy(data_, data, length);
    length_ = length;
    position_ = 0;
    next_read_length_ = length;
  }

  void next_read_length(size_t length)
  {
    next_read_length_ = length;
  }

  template <typename Iterator>
  bool check_buffers(Iterator begin, Iterator end, size_t length)
  {
    if (length != position_)
      return false;

    Iterator iter = begin;
    size_t checked_length = 0;
    for (; iter != end && checked_length < length; ++iter)
    {
      size_t buffer_length = asio::buffer_size(*iter);
      if (buffer_length > length - checked_length)
        buffer_length = length - checked_length;
      if (memcmp(data_ + checked_length, iter->data(), buffer_length) != 0)
        return false;
      checked_length += buffer_length;
    }

    return true;
  }

  template <typename Const_Buffers>
  bool check_buffers(const Const_Buffers& buffers, size_t length)
  {
    return check_buffers(asio::buffer_sequence_begin(buffers),
        asio::buffer_sequence_end(buffers), length);
  }

  template <typename Mutable_Buffers>
  size_t read_some(const Mutable_Buffers& buffers)
  {
    size_t n = asio::buffer_copy(buffers,
        asio::buffer(data_, length_) + position_,
        next_read_length_);
    position_ += n;
    return n;
  }

  template <typename Mutable_Buffers>
  size_t read_some(const Mutable_Buffers& buffers,
      asio::error_code& ec)
  {
    ec = asio::error_code();
    return read_some(buffers);
  }

  template <typename Mutable_Buffers, typename Handler>
  void async_read_some(const Mutable_Buffers& buffers,
      Handler&& handler)
  {
    size_t bytes_transferred = read_some(buffers);
    asio::post(get_executor(),
        asio::detail::bind_handler(
          static_cast<Handler&&>(handler),
          asio::error_code(), bytes_transferred));
  }

private:
  asio::io_context& io_context_;
  enum { max_length = 8192 };
  char data_[max_length];
  size_t length_;
  size_t position_;
  size_t next_read_length_;
};

static const char read_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void test_2_arg_zero_buffers_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::mutable_buffer> buffers;

  size_t bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == 0);
}

void test_2_arg_mutable_buffer_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_2_arg_vector_buffers_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf, 39) + 32);
  buffers.push_back(asio::buffer(read_buf) + 39);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_2_arg_dynamic_string_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  size_t bytes_transferred = asio::read(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
}

void test_2_arg_streambuf_read()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  size_t bytes_transferred = asio::read(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_3_arg_nothrow_zero_buffers_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::mutable_buffer> buffers;

  asio::error_code error;
  size_t bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == 0);
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_mutable_buffer_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_vector_buffers_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf, 39) + 32);
  buffers.push_back(asio::buffer(read_buf) + 39);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_dynamic_string_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_streambuf_read()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

bool old_style_transfer_all(const asio::error_code& ec,
    size_t /*bytes_transferred*/)
{
  return !!ec;
}

struct short_transfer
{
  short_transfer() {}
  short_transfer(short_transfer&&) {}
  size_t operator()(const asio::error_code& ec,
      size_t /*bytes_transferred*/)
  {
    return !!ec ? 0 : 3;
  }
};

void test_3_arg_mutable_buffer_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_3_arg_vector_buffers_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf, 39) + 32);
  buffers.push_back(asio::buffer(read_buf) + 39);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  size_t bytes_transferred = asio::read(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_3_arg_dynamic_string_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  size_t bytes_transferred = asio::read(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 50));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
}

void test_3_arg_streambuf_read()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  size_t bytes_transferred = asio::read(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(sb.data(), 50));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_4_arg_mutable_buffer_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_vector_buffers_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf, 39) + 32);
  buffers.push_back(asio::buffer(read_buf) + 39);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bytes_transferred = asio::read(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  error = asio::error_code();
  bytes_transferred = asio::read(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_dynamic_string_read()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_streambuf_read()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  asio::error_code error;
  size_t bytes_transferred = asio::read(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(sb.data(), 50));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bytes_transferred = asio::read(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  error = asio::error_code();
  bytes_transferred = asio::read(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(read_data));
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
  ASIO_CHECK(!error);
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void async_read_handler(const asio::error_code& e,
    size_t bytes_transferred, size_t expected_bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!e);
  ASIO_CHECK(bytes_transferred == expected_bytes_transferred);
}

void test_3_arg_mutable_buffer_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_3_arg_boost_array_buffers_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  boost::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_3_arg_std_array_buffers_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_3_arg_vector_buffers_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf, 39) + 32);
  buffers.push_back(asio::buffer(read_buf) + 39);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_3_arg_dynamic_string_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bool called = false;
  asio::async_read(s, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  int i = asio::async_read(s, sb, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
}

void test_3_arg_streambuf_async_read()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bool called = false;
  asio::async_read(s, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  int i = asio::async_read(s, sb, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_4_arg_mutable_buffer_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  asio::mutable_buffer buffers
    = asio::buffer(read_buf, sizeof(read_buf));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_4_arg_boost_array_buffers_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  boost::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_4_arg_std_array_buffers_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::array<asio::mutable_buffer, 2> buffers = { {
    asio::buffer(read_buf, 32),
    asio::buffer(read_buf) + 32 } };

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_4_arg_vector_buffers_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  char read_buf[sizeof(read_data)];
  std::vector<asio::mutable_buffer> buffers;
  buffers.push_back(asio::buffer(read_buf, 32));
  buffers.push_back(asio::buffer(read_buf, 39) + 32);
  buffers.push_back(asio::buffer(read_buf) + 39);

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  bool called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  memset(read_buf, 0, sizeof(read_buf));
  called = false;
  asio::async_read(s, buffers, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  memset(read_buf, 0, sizeof(read_buf));
  int i = asio::async_read(s, buffers,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(read_data)));
}

void test_4_arg_dynamic_string_async_read()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bool called = false;
  asio::async_read(s, sb, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 50));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  int i = asio::async_read(s, sb,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(0, sb.size()), sizeof(read_data)));
}

void test_4_arg_streambuf_async_read()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb(sizeof(read_data));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  bool called = false;
  asio::async_read(s, sb, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_all(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_read_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 50);
  ASIO_CHECK(s.check_buffers(sb.data(), 50));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_read_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 1);
  ASIO_CHECK(s.check_buffers(sb.data(), 1));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_read_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 10);
  ASIO_CHECK(s.check_buffers(sb.data(), 10));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_read_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == 42);
  ASIO_CHECK(s.check_buffers(sb.data(), 42));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, old_style_transfer_all,
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(1);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  s.next_read_length(10);
  sb.consume(sb.size());
  called = false;
  asio::async_read(s, sb, short_transfer(),
      bindns::bind(async_read_handler,
        _1, _2, sizeof(read_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));

  s.reset(read_data, sizeof(read_data));
  sb.consume(sb.size());
  int i = asio::async_read(s, sb,
      short_transfer(), archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(sb.size() == sizeof(read_data));
  ASIO_CHECK(s.check_buffers(sb.data(), sizeof(read_data)));
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

ASIO_TEST_SUITE
(
  "read",
  ASIO_TEST_CASE(test_2_arg_zero_buffers_read)
  ASIO_TEST_CASE(test_2_arg_mutable_buffer_read)
  ASIO_TEST_CASE(test_2_arg_vector_buffers_read)
  ASIO_TEST_CASE(test_2_arg_dynamic_string_read)
  ASIO_TEST_CASE(test_2_arg_streambuf_read)
  ASIO_TEST_CASE(test_3_arg_nothrow_zero_buffers_read)
  ASIO_TEST_CASE(test_3_arg_nothrow_mutable_buffer_read)
  ASIO_TEST_CASE(test_3_arg_nothrow_vector_buffers_read)
  ASIO_TEST_CASE(test_3_arg_nothrow_dynamic_string_read)
  ASIO_TEST_CASE(test_3_arg_nothrow_streambuf_read)
  ASIO_TEST_CASE(test_3_arg_mutable_buffer_read)
  ASIO_TEST_CASE(test_3_arg_vector_buffers_read)
  ASIO_TEST_CASE(test_3_arg_dynamic_string_read)
  ASIO_TEST_CASE(test_3_arg_streambuf_read)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_read)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_read)
  ASIO_TEST_CASE(test_4_arg_dynamic_string_read)
  ASIO_TEST_CASE(test_4_arg_streambuf_read)
  ASIO_TEST_CASE(test_3_arg_mutable_buffer_async_read)
  ASIO_TEST_CASE(test_3_arg_boost_array_buffers_async_read)
  ASIO_TEST_CASE(test_3_arg_std_array_buffers_async_read)
  ASIO_TEST_CASE(test_3_arg_vector_buffers_async_read)
  ASIO_TEST_CASE(test_3_arg_dynamic_string_async_read)
  ASIO_TEST_CASE(test_3_arg_streambuf_async_read)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_async_read)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_async_read)
  ASIO_TEST_CASE(test_4_arg_boost_array_buffers_async_read)
  ASIO_TEST_CASE(test_4_arg_std_array_buffers_async_read)
  ASIO_TEST_CASE(test_4_arg_dynamic_string_async_read)
  ASIO_TEST_CASE(test_4_arg_streambuf_async_read)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\readable_pipe.cpp
//
// readable_pipe.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header pipe is self-contained.
#include "asio/readable_pipe.hpp"

#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

// readable_pipe_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// readable_pipe compile and link correctly. Runtime failures are ignored.

namespace readable_pipe_compile {

struct write_some_handler
{
  write_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  write_some_handler(write_some_handler&&) {}
private:
  write_some_handler(const write_some_handler&);
};

struct read_some_handler
{
  read_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  read_some_handler(read_some_handler&&) {}
private:
  read_some_handler(const read_some_handler&);
};

void test()
{
#if defined(ASIO_HAS_PIPE)
  using namespace asio;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    archetypes::lazy_handler lazy;
    asio::error_code ec;
    const std::string path;

    // basic_readable_pipe constructors.

    readable_pipe pipe1(ioc);
    readable_pipe::native_handle_type native_pipe1 = pipe1.native_handle();
    readable_pipe pipe2(ioc, native_pipe1);

    readable_pipe pipe3(ioc_ex);
    readable_pipe::native_handle_type native_pipe2 = pipe1.native_handle();
    readable_pipe pipe4(ioc_ex, native_pipe2);

    readable_pipe pipe5(std::move(pipe4));

    basic_readable_pipe<io_context::executor_type> pipe6(ioc);
    readable_pipe pipe7(std::move(pipe6));

    // basic_readable_pipe operators.

    pipe1 = readable_pipe(ioc);
    pipe1 = std::move(pipe2);
    pipe1 = std::move(pipe6);

    // basic_io_object functions.

    readable_pipe::executor_type ex = pipe1.get_executor();
    (void)ex;

    // basic_readable_pipe functions.

    readable_pipe::native_handle_type native_pipe3 = pipe1.native_handle();
    pipe1.assign(native_pipe3);
    readable_pipe::native_handle_type native_pipe4 = pipe1.native_handle();
    pipe1.assign(native_pipe4, ec);

    bool is_open = pipe1.is_open();
    (void)is_open;

    pipe1.close();
    pipe1.close(ec);

    readable_pipe::native_handle_type native_pipe5 = pipe1.release();
    (void)native_pipe5;
    readable_pipe::native_handle_type native_pipe6 = pipe1.release(ec);
    (void)native_pipe6;

    readable_pipe::native_handle_type native_pipe7 = pipe1.native_handle();
    (void)native_pipe7;

    pipe1.cancel();
    pipe1.cancel(ec);

    pipe1.read_some(buffer(mutable_char_buffer));
    pipe1.read_some(buffer(mutable_char_buffer), ec);

    pipe1.async_read_some(buffer(mutable_char_buffer), read_some_handler());
    int i3 = pipe1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i3;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_PIPE)
}

} // namespace readable_pipe_compile

ASIO_TEST_SUITE
(
  "readable_pipe",
  ASIO_COMPILE_TEST_CASE(readable_pipe_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\recycling_allocator.cpp
//
// recycling_allocator.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/recycling_allocator.hpp"

#include "unit_test.hpp"
#include <vector>
#include "asio/detail/type_traits.hpp"

void recycling_allocator_test()
{
  ASIO_CHECK((
      asio::is_same<
        asio::recycling_allocator<int>::value_type,
        int
      >::value));

  ASIO_CHECK((
      asio::is_same<
        asio::recycling_allocator<void>::value_type,
        void
      >::value));

  ASIO_CHECK((
      asio::is_same<
        asio::recycling_allocator<int>::rebind<char>::other,
        asio::recycling_allocator<char>
      >::value));

  ASIO_CHECK((
      asio::is_same<
        asio::recycling_allocator<void>::rebind<char>::other,
        asio::recycling_allocator<char>
      >::value));

  asio::recycling_allocator<int> a1;
  asio::recycling_allocator<int> a2(a1);

  ASIO_CHECK(a1 == a2);
  ASIO_CHECK(!(a1 != a2));

  asio::recycling_allocator<void> a3;
  asio::recycling_allocator<void> a4(a3);

  ASIO_CHECK(a3 == a4);
  ASIO_CHECK(!(a3 != a4));

  asio::recycling_allocator<int> a5(a4);
  (void)a5;

  asio::recycling_allocator<void> a6(a5);
  (void)a6;

  int* p = a1.allocate(42);
  ASIO_CHECK(p != 0);

  a1.deallocate(p, 42);

  std::vector<int, asio::recycling_allocator<int> > v(42);
  ASIO_CHECK(v.size() == 42);
}

ASIO_TEST_SUITE
(
  "recycling_allocator",
  ASIO_TEST_CASE(recycling_allocator_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\redirect_error.cpp
//
// redirect_error.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/redirect_error.hpp"

#include "asio/bind_executor.hpp"
#include "asio/deferred.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/system_timer.hpp"
#include "asio/use_future.hpp"
#include "unit_test.hpp"

struct redirect_error_handler
{
  int* count_;

  explicit redirect_error_handler(int* c)
    : count_(c)
  {
  }

  void operator()()
  {
    ++(*count_);
  }
};

void redirect_error_test()
{
  asio::io_context io1;
  asio::io_context io2;
  asio::system_timer timer1(io1);
  asio::error_code ec = asio::error::would_block;
  int count = 0;

  timer1.expires_after(asio::chrono::seconds(0));
  timer1.async_wait(
      asio::redirect_error(
        asio::bind_executor(io2.get_executor(),
          redirect_error_handler(&count)), ec));

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(count == 0);

  io1.run();

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(count == 0);

  io2.run();

  ASIO_CHECK(!ec);
  ASIO_CHECK(count == 1);

  ec = asio::error::would_block;
  timer1.async_wait(
      asio::redirect_error(
        asio::bind_executor(io2.get_executor(),
          asio::deferred), ec))(redirect_error_handler(&count));

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(count == 1);

  io1.restart();
  io1.run();

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(count == 1);

  io2.restart();
  io2.run();

  ASIO_CHECK(!ec);
  ASIO_CHECK(count == 2);

#if defined(ASIO_HAS_STD_FUTURE_CLASS)
  ec = asio::error::would_block;
  std::future<void> f = timer1.async_wait(
      asio::redirect_error(
        asio::bind_executor(io2.get_executor(),
          asio::use_future), ec));

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(f.wait_for(std::chrono::seconds(0))
      == std::future_status::timeout);

  io1.restart();
  io1.run();

  ASIO_CHECK(ec == asio::error::would_block);
  ASIO_CHECK(f.wait_for(std::chrono::seconds(0))
      == std::future_status::timeout);

  io2.restart();
  io2.run();

  ASIO_CHECK(!ec);
  ASIO_CHECK(f.wait_for(std::chrono::seconds(0))
      == std::future_status::ready);
#endif // defined(ASIO_HAS_STD_FUTURE_CLASS)
}

ASIO_TEST_SUITE
(
  "redirect_error",
  ASIO_TEST_CASE(redirect_error_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\registered_buffer.cpp
//
// registered_buffer.cpp
// ~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/registered_buffer.hpp"

#include "unit_test.hpp"

//------------------------------------------------------------------------------

// registered_buffer_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all the mutable_registered_buffer and
// const_registered_buffer classes compile and link correctly. Runtime
// failures are ignored.

namespace registered_buffer_compile {

using namespace asio;

void test()
{
  try
  {
    // mutable_registered_buffer constructors.

    mutable_registered_buffer mb1;
    mutable_registered_buffer mb2(mb1);
    (void)mb2;

    // mutable_registered_buffer functions.

    mutable_buffer b1 = mb1.buffer();
    (void)b1;

    void* ptr1 = mb1.data();
    (void)ptr1;

    std::size_t n1 = mb1.size();
    (void)n1;

    registered_buffer_id id1 = mb1.id();
    (void)id1;

    // mutable_registered_buffer operators.

    mb1 += 128;
    mb1 = mb2 + 128;
    mb1 = 128 + mb2;

    // const_registered_buffer constructors.

    const_registered_buffer cb1;
    const_registered_buffer cb2(cb1);
    (void)cb2;
    const_registered_buffer cb3(mb1);
    (void)cb3;

    // const_registered_buffer functions.

    const_buffer b2 = cb1.buffer();
    (void)b2;

    const void* ptr2 = cb1.data();
    (void)ptr2;

    std::size_t n2 = cb1.size();
    (void)n2;

    registered_buffer_id id2 = cb1.id();
    (void)id2;

    // const_registered_buffer operators.

    cb1 += 128;
    cb1 = cb2 + 128;
    cb1 = 128 + cb2;

    // buffer function overloads.

    mb1 = buffer(mb2);
    mb1 = buffer(mb2, 128);
    cb1 = buffer(cb2);
    cb1 = buffer(cb2, 128);
  }
  catch (std::exception&)
  {
  }
}

} // namespace buffer_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "registered_buffer",
  ASIO_COMPILE_TEST_CASE(registered_buffer_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\serial_port_base.cpp
//
// serial_port_base.cpp
// ~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/serial_port_base.hpp"

#include "asio/io_context.hpp"
#include "asio/serial_port.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

// serial_port_base_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Verify that all options and and their accessors compile. Runtime failures are
// ignored.

namespace serial_port_base_compile {

void test()
{
#if defined(ASIO_HAS_SERIAL_PORT)
  using namespace asio;

  try
  {
    io_context ioc;
    serial_port port(ioc);

    // baud_rate class.

    serial_port_base::baud_rate baud_rate1(9600);
    port.set_option(baud_rate1);
    serial_port_base::baud_rate baud_rate2;
    port.get_option(baud_rate2);
    (void)static_cast<unsigned int>(baud_rate2.value());

    // flow_control class.

    serial_port_base::flow_control flow_control1(
      serial_port_base::flow_control::none);
    port.set_option(flow_control1);
    serial_port_base::flow_control flow_control2;
    port.get_option(flow_control2);
    (void)static_cast<serial_port_base::flow_control::type>(
        flow_control2.value());

    // parity class.

    serial_port_base::parity parity1(serial_port_base::parity::none);
    port.set_option(parity1);
    serial_port_base::parity parity2;
    port.get_option(parity2);
    (void)static_cast<serial_port_base::parity::type>(parity2.value());

    // stop_bits class.

    serial_port_base::stop_bits stop_bits1(serial_port_base::stop_bits::one);
    port.set_option(stop_bits1);
    serial_port_base::stop_bits stop_bits2;
    port.get_option(stop_bits2);
    (void)static_cast<serial_port_base::stop_bits::type>(stop_bits2.value());

    // character_size class.

    serial_port_base::character_size character_size1(8);
    port.set_option(character_size1);
    serial_port_base::character_size character_size2;
    port.get_option(character_size2);
    (void)static_cast<unsigned int>(character_size2.value());
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_SERIAL_PORT)
}

} // namespace serial_port_base_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "serial_port_base",
  ASIO_COMPILE_TEST_CASE(serial_port_base_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\serial_port.cpp
//
// serial_port.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
// Copyright (c) 2008 Rep Invariant Systems, Inc. (info@repinvariant.com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/serial_port.hpp"

#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

// serial_port_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// serial_port compile and link correctly. Runtime failures are ignored.

namespace serial_port_compile {

struct write_some_handler
{
  write_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  write_some_handler(write_some_handler&&) {}
private:
  write_some_handler(const write_some_handler&);
};

struct read_some_handler
{
  read_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  read_some_handler(read_some_handler&&) {}
private:
  read_some_handler(const read_some_handler&);
};

void test()
{
#if defined(ASIO_HAS_SERIAL_PORT)
  using namespace asio;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    serial_port::baud_rate serial_port_option;
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_serial_port constructors.

    serial_port port1(ioc);
    serial_port port2(ioc, "null");
    serial_port::native_handle_type native_port1 = port1.native_handle();
#if defined(ASIO_MSVC) && (_MSC_VER < 1910)
    // Skip this on older MSVC due to mysterious ambiguous overload errors.
#else
    serial_port port3(ioc, native_port1);
#endif

    serial_port port4(ioc_ex);
    serial_port port5(ioc_ex, "null");
    serial_port::native_handle_type native_port2 = port1.native_handle();
    serial_port port6(ioc_ex, native_port2);

    serial_port port7(std::move(port6));

    basic_serial_port<io_context::executor_type> port8(ioc);
    serial_port port9(std::move(port8));

    // basic_serial_port operators.

    port1 = serial_port(ioc);
    port1 = std::move(port2);
    port1 = std::move(port8);

    // basic_io_object functions.

    serial_port::executor_type ex = port1.get_executor();
    (void)ex;

    // basic_serial_port functions.

    serial_port::lowest_layer_type& lowest_layer = port1.lowest_layer();
    (void)lowest_layer;

    const serial_port& port10 = port1;
    const serial_port::lowest_layer_type& lowest_layer2 = port10.lowest_layer();
    (void)lowest_layer2;

    port1.open("null");
    port1.open("null", ec);

    serial_port::native_handle_type native_port3 = port1.native_handle();
    port1.assign(native_port3);
    serial_port::native_handle_type native_port4 = port1.native_handle();
    port1.assign(native_port4, ec);

    bool is_open = port1.is_open();
    (void)is_open;

    port1.close();
    port1.close(ec);

    serial_port::native_handle_type native_port5 = port1.native_handle();
    (void)native_port5;

    port1.cancel();
    port1.cancel(ec);

    port1.set_option(serial_port_option);
    port1.set_option(serial_port_option, ec);

    port1.get_option(serial_port_option);
    port1.get_option(serial_port_option, ec);

    port1.send_break();
    port1.send_break(ec);

    port1.write_some(buffer(mutable_char_buffer));
    port1.write_some(buffer(const_char_buffer));
    port1.write_some(buffer(mutable_char_buffer), ec);
    port1.write_some(buffer(const_char_buffer), ec);

    port1.async_write_some(buffer(mutable_char_buffer), write_some_handler());
    port1.async_write_some(buffer(const_char_buffer), write_some_handler());
    int i1 = port1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = port1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;

    port1.read_some(buffer(mutable_char_buffer));
    port1.read_some(buffer(mutable_char_buffer), ec);

    port1.async_read_some(buffer(mutable_char_buffer), read_some_handler());
    int i3 = port1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i3;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_SERIAL_PORT)
}

} // namespace serial_port_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "serial_port",
  ASIO_COMPILE_TEST_CASE(serial_port_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\signal_set_base.cpp
//
// signal_set_base.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/signal_set_base.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "signal_set_base",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\signal_set.cpp
//
// signal_set.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/signal_set.hpp"

#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

// signal_set_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// signal_set compile and link correctly. Runtime failures are ignored.

namespace signal_set_compile {

void signal_handler(const asio::error_code&, int)
{
}

void test()
{
  using namespace asio;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_signal_set constructors.

    signal_set set1(ioc);
    signal_set set2(ioc, 1);
    signal_set set3(ioc, 1, 2);
    signal_set set4(ioc, 1, 2, 3);

    signal_set set5(ioc_ex);
    signal_set set6(ioc_ex, 1);
    signal_set set7(ioc_ex, 1, 2);
    signal_set set8(ioc_ex, 1, 2, 3);

    // basic_io_object functions.

    signal_set::executor_type ex = set1.get_executor();
    (void)ex;

    // basic_signal_set functions.

    set1.add(1);
    set1.add(1, ec);

    set1.add(1, signal_set::flags::dont_care);
    set1.add(1, signal_set::flags::dont_care, ec);

    set1.remove(1);
    set1.remove(1, ec);

    set1.clear();
    set1.clear(ec);

    set1.cancel();
    set1.cancel(ec);

    set1.async_wait(&signal_handler);
    int i = set1.async_wait(lazy);
    (void)i;
  }
  catch (std::exception&)
  {
  }
}

} // namespace signal_set_compile

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "signal_set",
  ASIO_COMPILE_TEST_CASE(signal_set_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\socket_base.cpp
//
// socket_base.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/socket_base.hpp"

#include "asio/io_context.hpp"
#include "asio/ip/tcp.hpp"
#include "asio/ip/udp.hpp"
#include "unit_test.hpp"

//------------------------------------------------------------------------------

// socket_base_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all nested classes, enums and constants in
// socket_base compile and link correctly. Runtime failures are ignored.

namespace socket_base_compile {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  try
  {
    io_context ioc;
    ip::tcp::socket sock(ioc);
    char buf[1024];

    // shutdown_type enumeration.

    sock.shutdown(socket_base::shutdown_receive);
    sock.shutdown(socket_base::shutdown_send);
    sock.shutdown(socket_base::shutdown_both);

    // message_flags constants.

    sock.receive(buffer(buf), socket_base::message_peek);
    sock.receive(buffer(buf), socket_base::message_out_of_band);
    sock.send(buffer(buf), socket_base::message_do_not_route);

    // broadcast class.

    socket_base::broadcast broadcast1(true);
    sock.set_option(broadcast1);
    socket_base::broadcast broadcast2;
    sock.get_option(broadcast2);
    broadcast1 = true;
    (void)static_cast<bool>(broadcast1);
    (void)static_cast<bool>(!broadcast1);
    (void)static_cast<bool>(broadcast1.value());

    // debug class.

    socket_base::debug debug1(true);
    sock.set_option(debug1);
    socket_base::debug debug2;
    sock.get_option(debug2);
    debug1 = true;
    (void)static_cast<bool>(debug1);
    (void)static_cast<bool>(!debug1);
    (void)static_cast<bool>(debug1.value());

    // do_not_route class.

    socket_base::do_not_route do_not_route1(true);
    sock.set_option(do_not_route1);
    socket_base::do_not_route do_not_route2;
    sock.get_option(do_not_route2);
    do_not_route1 = true;
    (void)static_cast<bool>(do_not_route1);
    (void)static_cast<bool>(!do_not_route1);
    (void)static_cast<bool>(do_not_route1.value());

    // keep_alive class.

    socket_base::keep_alive keep_alive1(true);
    sock.set_option(keep_alive1);
    socket_base::keep_alive keep_alive2;
    sock.get_option(keep_alive2);
    keep_alive1 = true;
    (void)static_cast<bool>(keep_alive1);
    (void)static_cast<bool>(!keep_alive1);
    (void)static_cast<bool>(keep_alive1.value());

    // send_buffer_size class.

    socket_base::send_buffer_size send_buffer_size1(1024);
    sock.set_option(send_buffer_size1);
    socket_base::send_buffer_size send_buffer_size2;
    sock.get_option(send_buffer_size2);
    send_buffer_size1 = 1;
    (void)static_cast<int>(send_buffer_size1.value());

    // send_low_watermark class.

    socket_base::send_low_watermark send_low_watermark1(128);
    sock.set_option(send_low_watermark1);
    socket_base::send_low_watermark send_low_watermark2;
    sock.get_option(send_low_watermark2);
    send_low_watermark1 = 1;
    (void)static_cast<int>(send_low_watermark1.value());

    // receive_buffer_size class.

    socket_base::receive_buffer_size receive_buffer_size1(1024);
    sock.set_option(receive_buffer_size1);
    socket_base::receive_buffer_size receive_buffer_size2;
    sock.get_option(receive_buffer_size2);
    receive_buffer_size1 = 1;
    (void)static_cast<int>(receive_buffer_size1.value());

    // receive_low_watermark class.

    socket_base::receive_low_watermark receive_low_watermark1(128);
    sock.set_option(receive_low_watermark1);
    socket_base::receive_low_watermark receive_low_watermark2;
    sock.get_option(receive_low_watermark2);
    receive_low_watermark1 = 1;
    (void)static_cast<int>(receive_low_watermark1.value());

    // reuse_address class.

    socket_base::reuse_address reuse_address1(true);
    sock.set_option(reuse_address1);
    socket_base::reuse_address reuse_address2;
    sock.get_option(reuse_address2);
    reuse_address1 = true;
    (void)static_cast<bool>(reuse_address1);
    (void)static_cast<bool>(!reuse_address1);
    (void)static_cast<bool>(reuse_address1.value());

    // linger class.

    socket_base::linger linger1(true, 30);
    sock.set_option(linger1);
    socket_base::linger linger2;
    sock.get_option(linger2);
    linger1.enabled(true);
    (void)static_cast<bool>(linger1.enabled());
    linger1.timeout(1);
    (void)static_cast<int>(linger1.timeout());

    // out_of_band_inline class.

    socket_base::out_of_band_inline out_of_band_inline1(true);
    sock.set_option(out_of_band_inline1);
    socket_base::out_of_band_inline out_of_band_inline2;
    sock.get_option(out_of_band_inline2);
    out_of_band_inline1 = true;
    (void)static_cast<bool>(out_of_band_inline1);
    (void)static_cast<bool>(!out_of_band_inline1);
    (void)static_cast<bool>(out_of_band_inline1.value());

    // enable_connection_aborted class.

    socket_base::enable_connection_aborted enable_connection_aborted1(true);
    sock.set_option(enable_connection_aborted1);
    socket_base::enable_connection_aborted enable_connection_aborted2;
    sock.get_option(enable_connection_aborted2);
    enable_connection_aborted1 = true;
    (void)static_cast<bool>(enable_connection_aborted1);
    (void)static_cast<bool>(!enable_connection_aborted1);
    (void)static_cast<bool>(enable_connection_aborted1.value());

    // bytes_readable class.

    socket_base::bytes_readable bytes_readable;
    sock.io_control(bytes_readable);
    std::size_t bytes = bytes_readable.get();
    (void)bytes;
  }
  catch (std::exception&)
  {
  }
}

} // namespace socket_base_compile

//------------------------------------------------------------------------------

// socket_base_runtime test
// ~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks the runtime operation of the socket options and I/O
// control commands defined in socket_base.

namespace socket_base_runtime {

void test()
{
  using namespace asio;
  namespace ip = asio::ip;

  io_context ioc;
  ip::udp::socket udp_sock(ioc, ip::udp::v4());
  ip::tcp::socket tcp_sock(ioc, ip::tcp::v4());
  ip::tcp::acceptor tcp_acceptor(ioc, ip::tcp::v4());
  asio::error_code ec;

  // broadcast class.

  socket_base::broadcast broadcast1(true);
  ASIO_CHECK(broadcast1.value());
  ASIO_CHECK(static_cast<bool>(broadcast1));
  ASIO_CHECK(!!broadcast1);
  udp_sock.set_option(broadcast1, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::broadcast broadcast2;
  udp_sock.get_option(broadcast2, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(broadcast2.value());
  ASIO_CHECK(static_cast<bool>(broadcast2));
  ASIO_CHECK(!!broadcast2);

  socket_base::broadcast broadcast3(false);
  ASIO_CHECK(!broadcast3.value());
  ASIO_CHECK(!static_cast<bool>(broadcast3));
  ASIO_CHECK(!broadcast3);
  udp_sock.set_option(broadcast3, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::broadcast broadcast4;
  udp_sock.get_option(broadcast4, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(!broadcast4.value());
  ASIO_CHECK(!static_cast<bool>(broadcast4));
  ASIO_CHECK(!broadcast4);

  // debug class.

  socket_base::debug debug1(true);
  ASIO_CHECK(debug1.value());
  ASIO_CHECK(static_cast<bool>(debug1));
  ASIO_CHECK(!!debug1);
  udp_sock.set_option(debug1, ec);
#if defined(__linux__)
  // On Linux, only root can set SO_DEBUG.
  bool not_root = (ec == asio::error::access_denied);
  ASIO_CHECK(!ec || not_root);
  ASIO_WARN_MESSAGE(!ec, "Must be root to set debug socket option");
#else // defined(__linux__)
# if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
# else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
# endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)
#endif // defined(__linux__)

  socket_base::debug debug2;
  udp_sock.get_option(debug2, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
# if defined(__linux__)
  ASIO_CHECK(debug2.value() || not_root);
  ASIO_CHECK(static_cast<bool>(debug2) || not_root);
  ASIO_CHECK(!!debug2 || not_root);
# else // defined(__linux__)
  ASIO_CHECK(debug2.value());
  ASIO_CHECK(static_cast<bool>(debug2));
  ASIO_CHECK(!!debug2);
# endif // defined(__linux__)
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::debug debug3(false);
  ASIO_CHECK(!debug3.value());
  ASIO_CHECK(!static_cast<bool>(debug3));
  ASIO_CHECK(!debug3);
  udp_sock.set_option(debug3, ec);
#if defined(__linux__)
  ASIO_CHECK(!ec || not_root);
#else // defined(__linux__)
# if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
# else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
# endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)
#endif // defined(__linux__)

  socket_base::debug debug4;
  udp_sock.get_option(debug4, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
# if defined(__linux__)
  ASIO_CHECK(!debug4.value() || not_root);
  ASIO_CHECK(!static_cast<bool>(debug4) || not_root);
  ASIO_CHECK(!debug4 || not_root);
# else // defined(__linux__)
  ASIO_CHECK(!debug4.value());
  ASIO_CHECK(!static_cast<bool>(debug4));
  ASIO_CHECK(!debug4);
# endif // defined(__linux__)
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  // do_not_route class.

  socket_base::do_not_route do_not_route1(true);
  ASIO_CHECK(do_not_route1.value());
  ASIO_CHECK(static_cast<bool>(do_not_route1));
  ASIO_CHECK(!!do_not_route1);
  udp_sock.set_option(do_not_route1, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::do_not_route do_not_route2;
  udp_sock.get_option(do_not_route2, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(do_not_route2.value());
  ASIO_CHECK(static_cast<bool>(do_not_route2));
  ASIO_CHECK(!!do_not_route2);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::do_not_route do_not_route3(false);
  ASIO_CHECK(!do_not_route3.value());
  ASIO_CHECK(!static_cast<bool>(do_not_route3));
  ASIO_CHECK(!do_not_route3);
  udp_sock.set_option(do_not_route3, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::do_not_route do_not_route4;
  udp_sock.get_option(do_not_route4, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(!do_not_route4.value());
  ASIO_CHECK(!static_cast<bool>(do_not_route4));
  ASIO_CHECK(!do_not_route4);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  // keep_alive class.

  socket_base::keep_alive keep_alive1(true);
  ASIO_CHECK(keep_alive1.value());
  ASIO_CHECK(static_cast<bool>(keep_alive1));
  ASIO_CHECK(!!keep_alive1);
  tcp_sock.set_option(keep_alive1, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::keep_alive keep_alive2;
  tcp_sock.get_option(keep_alive2, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(keep_alive2.value());
  ASIO_CHECK(static_cast<bool>(keep_alive2));
  ASIO_CHECK(!!keep_alive2);

  socket_base::keep_alive keep_alive3(false);
  ASIO_CHECK(!keep_alive3.value());
  ASIO_CHECK(!static_cast<bool>(keep_alive3));
  ASIO_CHECK(!keep_alive3);
  tcp_sock.set_option(keep_alive3, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::keep_alive keep_alive4;
  tcp_sock.get_option(keep_alive4, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(!keep_alive4.value());
  ASIO_CHECK(!static_cast<bool>(keep_alive4));
  ASIO_CHECK(!keep_alive4);

  // send_buffer_size class.

  socket_base::send_buffer_size send_buffer_size1(4096);
  ASIO_CHECK(send_buffer_size1.value() == 4096);
  tcp_sock.set_option(send_buffer_size1, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::send_buffer_size send_buffer_size2;
  tcp_sock.get_option(send_buffer_size2, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(send_buffer_size2.value() == 4096);

  socket_base::send_buffer_size send_buffer_size3(16384);
  ASIO_CHECK(send_buffer_size3.value() == 16384);
  tcp_sock.set_option(send_buffer_size3, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::send_buffer_size send_buffer_size4;
  tcp_sock.get_option(send_buffer_size4, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(send_buffer_size4.value() == 16384);

  // send_low_watermark class.

  socket_base::send_low_watermark send_low_watermark1(4096);
  ASIO_CHECK(send_low_watermark1.value() == 4096);
  tcp_sock.set_option(send_low_watermark1, ec);
#if defined(WIN32) || defined(__linux__) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows, Linux or Solaris.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif

  socket_base::send_low_watermark send_low_watermark2;
  tcp_sock.get_option(send_low_watermark2, ec);
#if defined(WIN32) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows or Solaris.
#elif defined(__linux__)
  ASIO_CHECK(!ec); // Not supported on Linux but can get value.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(send_low_watermark2.value() == 4096);
#endif

  socket_base::send_low_watermark send_low_watermark3(8192);
  ASIO_CHECK(send_low_watermark3.value() == 8192);
  tcp_sock.set_option(send_low_watermark3, ec);
#if defined(WIN32) || defined(__linux__) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows, Linux or Solaris.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif

  socket_base::send_low_watermark send_low_watermark4;
  tcp_sock.get_option(send_low_watermark4, ec);
#if defined(WIN32) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows or Solaris.
#elif defined(__linux__)
  ASIO_CHECK(!ec); // Not supported on Linux but can get value.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(send_low_watermark4.value() == 8192);
#endif

  // receive_buffer_size class.

  socket_base::receive_buffer_size receive_buffer_size1(4096);
  ASIO_CHECK(receive_buffer_size1.value() == 4096);
  tcp_sock.set_option(receive_buffer_size1, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::receive_buffer_size receive_buffer_size2;
  tcp_sock.get_option(receive_buffer_size2, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK(!ec); // Not supported under Windows CE but can get value.
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(receive_buffer_size2.value() == 4096);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::receive_buffer_size receive_buffer_size3(16384);
  ASIO_CHECK(receive_buffer_size3.value() == 16384);
  tcp_sock.set_option(receive_buffer_size3, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  // Option is not supported under Windows CE.
  ASIO_CHECK_MESSAGE(ec == asio::error::no_protocol_option,
      ec.value() << ", " << ec.message());
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  socket_base::receive_buffer_size receive_buffer_size4;
  tcp_sock.get_option(receive_buffer_size4, ec);
#if defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK(!ec); // Not supported under Windows CE but can get value.
#else // defined(ASIO_WINDOWS) && defined(UNDER_CE)
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(receive_buffer_size4.value() == 16384);
#endif // defined(ASIO_WINDOWS) && defined(UNDER_CE)

  // receive_low_watermark class.

  socket_base::receive_low_watermark receive_low_watermark1(4096);
  ASIO_CHECK(receive_low_watermark1.value() == 4096);
  tcp_sock.set_option(receive_low_watermark1, ec);
#if defined(WIN32) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows or Solaris.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif

  socket_base::receive_low_watermark receive_low_watermark2;
  tcp_sock.get_option(receive_low_watermark2, ec);
#if defined(WIN32) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows or Solaris.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(receive_low_watermark2.value() == 4096);
#endif

  socket_base::receive_low_watermark receive_low_watermark3(8192);
  ASIO_CHECK(receive_low_watermark3.value() == 8192);
  tcp_sock.set_option(receive_low_watermark3, ec);
#if defined(WIN32) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows or Solaris.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
#endif

  socket_base::receive_low_watermark receive_low_watermark4;
  tcp_sock.get_option(receive_low_watermark4, ec);
#if defined(WIN32) || defined(__sun)
  ASIO_CHECK(!!ec); // Not supported on Windows or Solaris.
#else
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(receive_low_watermark4.value() == 8192);
#endif

  // reuse_address class.

  socket_base::reuse_address reuse_address1(true);
  ASIO_CHECK(reuse_address1.value());
  ASIO_CHECK(static_cast<bool>(reuse_address1));
  ASIO_CHECK(!!reuse_address1);
  udp_sock.set_option(reuse_address1, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::reuse_address reuse_address2;
  udp_sock.get_option(reuse_address2, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(reuse_address2.value());
  ASIO_CHECK(static_cast<bool>(reuse_address2));
  ASIO_CHECK(!!reuse_address2);

  socket_base::reuse_address reuse_address3(false);
  ASIO_CHECK(!reuse_address3.value());
  ASIO_CHECK(!static_cast<bool>(reuse_address3));
  ASIO_CHECK(!reuse_address3);
  udp_sock.set_option(reuse_address3, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::reuse_address reuse_address4;
  udp_sock.get_option(reuse_address4, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(!reuse_address4.value());
  ASIO_CHECK(!static_cast<bool>(reuse_address4));
  ASIO_CHECK(!reuse_address4);

  // linger class.

  socket_base::linger linger1(true, 60);
  ASIO_CHECK(linger1.enabled());
  ASIO_CHECK(linger1.timeout() == 60);
  tcp_sock.set_option(linger1, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::linger linger2;
  tcp_sock.get_option(linger2, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(linger2.enabled());
  ASIO_CHECK(linger2.timeout() == 60);

  socket_base::linger linger3(false, 0);
  ASIO_CHECK(!linger3.enabled());
  ASIO_CHECK(linger3.timeout() == 0);
  tcp_sock.set_option(linger3, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::linger linger4;
  tcp_sock.get_option(linger4, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(!linger4.enabled());

  // enable_connection_aborted class.

  socket_base::enable_connection_aborted enable_connection_aborted1(true);
  ASIO_CHECK(enable_connection_aborted1.value());
  ASIO_CHECK(static_cast<bool>(enable_connection_aborted1));
  ASIO_CHECK(!!enable_connection_aborted1);
  tcp_acceptor.set_option(enable_connection_aborted1, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::enable_connection_aborted enable_connection_aborted2;
  tcp_acceptor.get_option(enable_connection_aborted2, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(enable_connection_aborted2.value());
  ASIO_CHECK(static_cast<bool>(enable_connection_aborted2));
  ASIO_CHECK(!!enable_connection_aborted2);

  socket_base::enable_connection_aborted enable_connection_aborted3(false);
  ASIO_CHECK(!enable_connection_aborted3.value());
  ASIO_CHECK(!static_cast<bool>(enable_connection_aborted3));
  ASIO_CHECK(!enable_connection_aborted3);
  tcp_acceptor.set_option(enable_connection_aborted3, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());

  socket_base::enable_connection_aborted enable_connection_aborted4;
  tcp_acceptor.get_option(enable_connection_aborted4, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
  ASIO_CHECK(!enable_connection_aborted4.value());
  ASIO_CHECK(!static_cast<bool>(enable_connection_aborted4));
  ASIO_CHECK(!enable_connection_aborted4);

  // bytes_readable class.

  socket_base::bytes_readable bytes_readable;
  udp_sock.io_control(bytes_readable, ec);
  ASIO_CHECK_MESSAGE(!ec, ec.value() << ", " << ec.message());
}

} // namespace socket_base_runtime

//------------------------------------------------------------------------------

ASIO_TEST_SUITE
(
  "socket_base",
  ASIO_COMPILE_TEST_CASE(socket_base_compile::test)
  ASIO_TEST_CASE(socket_base_runtime::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\static_thread_pool.cpp
//
// static_thread_pool.cpp
// ~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/static_thread_pool.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "static_thread_pool",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\steady_timer.cpp
//
// steady_timer.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/steady_timer.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "steady_timer",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\strand.cpp
//
// strand.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/strand.hpp"

#include <functional>
#include <sstream>
#include "asio/executor.hpp"
#include "asio/io_context.hpp"
#include "asio/dispatch.hpp"
#include "asio/post.hpp"
#include "asio/thread.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/deadline_timer.hpp"
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
# include "asio/steady_timer.hpp"
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

using namespace asio;
namespace bindns = std;

#if defined(ASIO_HAS_BOOST_DATE_TIME)
typedef deadline_timer timer;
namespace chronons = boost::posix_time;
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
typedef steady_timer timer;
namespace chronons = asio::chrono;
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)

void increment(int* count)
{
  ++(*count);
}

void increment_without_lock(strand<io_context::executor_type>* s, int* count)
{
  ASIO_CHECK(!s->running_in_this_thread());

  int original_count = *count;

  dispatch(*s, bindns::bind(increment, count));

  // No other functions are currently executing through the locking dispatcher,
  // so the previous call to dispatch should have successfully nested.
  ASIO_CHECK(*count == original_count + 1);
}

void increment_with_lock(strand<io_context::executor_type>* s, int* count)
{
  ASIO_CHECK(s->running_in_this_thread());

  int original_count = *count;

  dispatch(*s, bindns::bind(increment, count));

  // The current function already holds the strand's lock, so the
  // previous call to dispatch should have successfully nested.
  ASIO_CHECK(*count == original_count + 1);
}

void sleep_increment(io_context* ioc, int* count)
{
  timer t(*ioc, chronons::seconds(2));
  t.wait();

  ++(*count);
}

void increment_by_a(int* count, int a)
{
  (*count) += a;
}

void increment_by_a_b(int* count, int a, int b)
{
  (*count) += a + b;
}

void increment_by_a_b_c(int* count, int a, int b, int c)
{
  (*count) += a + b + c;
}

void increment_by_a_b_c_d(int* count, int a, int b, int c, int d)
{
  (*count) += a + b + c + d;
}

void start_sleep_increments(io_context* ioc,
    strand<io_context::executor_type>* s, int* count)
{
  // Give all threads a chance to start.
  timer t(*ioc, chronons::seconds(2));
  t.wait();

  // Start three increments.
  post(*s, bindns::bind(sleep_increment, ioc, count));
  post(*s, bindns::bind(sleep_increment, ioc, count));
  post(*s, bindns::bind(sleep_increment, ioc, count));
}

void throw_exception()
{
  throw 1;
}

void io_context_run(io_context* ioc)
{
  ioc->run();
}

void strand_test()
{
  io_context ioc;
  strand<io_context::executor_type> s = make_strand(ioc);
  int count = 0;

  post(ioc, bindns::bind(increment_without_lock, &s, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  post(s, bindns::bind(increment_with_lock, &s, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  post(ioc, bindns::bind(start_sleep_increments, &ioc, &s, &count));
  thread thread1(bindns::bind(io_context_run, &ioc));
  thread thread2(bindns::bind(io_context_run, &ioc));

  // Check all events run one after another even though there are two threads.
  timer timer1(ioc, chronons::seconds(3));
  timer1.wait();
  ASIO_CHECK(count == 0);
#if defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expires_at() + chronons::seconds(2));
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expiry() + chronons::seconds(2));
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.wait();
  ASIO_CHECK(count == 1);
#if defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expires_at() + chronons::seconds(2));
#else // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.expires_at(timer1.expiry() + chronons::seconds(2));
#endif // defined(ASIO_HAS_BOOST_DATE_TIME)
  timer1.wait();
  ASIO_CHECK(count == 2);

  thread1.join();
  thread2.join();

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 3);

  count = 0;
  int exception_count = 0;
  ioc.restart();
  post(s, throw_exception);
  post(s, bindns::bind(increment, &count));
  post(s, bindns::bind(increment, &count));
  post(s, throw_exception);
  post(s, bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);
  ASIO_CHECK(exception_count == 0);

  for (;;)
  {
    try
    {
      ioc.run();
      break;
    }
    catch (int)
    {
      ++exception_count;
    }
  }

  // The run() calls will not return until all work has finished.
  ASIO_CHECK(count == 3);
  ASIO_CHECK(exception_count == 2);

  count = 0;
  ioc.restart();

  // Check for clean shutdown when handlers posted through an orphaned strand
  // are abandoned.
  {
    strand<io_context::executor_type> s2 = make_strand(ioc.get_executor());
    post(s2, bindns::bind(increment, &count));
    post(s2, bindns::bind(increment, &count));
    post(s2, bindns::bind(increment, &count));
  }

  // No handlers can be called until run() is called.
  ASIO_CHECK(count == 0);
}

void strand_conversion_test()
{
  io_context ioc;
  strand<io_context::executor_type> s1 = make_strand(ioc);

  // Converting constructors.

  strand<executor> s2(s1);
  strand<executor> s3 = strand<io_context::executor_type>(s1);

  // Converting assignment.

  s3 = s1;
  s3 = strand<io_context::executor_type>(s1);
}

void strand_query_test()
{
  io_context ioc;
  strand<io_context::executor_type> s1 = make_strand(ioc);

  ASIO_CHECK(
      &asio::query(s1, asio::execution::context)
        == &ioc);

  ASIO_CHECK(
      asio::query(s1, asio::execution::blocking)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(s1, asio::execution::blocking.possibly)
        == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(s1, asio::execution::outstanding_work)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(s1, asio::execution::outstanding_work.untracked)
        == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(s1, asio::execution::relationship)
        == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(s1, asio::execution::relationship.fork)
        == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(s1, asio::execution::mapping)
        == asio::execution::mapping.thread);

  ASIO_CHECK(
      asio::query(s1, asio::execution::allocator)
        == std::allocator<void>());
}

void strand_execute_test()
{
  io_context ioc;
  strand<io_context::executor_type> s1 = make_strand(ioc);
  int count = 0;

  s1.execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(s1, asio::execution::blocking.possibly).execute(
      bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(s1, asio::execution::blocking.never).execute(
      bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  ASIO_CHECK(!ioc.stopped());

  asio::require(s1,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.tracked
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(s1,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(s1,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.fork
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::require(s1,
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.continuation
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::prefer(
      asio::require(s1,
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator(std::allocator<void>())
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);

  count = 0;
  ioc.restart();
  asio::prefer(
      asio::require(s1,
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator
    ).execute(bindns::bind(increment, &count));

  // No handlers can be called until run() is called.
  ASIO_CHECK(!ioc.stopped());
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all work has finished.
  ASIO_CHECK(ioc.stopped());
  ASIO_CHECK(count == 1);
}

ASIO_TEST_SUITE
(
  "strand",
  ASIO_TEST_CASE(strand_test)
  ASIO_COMPILE_TEST_CASE(strand_conversion_test)
  ASIO_TEST_CASE(strand_query_test)
  ASIO_TEST_CASE(strand_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\stream_file.cpp
//
// stream_file.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/stream_file.hpp"

#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

// stream_file_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// stream_file compile and link correctly. Runtime failures are ignored.

namespace stream_file_compile {

struct write_some_handler
{
  write_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  write_some_handler(write_some_handler&&) {}
private:
  write_some_handler(const write_some_handler&);
};

struct read_some_handler
{
  read_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  read_some_handler(read_some_handler&&) {}
private:
  read_some_handler(const read_some_handler&);
};

void test()
{
#if defined(ASIO_HAS_FILE)
  using namespace asio;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    archetypes::lazy_handler lazy;
    asio::error_code ec;
    const std::string path;

    // basic_stream_file constructors.

    stream_file file1(ioc);
    stream_file file2(ioc, "", stream_file::read_only);
    stream_file file3(ioc, path, stream_file::read_only);
    stream_file::native_handle_type native_file1 = file1.native_handle();
    stream_file file4(ioc, native_file1);

    stream_file file5(ioc_ex);
    stream_file file6(ioc_ex, "", stream_file::read_only);
    stream_file file7(ioc_ex, path, stream_file::read_only);
    stream_file::native_handle_type native_file2 = file1.native_handle();
    stream_file file8(ioc_ex, native_file2);

    stream_file file9(std::move(file8));

    basic_stream_file<io_context::executor_type> file10(ioc);
    stream_file file11(std::move(file10));

    // basic_stream_file operators.

    file1 = stream_file(ioc);
    file1 = std::move(file2);
    file1 = std::move(file10);

    // basic_io_object functions.

    stream_file::executor_type ex = file1.get_executor();
    (void)ex;

    // basic_stream_file functions.

    file1.open("", stream_file::read_only);
    file1.open("", stream_file::read_only, ec);

    file1.open(path, stream_file::read_only);
    file1.open(path, stream_file::read_only, ec);

    stream_file::native_handle_type native_file3 = file1.native_handle();
    file1.assign(native_file3);
    stream_file::native_handle_type native_file4 = file1.native_handle();
    file1.assign(native_file4, ec);

    bool is_open = file1.is_open();
    (void)is_open;

    file1.close();
    file1.close(ec);

    stream_file::native_handle_type native_file5 = file1.native_handle();
    (void)native_file5;

    stream_file::native_handle_type native_file6 = file1.release();
    (void)native_file6;
    stream_file::native_handle_type native_file7 = file1.release(ec);
    (void)native_file7;

    file1.cancel();
    file1.cancel(ec);

    asio::uint64_t s1 = file1.size();
    (void)s1;
    asio::uint64_t s2 = file1.size(ec);
    (void)s2;

    file1.resize(asio::uint64_t(0));
    file1.resize(asio::uint64_t(0), ec);

    file1.sync_all();
    file1.sync_all(ec);

    file1.sync_data();
    file1.sync_data(ec);

    asio::uint64_t s3 = file1.seek(0, stream_file::seek_set);
    (void)s3;
    asio::uint64_t s4 = file1.seek(0, stream_file::seek_set, ec);
    (void)s4;

    file1.write_some(buffer(mutable_char_buffer));
    file1.write_some(buffer(const_char_buffer));
    file1.write_some(buffer(mutable_char_buffer), ec);
    file1.write_some(buffer(const_char_buffer), ec);

    file1.async_write_some(buffer(mutable_char_buffer), write_some_handler());
    file1.async_write_some(buffer(const_char_buffer), write_some_handler());
    int i1 = file1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = file1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;

    file1.read_some(buffer(mutable_char_buffer));
    file1.read_some(buffer(mutable_char_buffer), ec);

    file1.async_read_some(buffer(mutable_char_buffer), read_some_handler());
    int i3 = file1.async_read_some(buffer(mutable_char_buffer), lazy);
    (void)i3;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_FILE)
}

} // namespace stream_file_compile

ASIO_TEST_SUITE
(
  "stream_file",
  ASIO_COMPILE_TEST_CASE(stream_file_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\streambuf.cpp
//
// streambuf.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/streambuf.hpp"

#include "asio/buffer.hpp"
#include "unit_test.hpp"

void streambuf_test()
{
  asio::streambuf sb;

  sb.sputn("abcd", 4);

  ASIO_CHECK(sb.size() == 4);

  for (int i = 0; i < 100; ++i)
  {
    sb.consume(3);

    ASIO_CHECK(sb.size() == 1);

    char buf[1];
    sb.sgetn(buf, 1);

    ASIO_CHECK(sb.size() == 0);

    sb.sputn("ab", 2);

    ASIO_CHECK(sb.size() == 2);

    asio::buffer_copy(sb.prepare(10), asio::buffer("cd", 2));
    sb.commit(2);

    ASIO_CHECK(sb.size() == 4);
  }

  ASIO_CHECK(sb.size() == 4);

  sb.consume(4);

  ASIO_CHECK(sb.size() == 0);
}

ASIO_TEST_SUITE
(
  "streambuf",
  ASIO_TEST_CASE(streambuf_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\system_context.cpp
//
// system_context.cpp
// ~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/system_context.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "system_context",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\system_executor.cpp
//
// system_executor.cpp
// ~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/system_executor.hpp"

#include <functional>
#include "asio/dispatch.hpp"
#include "asio/post.hpp"
#include "unit_test.hpp"

using namespace asio;

namespace bindns = std;

void increment(asio::detail::atomic_count* count)
{
  ++(*count);
}

void system_executor_query_test()
{
  ASIO_CHECK(
      &asio::query(system_executor(),
        asio::execution::context)
      != static_cast<const system_context*>(0));

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::blocking)
      == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::blocking.possibly)
      == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::outstanding_work)
      == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::outstanding_work.untracked)
      == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::relationship)
      == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::relationship.fork)
      == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::mapping)
      == asio::execution::mapping.thread);

  ASIO_CHECK(
      asio::query(system_executor(),
        asio::execution::allocator)
      == std::allocator<void>());
}

void system_executor_execute_test()
{
  asio::detail::atomic_count count(0);

  system_executor().execute(bindns::bind(increment, &count));

  asio::require(system_executor(),
      asio::execution::blocking.possibly
    ).execute(bindns::bind(increment, &count));

  asio::require(system_executor(),
      asio::execution::blocking.always
    ).execute(bindns::bind(increment, &count));

  asio::require(system_executor(),
      asio::execution::blocking.never
    ).execute(bindns::bind(increment, &count));

  asio::require(system_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked
    ).execute(bindns::bind(increment, &count));

  asio::require(system_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.fork
    ).execute(bindns::bind(increment, &count));

  asio::require(system_executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.continuation
    ).execute(bindns::bind(increment, &count));

  asio::prefer(
      asio::require(system_executor(),
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator(std::allocator<void>())
    ).execute(bindns::bind(increment, &count));

  asio::prefer(
      asio::require(system_executor(),
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator
    ).execute(bindns::bind(increment, &count));

  asio::query(system_executor(), execution::context).join();

  ASIO_CHECK(count == 9);
}

ASIO_TEST_SUITE
(
  "system_executor",
  ASIO_TEST_CASE(system_executor_query_test)
  ASIO_TEST_CASE(system_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\system_timer.cpp
//
// system_timer.cpp
// ~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Prevent link dependency on the Boost.System library.
#if !defined(BOOST_SYSTEM_NO_DEPRECATED)
#define BOOST_SYSTEM_NO_DEPRECATED
#endif // !defined(BOOST_SYSTEM_NO_DEPRECATED)

// Test that header file is self-contained.
#include "asio/system_timer.hpp"

#include <functional>
#include "asio/bind_cancellation_slot.hpp"
#include "asio/cancellation_signal.hpp"
#include "asio/executor_work_guard.hpp"
#include "asio/io_context.hpp"
#include "asio/thread.hpp"
#include "unit_test.hpp"

namespace bindns = std;

void increment(int* count)
{
  ++(*count);
}

void decrement_to_zero(asio::system_timer* t, int* count)
{
  if (*count > 0)
  {
    --(*count);

    int before_value = *count;

    t->expires_at(t->expiry() + asio::chrono::seconds(1));
    t->async_wait(bindns::bind(decrement_to_zero, t, count));

    // Completion cannot nest, so count value should remain unchanged.
    ASIO_CHECK(*count == before_value);
  }
}

void increment_if_not_cancelled(int* count,
    const asio::error_code& ec)
{
  if (!ec)
    ++(*count);
}

void cancel_timer(asio::system_timer* t)
{
  std::size_t num_cancelled = t->cancel();
  ASIO_CHECK(num_cancelled == 1);
}

void cancel_one_timer(asio::system_timer* t)
{
  std::size_t num_cancelled = t->cancel_one();
  ASIO_CHECK(num_cancelled == 1);
}

asio::system_timer::time_point now()
{
  return asio::system_timer::clock_type::now();
}

void system_timer_test()
{
  using asio::chrono::seconds;
  using asio::chrono::microseconds;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  const asio::io_context::executor_type ioc_ex = ioc.get_executor();
  int count = 0;

  asio::system_timer::time_point start = now();

  asio::system_timer t1(ioc, seconds(1));
  t1.wait();

  // The timer must block until after its expiry time.
  asio::system_timer::time_point end = now();
  asio::system_timer::time_point expected_end = start + seconds(1);
  ASIO_CHECK(expected_end < end || expected_end == end);

  start = now();

  asio::system_timer t2(ioc_ex, seconds(1) + microseconds(500000));
  t2.wait();

  // The timer must block until after its expiry time.
  end = now();
  expected_end = start + seconds(1) + microseconds(500000);
  ASIO_CHECK(expected_end < end || expected_end == end);

  t2.expires_at(t2.expiry() + seconds(1));
  t2.wait();

  // The timer must block until after its expiry time.
  end = now();
  expected_end += seconds(1);
  ASIO_CHECK(expected_end < end || expected_end == end);

  start = now();

  t2.expires_after(seconds(1) + microseconds(200000));
  t2.wait();

  // The timer must block until after its expiry time.
  end = now();
  expected_end = start + seconds(1) + microseconds(200000);
  ASIO_CHECK(expected_end < end || expected_end == end);

  start = now();

  asio::system_timer t3(ioc, seconds(5));
  t3.async_wait(bindns::bind(increment, &count));

  // No completions can be delivered until run() is called.
  ASIO_CHECK(count == 0);

  ioc.run();

  // The run() call will not return until all operations have finished, and
  // this should not be until after the timer's expiry time.
  ASIO_CHECK(count == 1);
  end = now();
  expected_end = start + seconds(1);
  ASIO_CHECK(expected_end < end || expected_end == end);

  count = 3;
  start = now();

  asio::system_timer t4(ioc, seconds(1));
  t4.async_wait(bindns::bind(decrement_to_zero, &t4, &count));

  // No completions can be delivered until run() is called.
  ASIO_CHECK(count == 3);

  ioc.restart();
  ioc.run();

  // The run() call will not return until all operations have finished, and
  // this should not be until after the timer's final expiry time.
  ASIO_CHECK(count == 0);
  end = now();
  expected_end = start + seconds(3);
  ASIO_CHECK(expected_end < end || expected_end == end);

  count = 0;
  start = now();

  asio::system_timer t5(ioc, seconds(10));
  t5.async_wait(bindns::bind(increment_if_not_cancelled, &count, _1));
  asio::system_timer t6(ioc, seconds(1));
  t6.async_wait(bindns::bind(cancel_timer, &t5));

  // No completions can be delivered until run() is called.
  ASIO_CHECK(count == 0);

  ioc.restart();
  ioc.run();

  // The timer should have been cancelled, so count should not have changed.
  // The total run time should not have been much more than 1 second (and
  // certainly far less than 10 seconds).
  ASIO_CHECK(count == 0);
  end = now();
  expected_end = start + seconds(2);
  ASIO_CHECK(end < expected_end);

  // Wait on the timer again without cancelling it. This time the asynchronous
  // wait should run to completion and increment the counter.
  t5.async_wait(bindns::bind(increment_if_not_cancelled, &count, _1));

  ioc.restart();
  ioc.run();

  // The timer should not have been cancelled, so count should have changed.
  // The total time since the timer was created should be more than 10 seconds.
  ASIO_CHECK(count == 1);
  end = now();
  expected_end = start + seconds(10);
  ASIO_CHECK(expected_end < end || expected_end == end);

  count = 0;
  start = now();

  // Start two waits on a timer, one of which will be cancelled. The one
  // which is not cancelled should still run to completion and increment the
  // counter.
  asio::system_timer t7(ioc, seconds(3));
  t7.async_wait(bindns::bind(increment_if_not_cancelled, &count, _1));
  t7.async_wait(bindns::bind(increment_if_not_cancelled, &count, _1));
  asio::system_timer t8(ioc, seconds(1));
  t8.async_wait(bindns::bind(cancel_one_timer, &t7));

  ioc.restart();
  ioc.run();

  // One of the waits should not have been cancelled, so count should have
  // changed. The total time since the timer was created should be more than 3
  // seconds.
  ASIO_CHECK(count == 1);
  end = now();
  expected_end = start + seconds(3);
  ASIO_CHECK(expected_end < end || expected_end == end);
}

struct timer_handler
{
  timer_handler() {}
  void operator()(const asio::error_code&) {}
  timer_handler(timer_handler&&) {}
private:
  timer_handler(const timer_handler&);
};

void system_timer_cancel_test()
{
  static asio::io_context io_context;
  struct timer
  {
    asio::system_timer t;
    timer() : t(io_context)
    {
      t.expires_at((asio::system_timer::time_point::max)());
    }
  } timers[50];

  timers[2].t.async_wait(timer_handler());
  timers[41].t.async_wait(timer_handler());
  for (int i = 10; i < 20; ++i)
    timers[i].t.async_wait(timer_handler());

  ASIO_CHECK(timers[2].t.cancel() == 1);
  ASIO_CHECK(timers[41].t.cancel() == 1);
  for (int i = 10; i < 20; ++i)
    ASIO_CHECK(timers[i].t.cancel() == 1);
}

struct custom_allocation_timer_handler
{
  custom_allocation_timer_handler(int* count) : count_(count) {}
  void operator()(const asio::error_code&) {}
  int* count_;

  template <typename T>
  struct allocator
  {
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    template <typename U>
    struct rebind
    {
      typedef allocator<U> other;
    };

    explicit allocator(int* count) noexcept
      : count_(count)
    {
    }

    allocator(const allocator& other) noexcept
      : count_(other.count_)
    {
    }

    template <typename U>
    allocator(const allocator<U>& other) noexcept
      : count_(other.count_)
    {
    }

    pointer allocate(size_type n, const void* = 0)
    {
      ++(*count_);
      return static_cast<T*>(::operator new(sizeof(T) * n));
    }

    void deallocate(pointer p, size_type)
    {
      --(*count_);
      ::operator delete(p);
    }

    size_type max_size() const
    {
      return ~size_type(0);
    }

    void construct(pointer p, const T& v)
    {
      new (p) T(v);
    }

    void destroy(pointer p)
    {
      p->~T();
    }

    int* count_;
  };

  typedef allocator<int> allocator_type;

  allocator_type get_allocator() const noexcept
  {
    return allocator_type(count_);
  }
};

void system_timer_custom_allocation_test()
{
  static asio::io_context io_context;
  struct timer
  {
    asio::system_timer t;
    timer() : t(io_context) {}
  } timers[100];

  int allocation_count = 0;

  for (int i = 0; i < 50; ++i)
  {
    timers[i].t.expires_at((asio::system_timer::time_point::max)());
    timers[i].t.async_wait(custom_allocation_timer_handler(&allocation_count));
  }

  for (int i = 50; i < 100; ++i)
  {
    timers[i].t.expires_at((asio::system_timer::time_point::min)());
    timers[i].t.async_wait(custom_allocation_timer_handler(&allocation_count));
  }

  for (int i = 0; i < 50; ++i)
    timers[i].t.cancel();

  io_context.run();

  ASIO_CHECK(allocation_count == 0);
}

void io_context_run(asio::io_context* ioc)
{
  ioc->run();
}

void system_timer_thread_test()
{
  asio::io_context ioc;
  asio::executor_work_guard<asio::io_context::executor_type> work
    = asio::make_work_guard(ioc);
  asio::system_timer t1(ioc);
  asio::system_timer t2(ioc);
  int count = 0;

  asio::thread th(bindns::bind(io_context_run, &ioc));

  t2.expires_after(asio::chrono::seconds(2));
  t2.wait();

  t1.expires_after(asio::chrono::seconds(2));
  t1.async_wait(bindns::bind(increment, &count));

  t2.expires_after(asio::chrono::seconds(4));
  t2.wait();

  ioc.stop();
  th.join();

  ASIO_CHECK(count == 1);
}

asio::system_timer make_timer(asio::io_context& ioc, int* count)
{
  asio::system_timer t(ioc);
  t.expires_after(asio::chrono::seconds(1));
  t.async_wait(bindns::bind(increment, count));
  return t;
}

typedef asio::basic_waitable_timer<
    asio::system_timer::clock_type,
    asio::system_timer::traits_type,
    asio::io_context::executor_type> io_context_system_timer;

io_context_system_timer make_convertible_timer(asio::io_context& ioc, int* count)
{
  io_context_system_timer t(ioc);
  t.expires_after(asio::chrono::seconds(1));
  t.async_wait(bindns::bind(increment, count));
  return t;
}

void system_timer_move_test()
{
  asio::io_context io_context1;
  asio::io_context io_context2;
  int count = 0;

  asio::system_timer t1 = make_timer(io_context1, &count);
  asio::system_timer t2 = make_timer(io_context2, &count);
  asio::system_timer t3 = std::move(t1);

  t2 = std::move(t1);

  io_context2.run();

  ASIO_CHECK(count == 1);

  io_context1.run();

  ASIO_CHECK(count == 2);

  asio::system_timer t4 = make_convertible_timer(io_context1, &count);
  asio::system_timer t5 = make_convertible_timer(io_context2, &count);
  asio::system_timer t6 = std::move(t4);

  t2 = std::move(t4);

  io_context2.restart();
  io_context2.run();

  ASIO_CHECK(count == 3);

  io_context1.restart();
  io_context1.run();

  ASIO_CHECK(count == 4);
}

void system_timer_op_cancel_test()
{
  asio::cancellation_signal cancel_signal;
  asio::io_context ioc;
  int count = 0;

  asio::system_timer timer(ioc, asio::chrono::seconds(10));

  timer.async_wait(bindns::bind(increment, &count));

  timer.async_wait(
      asio::bind_cancellation_slot(
        cancel_signal.slot(),
        bindns::bind(increment, &count)));

  timer.async_wait(bindns::bind(increment, &count));

  ioc.poll();

  ASIO_CHECK(count == 0);
  ASIO_CHECK(!ioc.stopped());

  cancel_signal.emit(asio::cancellation_type::all);

  ioc.run_one();
  ioc.poll();

  ASIO_CHECK(count == 1);
  ASIO_CHECK(!ioc.stopped());

  timer.cancel();

  ioc.run();

  ASIO_CHECK(count == 3);
  ASIO_CHECK(ioc.stopped());
}

ASIO_TEST_SUITE
(
  "system_timer",
  ASIO_TEST_CASE(system_timer_test)
  ASIO_TEST_CASE(system_timer_cancel_test)
  ASIO_TEST_CASE(system_timer_custom_allocation_test)
  ASIO_TEST_CASE(system_timer_thread_test)
  ASIO_TEST_CASE(system_timer_move_test)
  ASIO_TEST_CASE(system_timer_op_cancel_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\this_coro.cpp
//
// this_coro.cpp
// ~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/this_coro.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "this_coro",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\thread_pool.cpp
//
// thread_pool.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/thread_pool.hpp"

#include <functional>
#include "asio/dispatch.hpp"
#include "asio/post.hpp"
#include "unit_test.hpp"

using namespace asio;
namespace bindns = std;

void increment(int* count)
{
  ++(*count);
}

void decrement_to_zero(thread_pool* pool, int* count)
{
  if (*count > 0)
  {
    --(*count);

    int before_value = *count;
    asio::post(*pool, bindns::bind(decrement_to_zero, pool, count));

    // Handler execution cannot nest, so count value should remain unchanged.
    ASIO_CHECK(*count == before_value);
  }
}

void nested_decrement_to_zero(thread_pool* pool, int* count)
{
  if (*count > 0)
  {
    --(*count);

    asio::dispatch(*pool,
        bindns::bind(nested_decrement_to_zero, pool, count));

    // Handler execution is nested, so count value should now be zero.
    ASIO_CHECK(*count == 0);
  }
}

void thread_pool_test()
{
  thread_pool pool(1);

  int count1 = 0;
  asio::post(pool, bindns::bind(increment, &count1));

  int count2 = 10;
  asio::post(pool, bindns::bind(decrement_to_zero, &pool, &count2));

  int count3 = 10;
  asio::post(pool, bindns::bind(nested_decrement_to_zero, &pool, &count3));

  pool.wait();

  ASIO_CHECK(count1 == 1);
  ASIO_CHECK(count2 == 0);
  ASIO_CHECK(count3 == 0);
}

class test_service : public asio::execution_context::service
{
public:
#if defined(ASIO_NO_TYPEID)
  static asio::execution_context::id id;
#endif // defined(ASIO_NO_TYPEID)

  typedef test_service key_type;

  test_service(asio::execution_context& ctx)
    : asio::execution_context::service(ctx)
  {
  }

private:
  virtual void shutdown() {}
};

#if defined(ASIO_NO_TYPEID)
asio::execution_context::id test_service::id;
#endif // defined(ASIO_NO_TYPEID)

void thread_pool_service_test()
{
  asio::thread_pool pool1(1);
  asio::thread_pool pool2(1);
  asio::thread_pool pool3(1);

  // Implicit service registration.

  asio::use_service<test_service>(pool1);

  ASIO_CHECK(asio::has_service<test_service>(pool1));

  test_service* svc1 = new test_service(pool1);
  try
  {
    asio::add_service(pool1, svc1);
    ASIO_ERROR("add_service did not throw");
  }
  catch (asio::service_already_exists&)
  {
  }
  delete svc1;

  // Explicit service registration.

  test_service& svc2 = asio::make_service<test_service>(pool2);

  ASIO_CHECK(asio::has_service<test_service>(pool2));
  ASIO_CHECK(&asio::use_service<test_service>(pool2) == &svc2);

  test_service* svc3 = new test_service(pool2);
  try
  {
    asio::add_service(pool2, svc3);
    ASIO_ERROR("add_service did not throw");
  }
  catch (asio::service_already_exists&)
  {
  }
  delete svc3;

  // Explicit registration with invalid owner.

  test_service* svc4 = new test_service(pool2);
  try
  {
    asio::add_service(pool3, svc4);
    ASIO_ERROR("add_service did not throw");
  }
  catch (asio::invalid_service_owner&)
  {
  }
  delete svc4;

  ASIO_CHECK(!asio::has_service<test_service>(pool3));
}

void thread_pool_executor_query_test()
{
  thread_pool pool(1);

  ASIO_CHECK(
      &asio::query(pool.executor(),
        asio::execution::context)
      == &pool);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::blocking)
      == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::blocking.possibly)
      == asio::execution::blocking.possibly);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::outstanding_work)
      == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::outstanding_work.untracked)
      == asio::execution::outstanding_work.untracked);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::relationship)
      == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::relationship.fork)
      == asio::execution::relationship.fork);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::mapping)
      == asio::execution::mapping.thread);

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::allocator)
      == std::allocator<void>());

  ASIO_CHECK(
      asio::query(pool.executor(),
        asio::execution::occupancy)
      == 1);
}

void thread_pool_executor_execute_test()
{
  int count = 0;
  thread_pool pool(1);

  pool.executor().execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.possibly
    ).execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.always
    ).execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.never
    ).execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.tracked
    ).execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked
    ).execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.fork
    ).execute(bindns::bind(increment, &count));

  asio::require(pool.executor(),
      asio::execution::blocking.never,
      asio::execution::outstanding_work.untracked,
      asio::execution::relationship.continuation
    ).execute(bindns::bind(increment, &count));

  asio::prefer(
      asio::require(pool.executor(),
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator(std::allocator<void>())
    ).execute(bindns::bind(increment, &count));

  asio::prefer(
      asio::require(pool.executor(),
        asio::execution::blocking.never,
        asio::execution::outstanding_work.untracked,
        asio::execution::relationship.continuation),
      asio::execution::allocator
    ).execute(bindns::bind(increment, &count));

  pool.wait();

  ASIO_CHECK(count == 10);
}

ASIO_TEST_SUITE
(
  "thread_pool",
  ASIO_TEST_CASE(thread_pool_test)
  ASIO_TEST_CASE(thread_pool_service_test)
  ASIO_TEST_CASE(thread_pool_executor_query_test)
  ASIO_TEST_CASE(thread_pool_executor_execute_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\thread.cpp
//
// thread.cpp
// ~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/thread.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "thread",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\time_traits.cpp
//
// time_traits.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/time_traits.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "time_traits",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\use_awaitable.cpp
//
// use_awaitable.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/use_awaitable.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "use_awaitable",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\use_future.cpp
//
// use_future.cpp
// ~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/use_future.hpp"

#include <string>
#include "unit_test.hpp"

#if defined(ASIO_HAS_STD_FUTURE_CLASS)

#include "archetypes/async_ops.hpp"

void use_future_0_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<void> f;

  f = async_op_0(use_future);
  try
  {
    f.get();
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_0(true, use_future);
  try
  {
    f.get();
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_0(false, use_future);
  try
  {
    f.get();
    ASIO_CHECK(false);
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::operation_aborted);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_0(true, use_future);
  try
  {
    f.get();
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_0(false, use_future);
  try
  {
    f.get();
    ASIO_CHECK(false);
  }
  catch (std::exception& e)
  {
    ASIO_CHECK(e.what() == std::string("blah"));
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

void use_future_1_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<int> f;

  f = async_op_1(use_future);
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_1(true, use_future);
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_1(false, use_future);
  try
  {
    int i = f.get();
    ASIO_CHECK(false);
    (void)i;
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::operation_aborted);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_1(true, use_future);
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_1(false, use_future);
  try
  {
    int i = f.get();
    ASIO_CHECK(false);
    (void)i;
  }
  catch (std::exception& e)
  {
    ASIO_CHECK(e.what() == std::string("blah"));
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

void use_future_2_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<std::tuple<int, double>> f;

  f = async_op_2(use_future);
  try
  {
    int i;
    double d;
    std::tie(i, d) = f.get();
    ASIO_CHECK(i == 42);
    ASIO_CHECK(d == 2.0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_2(true, use_future);
  try
  {
    int i;
    double d;
    std::tie(i, d) = f.get();
    ASIO_CHECK(i == 42);
    ASIO_CHECK(d == 2.0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_2(false, use_future);
  try
  {
    std::tuple<int, double> t = f.get();
    ASIO_CHECK(false);
    (void)t;
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::operation_aborted);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_2(true, use_future);
  try
  {
    int i;
    double d;
    std::tie(i, d) = f.get();
    ASIO_CHECK(i == 42);
    ASIO_CHECK(d == 2.0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_2(false, use_future);
  try
  {
    std::tuple<int, double> t = f.get();
    ASIO_CHECK(false);
    (void)t;
  }
  catch (std::exception& e)
  {
    ASIO_CHECK(e.what() == std::string("blah"));
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

void use_future_3_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<std::tuple<int, double, char>> f;

  f = async_op_3(use_future);
  try
  {
    int i;
    double d;
    char c;
    std::tie(i, d, c) = f.get();
    ASIO_CHECK(i == 42);
    ASIO_CHECK(d == 2.0);
    ASIO_CHECK(c == 'a');
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_3(true, use_future);
  try
  {
    int i;
    double d;
    char c;
    std::tie(i, d, c) = f.get();
    ASIO_CHECK(i == 42);
    ASIO_CHECK(d == 2.0);
    ASIO_CHECK(c == 'a');
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_3(false, use_future);
  try
  {
    std::tuple<int, double, char> t = f.get();
    ASIO_CHECK(false);
    (void)t;
  }
  catch (asio::system_error& e)
  {
    ASIO_CHECK(e.code() == asio::error::operation_aborted);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_3(true, use_future);
  try
  {
    int i;
    double d;
    char c;
    std::tie(i, d, c) = f.get();
    ASIO_CHECK(i == 42);
    ASIO_CHECK(d == 2.0);
    ASIO_CHECK(c == 'a');
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_3(false, use_future);
  try
  {
    std::tuple<int, double, char> t = f.get();
    ASIO_CHECK(false);
    (void)t;
  }
  catch (std::exception& e)
  {
    ASIO_CHECK(e.what() == std::string("blah"));
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

int package_0()
{
  return 42;
}

int package_ec_0(asio::error_code ec)
{
  return ec ? 0 : 42;
}

int package_ex_0(std::exception_ptr ex)
{
  return ex ? 0 : 42;
}

void use_future_package_0_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<int> f;

  f = async_op_0(use_future(package_0));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_0(true, use_future(&package_ec_0));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_0(false, use_future(package_ec_0));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_0(true, use_future(package_ex_0));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_0(false, use_future(package_ex_0));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

int package_1(int i)
{
  return i;
}

int package_ec_1(asio::error_code ec, int i)
{
  return ec ? 0 : i;
}

int package_ex_1(std::exception_ptr ex, int i)
{
  return ex ? 0 : i;
}

void use_future_package_1_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<int> f;

  f = async_op_1(use_future(package_1));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_1(true, use_future(package_ec_1));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_1(false, use_future(package_ec_1));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_1(true, use_future(package_ex_1));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_1(false, use_future(package_ex_1));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

int package_2(int i, double)
{
  return i;
}

int package_ec_2(asio::error_code ec, int i, double)
{
  return ec ? 0 : i;
}

int package_ex_2(std::exception_ptr ex, int i, double)
{
  return ex ? 0 : i;
}

void use_future_package_2_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<int> f;

  f = async_op_2(use_future(package_2));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_2(true, use_future(package_ec_2));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_2(false, use_future(package_ec_2));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_2(true, use_future(package_ex_2));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_2(false, use_future(package_ex_2));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

int package_3(int i, double, char)
{
  return i;
}

int package_ec_3(asio::error_code ec, int i, double, char)
{
  return ec ? 0 : i;
}

int package_ex_3(std::exception_ptr ex, int i, double, char)
{
  return ex ? 0 : i;
}

void use_future_package_3_test()
{
  using asio::use_future;
  using namespace archetypes;

  std::future<int> f;

  f = async_op_3(use_future(package_3));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_3(true, use_future(package_ec_3));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ec_3(false, use_future(package_ec_3));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_3(true, use_future(package_ex_3));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 42);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }

  f = async_op_ex_3(false, use_future(package_ex_3));
  try
  {
    int i = f.get();
    ASIO_CHECK(i == 0);
  }
  catch (...)
  {
    ASIO_CHECK(false);
  }
}

ASIO_TEST_SUITE
(
  "use_future",
  ASIO_TEST_CASE(use_future_0_test)
  ASIO_TEST_CASE(use_future_1_test)
  ASIO_TEST_CASE(use_future_2_test)
  ASIO_TEST_CASE(use_future_3_test)
  ASIO_TEST_CASE(use_future_package_0_test)
  ASIO_TEST_CASE(use_future_package_1_test)
  ASIO_TEST_CASE(use_future_package_2_test)
  ASIO_TEST_CASE(use_future_package_3_test)
)

#else // defined(ASIO_HAS_STD_FUTURE_CLASS)

ASIO_TEST_SUITE
(
  "use_future",
  ASIO_TEST_CASE(null_test)
)

#endif // defined(ASIO_HAS_STD_FUTURE_CLASS)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\uses_executor.cpp
//
// uses_executor.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/uses_executor.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "uses_executor",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\wait_traits.cpp
//
// wait_traits.cpp
// ~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/wait_traits.hpp"

#include "unit_test.hpp"

ASIO_TEST_SUITE
(
  "wait_traits",
  ASIO_TEST_CASE(null_test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\writable_pipe.cpp
//
// writable_pipe.cpp
// ~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header pipe is self-contained.
#include "asio/writable_pipe.hpp"

#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "unit_test.hpp"

// writable_pipe_compile test
// ~~~~~~~~~~~~~~~~~~~~~~~~~~
// The following test checks that all public member functions on the class
// writable_pipe compile and link correctly. Runtime failures are ignored.

namespace writable_pipe_compile {

struct write_some_handler
{
  write_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  write_some_handler(write_some_handler&&) {}
private:
  write_some_handler(const write_some_handler&);
};

struct read_some_handler
{
  read_some_handler() {}
  void operator()(const asio::error_code&, std::size_t) {}
  read_some_handler(read_some_handler&&) {}
private:
  read_some_handler(const read_some_handler&);
};

void test()
{
#if defined(ASIO_HAS_PIPE)
  using namespace asio;

  try
  {
    io_context ioc;
    const io_context::executor_type ioc_ex = ioc.get_executor();
    char mutable_char_buffer[128] = "";
    const char const_char_buffer[128] = "";
    archetypes::lazy_handler lazy;
    asio::error_code ec;

    // basic_writable_pipe constructors.

    writable_pipe pipe1(ioc);
    writable_pipe::native_handle_type native_pipe1 = pipe1.native_handle();
    writable_pipe pipe2(ioc, native_pipe1);

    writable_pipe pipe3(ioc_ex);
    writable_pipe::native_handle_type native_pipe2 = pipe1.native_handle();
    writable_pipe pipe4(ioc_ex, native_pipe2);

    writable_pipe pipe5(std::move(pipe4));

    basic_writable_pipe<io_context::executor_type> pipe6(ioc);
    writable_pipe pipe7(std::move(pipe6));

    // basic_writable_pipe operators.

    pipe1 = writable_pipe(ioc);
    pipe1 = std::move(pipe2);
    pipe1 = std::move(pipe6);

    // basic_io_object functions.

    writable_pipe::executor_type ex = pipe1.get_executor();
    (void)ex;

    // basic_writable_pipe functions.

    writable_pipe::native_handle_type native_pipe3 = pipe1.native_handle();
    pipe1.assign(native_pipe3);
    writable_pipe::native_handle_type native_pipe4 = pipe1.native_handle();
    pipe1.assign(native_pipe4, ec);

    bool is_open = pipe1.is_open();
    (void)is_open;

    pipe1.close();
    pipe1.close(ec);

    writable_pipe::native_handle_type native_pipe5 = pipe1.release();
    (void)native_pipe5;
    writable_pipe::native_handle_type native_pipe6 = pipe1.release(ec);
    (void)native_pipe6;

    writable_pipe::native_handle_type native_pipe7 = pipe1.native_handle();
    (void)native_pipe7;

    pipe1.cancel();
    pipe1.cancel(ec);

    pipe1.write_some(buffer(mutable_char_buffer));
    pipe1.write_some(buffer(const_char_buffer));
    pipe1.write_some(buffer(mutable_char_buffer), ec);
    pipe1.write_some(buffer(const_char_buffer), ec);

    pipe1.async_write_some(buffer(mutable_char_buffer), write_some_handler());
    pipe1.async_write_some(buffer(const_char_buffer), write_some_handler());
    int i1 = pipe1.async_write_some(buffer(mutable_char_buffer), lazy);
    (void)i1;
    int i2 = pipe1.async_write_some(buffer(const_char_buffer), lazy);
    (void)i2;
  }
  catch (std::exception&)
  {
  }
#endif // defined(ASIO_HAS_PIPE)
}

} // namespace writable_pipe_compile

ASIO_TEST_SUITE
(
  "writable_pipe",
  ASIO_COMPILE_TEST_CASE(writable_pipe_compile::test)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\write_at.cpp
//
// write_at.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/write_at.hpp"

#include <array>
#include <cstring>
#include <functional>
#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/streambuf.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
#include <boost/array.hpp>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

using namespace std; // For memcmp, memcpy and memset.

class test_random_access_device
{
public:
  typedef asio::io_context::executor_type executor_type;

  test_random_access_device(asio::io_context& io_context)
    : io_context_(io_context),
      length_(max_length),
      next_write_length_(max_length)
  {
    memset(data_, 0, max_length);
  }

  executor_type get_executor() noexcept
  {
    return io_context_.get_executor();
  }

  void reset()
  {
    memset(data_, 0, max_length);
    next_write_length_ = max_length;
  }

  void next_write_length(size_t length)
  {
    next_write_length_ = length;
  }

  template <typename Iterator>
  bool check_buffers(asio::uint64_t offset,
      Iterator begin, Iterator end, size_t length)
  {
    if (offset + length > max_length)
      return false;

    Iterator iter = begin;
    size_t checked_length = 0;
    for (; iter != end && checked_length < length; ++iter)
    {
      size_t buffer_length = asio::buffer_size(*iter);
      if (buffer_length > length - checked_length)
        buffer_length = length - checked_length;
      if (memcmp(data_ + offset + checked_length,
            iter->data(), buffer_length) != 0)
        return false;
      checked_length += buffer_length;
    }

    return true;
  }

  template <typename Const_Buffers>
  bool check_buffers(asio::uint64_t offset,
      const Const_Buffers& buffers, size_t length)
  {
    return check_buffers(offset, asio::buffer_sequence_begin(buffers),
        asio::buffer_sequence_end(buffers), length);
  }

  template <typename Const_Buffers>
  size_t write_some_at(asio::uint64_t offset,
      const Const_Buffers& buffers)
  {
    return asio::buffer_copy(
        asio::buffer(data_, length_) + offset,
        buffers, next_write_length_);
  }

  template <typename Const_Buffers>
  size_t write_some_at(asio::uint64_t offset,
      const Const_Buffers& buffers, asio::error_code& ec)
  {
    ec = asio::error_code();
    return write_some_at(offset, buffers);
  }

  template <typename Const_Buffers, typename Handler>
  void async_write_some_at(asio::uint64_t offset,
      const Const_Buffers& buffers, Handler&& handler)
  {
    size_t bytes_transferred = write_some_at(offset, buffers);
    asio::post(get_executor(),
        asio::detail::bind_handler(
          static_cast<Handler&&>(handler),
          asio::error_code(), bytes_transferred));
  }

private:
  asio::io_context& io_context_;
  enum { max_length = 8192 };
  char data_[max_length];
  size_t length_;
  size_t next_write_length_;
};

static const char write_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
static char mutable_write_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void test_3_arg_const_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  size_t bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
}

void test_3_arg_mutable_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  size_t bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
}

void test_3_arg_vector_buffers_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data) + 32);

  s.reset();
  size_t bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
}

void test_4_arg_nothrow_const_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_nothrow_mutable_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_nothrow_vector_buffers_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data) + 32);

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

bool old_style_transfer_all(const asio::error_code& ec,
    size_t /*bytes_transferred*/)
{
  return !!ec;
}

struct short_transfer
{
  short_transfer() {}
  short_transfer(short_transfer&&) {}
  size_t operator()(const asio::error_code& ec,
      size_t /*bytes_transferred*/)
  {
    return !!ec ? 0 : 3;
  }
};

void test_4_arg_const_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  size_t bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
}

void test_4_arg_mutable_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  size_t bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
}

void test_4_arg_vector_buffers_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data) + 32);

  s.reset();
  size_t bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 0, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write_at(s, 1234, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
}

void test_5_arg_const_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void test_5_arg_mutable_buffer_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);
}

void test_5_arg_vector_buffers_write_at()
{
  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data) + 32);

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 0, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write_at(s, 1234, buffers,
      short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void async_write_handler(const asio::error_code& e,
    size_t bytes_transferred, size_t expected_bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!e);
  ASIO_CHECK(bytes_transferred == expected_bytes_transferred);
}

void test_4_arg_const_buffer_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_4_arg_mutable_buffer_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_4_arg_boost_array_buffers_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_random_access_device s(ioc);
  boost::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_4_arg_std_array_buffers_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_4_arg_vector_buffers_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data) + 32);

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_4_arg_streambuf_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb;
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  bool called = false;
  asio::async_write_at(s, 0, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  int i = asio::async_write_at(s, 0, sb,
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_5_arg_const_buffer_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_5_arg_mutable_buffer_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(mutable_write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_5_arg_boost_array_buffers_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_random_access_device s(ioc);
  boost::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_5_arg_std_array_buffers_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_5_arg_vector_buffers_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data) + 32);

  s.reset();
  bool called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write_at(s, 0, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

void test_5_arg_streambuf_async_write_at()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_random_access_device s(ioc);
  asio::streambuf sb;
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  bool called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 50));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 50));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb,
      asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 0, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write_at(s, 1234, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 0, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write_at(s, 1234, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 0, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write_at(s, 1234, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(1234, buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  int i = asio::async_write_at(s, 0, sb, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(0, buffers, sizeof(write_data)));
}

ASIO_TEST_SUITE
(
  "write_at",
  ASIO_TEST_CASE(test_3_arg_const_buffer_write_at)
  ASIO_TEST_CASE(test_3_arg_mutable_buffer_write_at)
  ASIO_TEST_CASE(test_3_arg_vector_buffers_write_at)
  ASIO_TEST_CASE(test_4_arg_nothrow_const_buffer_write_at)
  ASIO_TEST_CASE(test_4_arg_nothrow_mutable_buffer_write_at)
  ASIO_TEST_CASE(test_4_arg_nothrow_vector_buffers_write_at)
  ASIO_TEST_CASE(test_4_arg_const_buffer_write_at)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_write_at)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_write_at)
  ASIO_TEST_CASE(test_5_arg_const_buffer_write_at)
  ASIO_TEST_CASE(test_5_arg_mutable_buffer_write_at)
  ASIO_TEST_CASE(test_5_arg_vector_buffers_write_at)
  ASIO_TEST_CASE(test_4_arg_const_buffer_async_write_at)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_async_write_at)
  ASIO_TEST_CASE(test_4_arg_boost_array_buffers_async_write_at)
  ASIO_TEST_CASE(test_4_arg_std_array_buffers_async_write_at)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_async_write_at)
  ASIO_TEST_CASE(test_4_arg_streambuf_async_write_at)
  ASIO_TEST_CASE(test_5_arg_const_buffer_async_write_at)
  ASIO_TEST_CASE(test_5_arg_mutable_buffer_async_write_at)
  ASIO_TEST_CASE(test_5_arg_boost_array_buffers_async_write_at)
  ASIO_TEST_CASE(test_5_arg_std_array_buffers_async_write_at)
  ASIO_TEST_CASE(test_5_arg_vector_buffers_async_write_at)
  ASIO_TEST_CASE(test_5_arg_streambuf_async_write_at)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\tests\unit\write.cpp
//
// write.cpp
// ~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

// Disable autolinking for unit tests.
#if !defined(BOOST_ALL_NO_LIB)
#define BOOST_ALL_NO_LIB 1
#endif // !defined(BOOST_ALL_NO_LIB)

// Test that header file is self-contained.
#include "asio/write.hpp"

#include <array>
#include <cstring>
#include <functional>
#include <vector>
#include "archetypes/async_result.hpp"
#include "asio/io_context.hpp"
#include "asio/post.hpp"
#include "asio/streambuf.hpp"
#include "unit_test.hpp"

#if defined(ASIO_HAS_BOOST_ARRAY)
#include <boost/array.hpp>
#endif // defined(ASIO_HAS_BOOST_ARRAY)

using namespace std; // For memcmp, memcpy and memset.

class test_stream
{
public:
  typedef asio::io_context::executor_type executor_type;

  test_stream(asio::io_context& io_context)
    : io_context_(io_context),
      length_(max_length),
      position_(0),
      next_write_length_(max_length)
  {
    memset(data_, 0, max_length);
  }

  executor_type get_executor() noexcept
  {
    return io_context_.get_executor();
  }

  void reset(size_t length = max_length)
  {
    ASIO_CHECK(length <= max_length);

    memset(data_, 0, max_length);
    length_ = length;
    position_ = 0;
    next_write_length_ = length;
  }

  void next_write_length(size_t length)
  {
    next_write_length_ = length;
  }

  template <typename Iterator>
  bool check_buffers(Iterator begin, Iterator end, size_t length)
  {
    if (length != position_)
      return false;

    Iterator iter = begin;
    size_t checked_length = 0;
    for (; iter != end && checked_length < length; ++iter)
    {
      size_t buffer_length = asio::buffer_size(*iter);
      if (buffer_length > length - checked_length)
        buffer_length = length - checked_length;
      if (memcmp(data_ + checked_length, iter->data(), buffer_length) != 0)
        return false;
      checked_length += buffer_length;
    }

    return true;
  }

  template <typename Const_Buffers>
  bool check_buffers(const Const_Buffers& buffers, size_t length)
  {
    return check_buffers(asio::buffer_sequence_begin(buffers),
        asio::buffer_sequence_end(buffers), length);
  }

  template <typename Const_Buffers>
  size_t write_some(const Const_Buffers& buffers)
  {
    size_t n = asio::buffer_copy(
        asio::buffer(data_, length_) + position_,
        buffers, next_write_length_);
    position_ += n;
    return n;
  }

  template <typename Const_Buffers>
  size_t write_some(const Const_Buffers& buffers, asio::error_code& ec)
  {
    ec = asio::error_code();
    return write_some(buffers);
  }

  template <typename Const_Buffers, typename Handler>
  void async_write_some(const Const_Buffers& buffers,
      Handler&& handler)
  {
    size_t bytes_transferred = write_some(buffers);
    asio::post(get_executor(),
        asio::detail::bind_handler(
          static_cast<Handler&&>(handler),
          asio::error_code(), bytes_transferred));
  }

private:
  asio::io_context& io_context_;
  enum { max_length = 8192 };
  char data_[max_length];
  size_t length_;
  size_t position_;
  size_t next_write_length_;
};

static const char write_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
static char mutable_write_data[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void test_2_arg_zero_buffers_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;

  size_t bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == 0);
}

void test_2_arg_const_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  size_t bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_2_arg_mutable_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  size_t bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
}

void test_2_arg_vector_buffers_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data, 39) + 32);
  buffers.push_back(asio::buffer(write_data) + 39);

  s.reset();
  size_t bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_2_arg_dynamic_string_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(write_data));
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  size_t bytes_transferred = asio::write(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_nothrow_zero_buffers_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;

  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == 0);
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_const_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_mutable_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_vector_buffers_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data, 39) + 32);
  buffers.push_back(asio::buffer(write_data) + 39);

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void test_3_arg_nothrow_dynamic_string_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(write_data));
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

bool old_style_transfer_all(const asio::error_code& ec,
    size_t /*bytes_transferred*/)
{
  return !!ec;
}

struct short_transfer
{
  short_transfer() {}
  short_transfer(short_transfer&&) {}
  size_t operator()(const asio::error_code& ec,
      size_t /*bytes_transferred*/)
  {
    return !!ec ? 0 : 3;
  }
};

void test_3_arg_const_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  size_t bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_mutable_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  size_t bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
}

void test_3_arg_vector_buffers_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data, 39) + 32);
  buffers.push_back(asio::buffer(write_data) + 39);

  s.reset();
  size_t bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  bytes_transferred = asio::write(s, buffers, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_dynamic_string_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(write_data));
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  size_t bytes_transferred = asio::write(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_all());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(1));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(42));
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(1));
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(10));
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(42));
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb, old_style_transfer_all);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  bytes_transferred = asio::write(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  bytes_transferred = asio::write(s, sb, short_transfer());
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_4_arg_const_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_mutable_buffer_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(mutable_write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_vector_buffers_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data, 39) + 32);
  buffers.push_back(asio::buffer(write_data) + 39);

  s.reset();
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, buffers, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void test_4_arg_dynamic_string_write()
{
  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(write_data));
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  asio::error_code error;
  size_t bytes_transferred = asio::write(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_all(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(1), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_at_least(42), error);
  ASIO_CHECK(bytes_transferred == 50);
  ASIO_CHECK(s.check_buffers(buffers, 50));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(1), error);
  ASIO_CHECK(bytes_transferred == 1);
  ASIO_CHECK(s.check_buffers(buffers, 1));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(10), error);
  ASIO_CHECK(bytes_transferred == 10);
  ASIO_CHECK(s.check_buffers(buffers, 10));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      asio::transfer_exactly(42), error);
  ASIO_CHECK(bytes_transferred == 42);
  ASIO_CHECK(s.check_buffers(buffers, 42));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb,
      old_style_transfer_all, error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bytes_transferred = asio::write(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  error = asio::error_code();
  bytes_transferred = asio::write(s, sb, short_transfer(), error);
  ASIO_CHECK(bytes_transferred == sizeof(write_data));
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
  ASIO_CHECK(!error);
}

void async_write_handler(const asio::error_code& e,
    size_t bytes_transferred, size_t expected_bytes_transferred, bool* called)
{
  *called = true;
  ASIO_CHECK(!e);
  ASIO_CHECK(bytes_transferred == expected_bytes_transferred);
}

void test_3_arg_const_buffer_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  bool called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_mutable_buffer_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  bool called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));
}

void test_3_arg_boost_array_buffers_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_stream s(ioc);
  boost::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_3_arg_std_array_buffers_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_vector_buffers_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data, 39) + 32);
  buffers.push_back(asio::buffer(write_data) + 39);

  s.reset();
  bool called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_dynamic_string_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(write_data));
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bool called = false;
  asio::async_write(s, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  int i = asio::async_write(s, sb, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_3_arg_streambuf_async_write()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb;
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  bool called = false;
  asio::async_write(s, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  int i = asio::async_write(s, sb, archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

void test_4_arg_const_buffer_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  bool called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_4_arg_mutable_buffer_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::mutable_buffer buffers
    = asio::buffer(mutable_write_data, sizeof(mutable_write_data));

  s.reset();
  bool called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(mutable_write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(mutable_write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_4_arg_boost_array_buffers_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

#if defined(ASIO_HAS_BOOST_ARRAY)
  asio::io_context ioc;
  test_stream s(ioc);
  boost::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
#endif // defined(ASIO_HAS_BOOST_ARRAY)
}

void test_4_arg_std_array_buffers_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::array<asio::const_buffer, 2> buffers = { {
    asio::buffer(write_data, 32),
    asio::buffer(write_data) + 32 } };

  s.reset();
  bool called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_4_arg_vector_buffers_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::vector<asio::const_buffer> buffers;
  buffers.push_back(asio::buffer(write_data, 32));
  buffers.push_back(asio::buffer(write_data, 39) + 32);
  buffers.push_back(asio::buffer(write_data) + 39);

  s.reset();
  bool called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(1);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  s.next_write_length(10);
  called = false;
  asio::async_write(s, buffers, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  int i = asio::async_write(s, buffers, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_4_arg_dynamic_string_async_write()
{
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  std::string data;
  asio::dynamic_string_buffer<char, std::string::traits_type,
    std::string::allocator_type> sb
      = asio::dynamic_buffer(data, sizeof(write_data));
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  bool called = false;
  asio::async_write(s, sb, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  data.assign(write_data, sizeof(write_data));
  int i = asio::async_write(s, sb, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
}

void test_4_arg_streambuf_async_write()
{
#if !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
  namespace bindns = std;
  using bindns::placeholders::_1;
  using bindns::placeholders::_2;

  asio::io_context ioc;
  test_stream s(ioc);
  asio::streambuf sb;
  asio::const_buffer buffers
    = asio::buffer(write_data, sizeof(write_data));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  bool called = false;
  asio::async_write(s, sb, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_all(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(1),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_at_least(42),
      bindns::bind(async_write_handler,
        _1, _2, 50, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 50));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(1),
      bindns::bind(async_write_handler,
        _1, _2, 1, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 1));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(10),
      bindns::bind(async_write_handler,
        _1, _2, 10, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 10));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, asio::transfer_exactly(42),
      bindns::bind(async_write_handler,
        _1, _2, 42, &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, 42));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, old_style_transfer_all,
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  called = false;
  asio::async_write(s, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(1);
  called = false;
  asio::async_write(s, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  s.next_write_length(10);
  called = false;
  asio::async_write(s, sb, short_transfer(),
      bindns::bind(async_write_handler,
        _1, _2, sizeof(write_data), &called));
  ioc.restart();
  ioc.run();
  ASIO_CHECK(called);
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));

  s.reset();
  sb.consume(sb.size());
  sb.sputn(write_data, sizeof(write_data));
  int i = asio::async_write(s, sb, short_transfer(),
      archetypes::lazy_handler());
  ASIO_CHECK(i == 42);
  ioc.restart();
  ioc.run();
  ASIO_CHECK(s.check_buffers(buffers, sizeof(write_data)));
#endif // !defined(ASIO_NO_DYNAMIC_BUFFER_V1)
}

ASIO_TEST_SUITE
(
  "write",
  ASIO_TEST_CASE(test_2_arg_zero_buffers_write)
  ASIO_TEST_CASE(test_2_arg_const_buffer_write)
  ASIO_TEST_CASE(test_2_arg_mutable_buffer_write)
  ASIO_TEST_CASE(test_2_arg_vector_buffers_write)
  ASIO_TEST_CASE(test_2_arg_dynamic_string_write)
  ASIO_TEST_CASE(test_3_arg_nothrow_zero_buffers_write)
  ASIO_TEST_CASE(test_3_arg_nothrow_const_buffer_write)
  ASIO_TEST_CASE(test_3_arg_nothrow_mutable_buffer_write)
  ASIO_TEST_CASE(test_3_arg_nothrow_vector_buffers_write)
  ASIO_TEST_CASE(test_3_arg_nothrow_dynamic_string_write)
  ASIO_TEST_CASE(test_3_arg_const_buffer_write)
  ASIO_TEST_CASE(test_3_arg_mutable_buffer_write)
  ASIO_TEST_CASE(test_3_arg_vector_buffers_write)
  ASIO_TEST_CASE(test_3_arg_dynamic_string_write)
  ASIO_TEST_CASE(test_4_arg_const_buffer_write)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_write)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_write)
  ASIO_TEST_CASE(test_4_arg_dynamic_string_write)
  ASIO_TEST_CASE(test_3_arg_const_buffer_async_write)
  ASIO_TEST_CASE(test_3_arg_mutable_buffer_async_write)
  ASIO_TEST_CASE(test_3_arg_boost_array_buffers_async_write)
  ASIO_TEST_CASE(test_3_arg_std_array_buffers_async_write)
  ASIO_TEST_CASE(test_3_arg_vector_buffers_async_write)
  ASIO_TEST_CASE(test_3_arg_dynamic_string_async_write)
  ASIO_TEST_CASE(test_3_arg_streambuf_async_write)
  ASIO_TEST_CASE(test_4_arg_const_buffer_async_write)
  ASIO_TEST_CASE(test_4_arg_mutable_buffer_async_write)
  ASIO_TEST_CASE(test_4_arg_boost_array_buffers_async_write)
  ASIO_TEST_CASE(test_4_arg_std_array_buffers_async_write)
  ASIO_TEST_CASE(test_4_arg_vector_buffers_async_write)
  ASIO_TEST_CASE(test_4_arg_dynamic_string_async_write)
  ASIO_TEST_CASE(test_4_arg_streambuf_async_write)
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\asio_ssl.cpp
//
// asio_ssl.cpp
// ~~~~~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/ssl/impl/src.hpp"

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\libs\asio-1.30.2\src\asio.cpp
//
// asio.cpp
// ~~~~~~~~
//
// Copyright (c) 2003-2024 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#include "asio/impl/src.hpp"

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetClient\CMakeLists.txt
cmake_minimum_required(VERSION 3.16)
project(NetClient)

# Set C++ version
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Include NetCommon from relative path
set(ASIO_INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../libs/asio-1.30.2/include)
add_subdirectory(../NetCommon ${CMAKE_CURRENT_BINARY_DIR}/NetCommonBuild)

# Source files
set(SOURCES
  SimpleClient.cpp
)

# Static library for NetClient
add_library(NetClient STATIC ${SOURCES})

target_include_directories(NetClient 
  PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
  PRIVATE
    ${ASIO_INCLUDE_PATH}
)

target_link_libraries(NetClient
  PUBLIC NetCommon
)

# Executable for testing NetClient on its own
add_executable(NetClientTest SimpleClient.cpp)

target_link_libraries(NetClientTest
  PRIVATE NetClient
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetClient\SimpleClient.cpp
#include <cstdio>
#include <iostream>

#include "net_client.h"
#include "olc_net.h"

enum class CustomMsgTypes : uint32_t { FireBullet, MovePlayer };

class CustomClient : public olc::net::client_interface<CustomMsgTypes> {
public:
  bool FireBullet(float x, float y) {
    olc::net::message<CustomMsgTypes> msg;
    msg.header.id = CustomMsgTypes::FireBullet;
    msg << x << y;
    Send(msg);
  }
};

int main() {
  CustomClient c;
  c.Connect("community.onelonecoder.com", 60000);
  c.FireBullet(2.0f, 5.0f);
  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\CMakeLists.txt
# NetCommon/CMakeLists.txt

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(ASIO_INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../libs/asio-1.30.2/include)

add_library(NetCommon STATIC
  NetCommon.cpp
  net_common.h 
  net_message.h
  net_tsqueue.h
  net_server.h
  net_connection.h
  olc_net.h
)



target_include_directories(NetCommon 
  PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${ASIO_INCLUDE_PATH}
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\net_client.h
#pragma once

#include <memory>

#include "asio/io_context.hpp"
#include "net_common.h"
#include "net_connection.h"
#include "net_message.h"
#include "net_tsqueue.h"

namespace olc {
namespace net {
template <typename T> class client_interface {
public:
  client_interface() : m_socket(m_context) {
    // Intialize the socket with the io context, so it can do stuff
  }
  virtual ~client_interface() {
    // if the client is destroyed, always try and disconnect from server
    Disconnect();
  }

public:
  // Connect to server with hostname/ip-address and port
  bool Connect(const std::string &host, const uint16_t port) {
    try {
      // Resolve hostname/ip-address into tangiable physical address
      asio::ip::tcp::resolver resolver(m_context);
      asio::ip::tcp::resolver::results_type endpoints =
          resolver.resolve(host, std::to_string(port));

      // Create a connection
      m_connection = std::make_unique<connection<T>>(); // TODO

      // Tell the connection object to connect to the server
      m_connection->ConnectToServer(endpoints);

      // Start Context thread
      thrContext = std::thread([this]() { m_context.run(); });
    } catch (std::exception &e) {
      std::cerr << "Client Exception: " << e.what() << '\n';
      return false;
    }
    return true;
  }

  // Disconnect from server
  void Disconnect() {
    // If connection exists, and it's connected then...
    if (IsConnected()) {
      // ...disconnect from server gracefully
      m_connection->Disconnect();
    }

    // Either way, we're also done with the asio context...
    m_context.stop();
    // ... and its thread
    if (thrContext.joinable())
      thrContext.join();

    // Destroy the connection object
    m_connection.release();
  }

  // Check if client is actually connected to a server
  bool IsConnected() {
    if (m_connection)
      return m_connection->IsConnected();
    else
      return false;
  }

  // Retrieve queue of messages from server
  tsqueue<owned_message<T>> &Incoming() { return m_qMessagesIn; }

public:
  void Send(const message<T> &msg) {
    if (IsConnected())
      m_connection->Send(msg);
  }

protected:
  // asio context handles the data transfer
  asio::io_context m_context;
  // ..but needs a thread of its own to execute its work commands
  std::thread thrContext;
  // This is the hardware socket that is connected to the server
  asio::ip::tcp::socket m_socket;
  // The client has a single instance of a "connection" object, which handles
  // data transfer
  std::unique_ptr<connection<T>> m_connection;

private:
  tsqueue<owned_message<T>> m_qMessagesIn;
};
} // namespace net
} // namespace olc

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\net_common.h
#pragma once

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <deque>
#include <iostream>
#include <memory.h>
#include <mutex>
#include <optional>
#include <thread>
#include <vector>

#ifdef _WIN32
#define _WIN32_WINNT 0x0A00
#endif

#define ASIO_STANDALONE
#include <asio.hpp>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\net_connection.h
#pragma once

#include "net_common.h"
#include "net_message.h"
#include "net_tsqueue.h"

namespace olc {
namespace net {
template <typename T>
class connection : public std::enable_shared_from_this<connection<T>> {
 public:
  connection() {}

  virtual ~connection() {}

 public:
  bool ConnectToServer();
  bool Disconnect();
  bool IsConnected() const;

 public:
  bool Send(const message<T>& msg);

 protected:
  // Each connection has a unique socket to a remote
  asio::ip::tcp::socket m_socket;

  // This context is shared with the whole asio instance
  asio::io_context& m_asioContext;

  // This queue holds all messages to be sent to the remote side
  // of this connection
  tsqueue<message<T>> m_qMessagesOut;

  // This queue holds all messages that have been recieved from
  // the remote side of this connection. Note that it is a reference
  // as the "owner" of this connection is expected to provide a queue
  tsqueue<owned_message<T>>& m_qMessagesIn;
};
}  // namespace net
}  // namespace olc

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\net_message.h
#pragma once
#include <cstring>

#include "net_common.h"

namespace olc {
namespace net {
// Message header is sent at the start of all messages. The template allows us
// to use "enum class" to ensure that the messages are valid at compile time.
template <typename T>
struct message_header {
    T id{};
    uint32_t size = 0;
};

template <typename T>
struct message {
    message_header<T> header{};
    std::vector<uint8_t> body;

    // Returns the size of the entire message packet in bytes
    size_t size() const { return sizeof(message_header<T>) + body.size(); }

    // Override for std::cout compatibility - produces a friendly description of
    // the message
    friend std::ostream &operator<<(std::ostream &os, const message<T> &msg) {
        os << "ID: " << int(msg.header.id) << " Size: " << msg.header.size();
        return os;
    }

    // Pushes any POD-like data into the message buffer
    template <typename DataType>
    friend message<T> &operator<<(message<T> &msg, const DataType &data) {
        // Check that the type of data being pushed is trivially copyable
        static_assert(std::is_standard_layout<DataType>::value,
                      "Data is too complex to be pushed into the vector.");

        // Cache current size of vector, as this will be the point we insert the
        // data
        size_t i = msg.body.size();

        // Resize the vector by the size of the data being pushed
        msg.body.resize(msg.body.size() + sizeof(DataType));

        // Physically copy the data into the newly allocated vector space
        std::memcpy(msg.body.data() + i, &data, sizeof(DataType));

        // Recalculate the size
        msg.header.size = msg.size();

        return msg;
    }

    template <typename DataType>
    friend message<T> &operator>>(message<T> &msg, DataType &data) {
        // Check that the type of the data being pushed is trivially copyable
        static_assert(std::is_standard_layout<DataType>::value,
                      "Data is too complex to be popped from the vector.");

        // Cache the location torwards the end of the vector where the pulled data
        // starts
        size_t i = msg.body.size() - sizeof(DataType);

        // Physically copy the data from the vector into the users variable
        std::memcpy(&data, msg.body.data() + i, sizeof(DataType));

        // Shrink the vector and remove read bytes, and reset end position
        msg.body.resize(i);

        // Recalculate the message size
        msg.header.size = msg.size();

        // Return the target message so that it can be "chained"
        return msg;
    }
};

// Forward declare the connection
template <typename T>
class connection;

template <typename T>
struct owned_message {
    std::shared_ptr<connection<T>> remote = nullptr;
    message<T> msg;

    // A friendly string maker
    friend std::ostream &operator<<(std::ostream &os, const owned_message<T> &msg) {
        os << msg.msg;
        return os;
    }
};
}  // namespace net
}  // namespace olc

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\net_server.h
#pragma once

#include <exception>

#include "net_common.h"
#include "net_connection.h"
#include "net_message.h"
#include "net_tsqueue.h"

namespace olc
{
namespace net
{
template <typename T>
class server_interface
{
public:
  server_interface(uint16_t port)
      : m_asioAcceptor(m_asioContext, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port))
  {
  }
  virtual ~server_interface()
  {
    Stop();
  }

  bool Start()
  {
    try
    {
      WaitForClientConnection();

      m_threadContext = std::thread(
          [this]()
          {
            m_asioContext.run();
          });
    }
    catch (std::exception &e)
    {
      // Something prohibited the server from listening
      std::cerr << "[SERVER] Exception: " << e.what() << "\n";
      return false;
    }

    std::cout << "[SERVER] Started!\n";
    return true;
  }

  void Stop()
  {
    // Request the context to close
    m_asioContext.stop();

    // Tidy up the context thread
    if (m_threadContext.joinable())
      m_threadContext.join();

    // Inform someone, anybody, if they care...
    std::cout << "[SERVER] Stopped!\n";
  }

  // ASYNC - Instruct asio to wait for connection
  void WaitForClientConnection()
  {
    m_asioAcceptor.async_accept(
        [this](std::error_code ec, asio::ip::tcp::socket socket)
        {
          if (!ec)
          {
            std::cout << "[SERVER] New Connection: " << socket.remote_endpoint() << "\n";

            // std::shared_ptr<connection<T>> newconn = std::make_shared<connection<T>>(
            //     connection<T>::owner::server, m_asioContext, std::move(socket), m_qMessagesIn);
            //
            // // Give the user server a chance to deny connection
            // if (OnClientConnect(newconn))
            // {
            //   // Connection allowed, so add to container of new connections
            //   m_deqConnections.push_back(std::move(newconn));
            //
            //   m_deqConnections.back()->ConnectToClient(nIDCounter++);
            //
            //   std::cout << "[" << m_deqConnections.back()->GetID() << "] Connection Approved\n";
            // }
            // else
            // {
            //   std::cout << "[-----] Connection Denied\n";
            // }
          }
          else
          {
            // Error has ocurred during acceptance
            std::cout << "[SERVER] New Connection Error: " << ec.message() << "\n";
          }

          // Prime the asio context with more work - again simply wait
          // for another connection
          WaitForClientConnection();
        });
  }

  // Send message to a specific client
  void MessageClient(std::shared_ptr<connection<T>> client, const message<T> &msg)
  {
    if (client && client->IsConnected())
    {
      client->Send(msg);
    }
    else
    {
      OnClientDisconnect(client);
      client.reset();
      m_deqConnections.erase(std::remove(m_deqConnections.begin(), m_deqConnections.end(), client),
                             m_deqConnections.end());
    }
  }

  // Send message to all clients
  void MessageAllClients(const message<T> &msg,
                         std::shared_ptr<connection<T>> pIgnoreClient = nullptr)
  {
    bool bInvalidClientExists = false;

    for (auto &client : m_deqConnections)
    {
      // Check client is connected...
      if (client && client->IsConnected())
      {
        // ..it is!
        if (client != pIgnoreClient)
          client->Send(msg);
      }
      else
      {
        // The client couldn't be contacted, so assume it has disconnected
        OnClientDisconnect(client);
        client.reset();
        bInvalidClientExists = true;
      }
    }

    if (bInvalidClientExists)
      m_deqConnections.erase(
          std::remove(m_deqConnections.begin(), m_deqConnections.end(), nullptr));
  }

  void Update(size_t nMaxMessages = -1)
  {
    size_t nMessageCount = 0;
    while (nMessageCount < nMaxMessages && !m_qMessagesIn.empty())
    {
      // Grab the front message
      auto msg = m_qMessagesIn.pop_front();

      // Pass to the message handler
      OnMessage(msg.remote, msg.msg);

      nMessageCount++;
    }
  }

protected:
  // Called when a client connects, you can veto the connection by returning
  // false
  virtual bool OnClientConnect(std::shared_ptr<connection<T>> client)
  {
    return false;
  }

  // Called when a client appears to have disconnected
  virtual void OnClientDisconnect(std::shared_ptr<connection<T>> client)
  {
  }

  // Called when a message arrives
  virtual void OnMessage(std::shared_ptr<connection<T>> client, message<T> &msg)
  {
  }

protected:
  // Thread safe Queue for incoming message packets
  tsqueue<owned_message<T>> m_qMessagesIn;

  // Container of active validated connections
  std::deque<std::shared_ptr<connection<T>>> m_deqConnections;

  // Order of declaration is important - it is also the order for initialization
  asio::io_context m_asioContext;
  std::thread m_threadContext;

  // These things need an asio context
  asio::ip::tcp::acceptor m_asioAcceptor;

  // Clients will be identified in the "wider system" via an ID
  uint32_t nIDCounter = 10000;
};
}  // namespace net
}  // namespace olc

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\net_tsqueue.h
#pragma once
#include "net_common.h"
#include <mutex>

namespace olc {
namespace net {
template <typename T> class tsqueue {
public:
  tsqueue() = default;
  tsqueue(const tsqueue<T>&) = delete;
  virtual ~tsqueue() { clear(); }
public:
  const T& front(){
    std::scoped_lock lock(muxQueue);
    return deqQueue.front();
  }
  const T& back(){
    std::scoped_lock lock(muxQueue);
    return deqQueue.back();
  }
  void push_back(const T& item){
    std::scoped_lock lock(muxQueue);
    deqQueue.emplace_back(std::move(item));
  }
  void push_front(const T& item){
    std::scoped_lock lock(muxQueue);
    deqQueue.emplace_front(std::move(item));
  }
  bool empty(){
    std::scoped_lock lock(muxQueue);
    return deqQueue.empty();
  }
  size_t count(){
    std::scoped_lock lock(muxQueue);
    return deqQueue.size();
  }
  void clear(){
    std::scoped_lock lock(muxQueue);
    deqQueue.clear();
  }
  T pop_front(){
    std::scoped_lock lock(muxQueue);
    auto t = std::move(deqQueue.front());
    deqQueue.pop_front();
    return t;
  }
  T pop_back(){
    std::scoped_lock lock(muxQueue);
    auto t = std::move(deqQueue.back());
    deqQueue.pop_back();
    return t;
  }
protected:
  std::mutex muxQueue;
  std::deque<T> deqQueue;
};
} // namespace net
} // namespace olc

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\NetCommon.cpp
// Dummy file to trick CMake into compiling this as a C++ project
//
//
//
//
//     |\__/,|   (`\
//   _.|o o  |_   ) )
//  -(((---(((-------- ignore me...
//
//
//
//
//

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetCommon\olc_net.h
#pragma once

#include "net_client.h"
#include "net_common.h"
#include "net_connection.h"
#include "net_message.h"
#include "net_server.h"
#include "net_tsqueue.h"

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetServer\CMakeLists.txt
cmake_minimum_required(VERSION 3.16)
project(SimpleServer)

# C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ASIO + NetCommon
set(ASIO_INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../libs/asio-1.30.2/include)
add_subdirectory(../NetCommon ${CMAKE_CURRENT_BINARY_DIR}/NetCommonBuild)

# Our library source (SimpleServer.cpp only!)
set(SOURCES
  SimpleServer.cpp
)

add_library(${PROJECT_NAME} STATIC ${SOURCES})

target_include_directories(${PROJECT_NAME} 
  PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${ASIO_INCLUDE_PATH}
)

target_link_libraries(${PROJECT_NAME}
  PUBLIC NetCommon
)

# The executable: ONLY main.cpp
add_executable(NetServerTest main.cpp)

target_link_libraries(NetServerTest
  PRIVATE ${PROJECT_NAME}
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetServer\main.cpp
#include "SimpleServer.h"

int main()
{
  CustomServer server(60000);
  server.Start();

  while (1)
  {
    server.Update();
  }

  return 0;
}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetServer\SimpleServer.cpp
#include "SimpleServer.h"

CustomServer::CustomServer(uint16_t nPort) : olc::net::server_interface<CustomMsgTypes>(nPort){

}

bool OnClientConnect(std::shared_ptr<CustomConnection> client)
{
  return true;
}

void OnClientDisconnect(std::shared_ptr<CustomConnection> client)
{

}

void OnMessage(std::shared_ptr<CustomConnection> client, CustomMessage& msg)
{

}

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\NetServer\SimpleServer.h
#include "olc_net.h"

enum class CustomMsgTypes : uint32_t
{
  ServerAccept,
  ServerDeny,
  ServerPing,
  MessageAll,
  ServerMessage,
};
using CustomConnection = olc::net::connection<CustomMsgTypes>;
using CustomMessage = olc::net::message<CustomMsgTypes>;

class CustomServer : public olc::net::server_interface<CustomMsgTypes>
{
public:
  CustomServer(uint16_t nPort);

protected:
  virtual bool OnClientConnect(std::shared_ptr<CustomConnection> client);

  virtual void OnClientDisconnect(std::shared_ptr<CustomConnection> client);

  virtual void OnMessage(std::shared_ptr<CustomConnection> client, CustomMessage& msg);
};

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

project(ASIOServer VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_subdirectory(
  NetCommon
  NetClient
)

add_executable(${PROJECT_NAME}
  main.cpp
)

target_link_libraries(${PROJECT_NAME} 
  ws2_32
)

target_include_directories(${PROJECT_NAME}
  PRIVATE
    NetCommon
    NetClient
)

target_include_directories(${PROJECT_NAME}
  PRIVATE
    libs/asio-1.30.2/include
)

// ----------------------------------------

// C:\Users\wiley\repos\ASIOServer\main.cpp
// std
#include <iostream>
#include <string>
#include <thread>

// libs
#define ASIO_STANDALONE
#include <asio.hpp>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>

std::vector<char> vBuffer(20 * 1024);

void GrabSomeData(asio::ip::tcp::socket &socket) {
  socket.async_read_some(asio::buffer(vBuffer.data(), vBuffer.size()),
                         [&](std::error_code ec, std::size_t length) {
                           if (!ec) {
                             std::cout << "\n\nRead " << length << " bytes\n\n";

                             for (int i = 0; i < length; i++) {
                               std::cout << vBuffer[i];
                             }

                             GrabSomeData(socket);
                           }
                         });
}

int main() {
  std::cout << "Hello World!" << std::endl;

  asio::error_code ec;

  // Create a "context" - essentially a platform specific interface
  asio::io_context context;

  // Give some fake work to asio so the context doesnt finish
  asio::io_context::work idleWork(context);

  // Start the context
  std::thread thrContext = std::thread([&]() { context.run(); });

  // Get the address of the thing we want to connect to
  asio::ip::tcp::endpoint endpoint(asio::ip::make_address("77.111.241.88", ec),
                                   80);

  // Create a socket, the context will deliver the implementation
  asio::ip::tcp::socket socket(context);

  // Tell the socket to try and connect
  socket.connect(endpoint, ec);

  if (!ec) {
    std::cout << "Connected!" << std::endl;
  } else {
    std::cout << "Failed to connect to address:\n" << ec.message() << std::endl;
  }

  if (socket.is_open()) {
    GrabSomeData(socket);
    std::string sRequest = "GET /index.html HTTP/1.1\r\n"
                           "Host: thegreenlionpub.se/\r\n"
                           "Connection: close\r\n\r\n";
    socket.write_some(asio::buffer(sRequest.data(), sRequest.size()), ec);

    using namespace std::chrono_literals;
    std::this_thread::sleep_for(20000ms);
  }

  std::cin.ignore();
  return 0;
}

// ----------------------------------------

